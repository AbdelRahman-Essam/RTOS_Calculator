
RTOS_LAB1_ATMEGA32.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d5a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000078  00800060  00002d5a  00002dee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006b1  008000d8  008000d8  00002e66  2**0
                  ALLOC
  3 .stab         000035a0  00000000  00000000  00002e68  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000c05  00000000  00000000  00006408  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000700d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000801  00000000  00000000  0000714d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002caa  00000000  00000000  0000794e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000e1b  00000000  00000000  0000a5f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000298d  00000000  00000000  0000b413  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000005b0  00000000  00000000  0000dda0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000116a  00000000  00000000  0000e350  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001d87  00000000  00000000  0000f4ba  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 0000048d  00000000  00000000  00011241  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000000a8  00000000  00000000  000116ce  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       8:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      10:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      14:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      18:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      1c:	0c 94 3d 07 	jmp	0xe7a	; 0xe7a <__vector_7>
      20:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      24:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      28:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      2c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	std	Y+40, r29	; 0x28
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	std	Y+56, r1	; 0x38
      62:	ba ab       	std	Y+50, r27	; 0x32
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	std	Y+51, r10	; 0x33
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	std	Y+54, r27	; 0x36
      96:	aa aa       	std	Y+50, r10	; 0x32
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	ldd	r30, Z+49	; 0x31
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <KeyPad_u8AdjustKeyNumber_4x4+0x30>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d8 e0       	ldi	r29, 0x08	; 8
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	ea e5       	ldi	r30, 0x5A	; 90
      ea:	fd e2       	ldi	r31, 0x2D	; 45
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	a8 3d       	cpi	r26, 0xD8	; 216
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	17 e0       	ldi	r17, 0x07	; 7
      fa:	a8 ed       	ldi	r26, 0xD8	; 216
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	a9 38       	cpi	r26, 0x89	; 137
     104:	b1 07       	cpc	r27, r17
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 8e 0b 	call	0x171c	; 0x171c <main>
     10c:	0c 94 ab 16 	jmp	0x2d56	; 0x2d56 <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     114:	af 92       	push	r10
     116:	bf 92       	push	r11
     118:	cf 92       	push	r12
     11a:	df 92       	push	r13
     11c:	ef 92       	push	r14
     11e:	ff 92       	push	r15
     120:	0f 93       	push	r16
     122:	1f 93       	push	r17
     124:	cf 93       	push	r28
     126:	df 93       	push	r29
     128:	7c 01       	movw	r14, r24
     12a:	04 2f       	mov	r16, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     12c:	8a e1       	ldi	r24, 0x1A	; 26
     12e:	90 e0       	ldi	r25, 0x00	; 0
     130:	0e 94 d5 03 	call	0x7aa	; 0x7aa <pvPortMalloc>
     134:	c8 2e       	mov	r12, r24
     136:	e6 01       	movw	r28, r12
     138:	6e 01       	movw	r12, r28
     13a:	d9 2e       	mov	r13, r25
     13c:	e6 01       	movw	r28, r12
	if( pxCoRoutine )
     13e:	20 97       	sbiw	r28, 0x00	; 0
     140:	09 f4       	brne	.+2      	; 0x144 <xCoRoutineCreate+0x30>
     142:	58 c0       	rjmp	.+176    	; 0x1f4 <xCoRoutineCreate+0xe0>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     144:	80 91 d8 00 	lds	r24, 0x00D8
     148:	90 91 d9 00 	lds	r25, 0x00D9
     14c:	00 97       	sbiw	r24, 0x00	; 0
     14e:	11 f5       	brne	.+68     	; 0x194 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     150:	d0 92 d9 00 	sts	0x00D9, r13
     154:	c0 92 d8 00 	sts	0x00D8, r12
	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     158:	0f 2e       	mov	r0, r31
     15a:	fe ee       	ldi	r31, 0xEE	; 238
     15c:	cf 2e       	mov	r12, r31
     15e:	f0 e0       	ldi	r31, 0x00	; 0
     160:	df 2e       	mov	r13, r31
     162:	f0 2d       	mov	r31, r0
     164:	c6 01       	movw	r24, r12
     166:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     16a:	0f 2e       	mov	r0, r31
     16c:	f7 ef       	ldi	r31, 0xF7	; 247
     16e:	af 2e       	mov	r10, r31
     170:	f0 e0       	ldi	r31, 0x00	; 0
     172:	bf 2e       	mov	r11, r31
     174:	f0 2d       	mov	r31, r0
     176:	c5 01       	movw	r24, r10
     178:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     17c:	8a ed       	ldi	r24, 0xDA	; 218
     17e:	90 e0       	ldi	r25, 0x00	; 0
     180:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     184:	d0 92 eb 00 	sts	0x00EB, r13
     188:	c0 92 ea 00 	sts	0x00EA, r12
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     18c:	b0 92 ed 00 	sts	0x00ED, r11
     190:	a0 92 ec 00 	sts	0x00EC, r10
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     194:	19 8e       	std	Y+25, r1	; 0x19
     196:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     198:	8f ef       	ldi	r24, 0xFF	; 255
     19a:	8e 8b       	std	Y+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     19c:	0f 8b       	std	Y+23, r16	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     19e:	fe 01       	movw	r30, r28
     1a0:	e1 92       	st	Z+, r14
     1a2:	f1 92       	st	Z+, r15
     1a4:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1a6:	cf 01       	movw	r24, r30
     1a8:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1ac:	ce 01       	movw	r24, r28
     1ae:	0c 96       	adiw	r24, 0x0c	; 12
     1b0:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1b4:	d9 87       	std	Y+9, r29	; 0x09
     1b6:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1b8:	db 8b       	std	Y+19, r29	; 0x13
     1ba:	ca 8b       	std	Y+18, r28	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     1bc:	86 e0       	ldi	r24, 0x06	; 6
     1be:	9f ef       	ldi	r25, 0xFF	; 255
     1c0:	9d 87       	std	Y+13, r25	; 0x0d
     1c2:	8c 87       	std	Y+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     1c4:	8e 89       	ldd	r24, Y+22	; 0x16
     1c6:	90 91 e3 00 	lds	r25, 0x00E3
     1ca:	98 17       	cp	r25, r24
     1cc:	10 f4       	brcc	.+4      	; 0x1d2 <xCoRoutineCreate+0xbe>
     1ce:	80 93 e3 00 	sts	0x00E3, r24
     1d2:	90 e0       	ldi	r25, 0x00	; 0
     1d4:	9c 01       	movw	r18, r24
     1d6:	22 0f       	add	r18, r18
     1d8:	33 1f       	adc	r19, r19
     1da:	22 0f       	add	r18, r18
     1dc:	33 1f       	adc	r19, r19
     1de:	22 0f       	add	r18, r18
     1e0:	33 1f       	adc	r19, r19
     1e2:	82 0f       	add	r24, r18
     1e4:	93 1f       	adc	r25, r19
     1e6:	8c 51       	subi	r24, 0x1C	; 28
     1e8:	9f 4f       	sbci	r25, 0xFF	; 255
     1ea:	b8 01       	movw	r22, r16
     1ec:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>

		xReturn = pdPASS;
     1f0:	81 e0       	ldi	r24, 0x01	; 1
     1f2:	01 c0       	rjmp	.+2      	; 0x1f6 <xCoRoutineCreate+0xe2>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     1f4:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
     1f6:	df 91       	pop	r29
     1f8:	cf 91       	pop	r28
     1fa:	1f 91       	pop	r17
     1fc:	0f 91       	pop	r16
     1fe:	ff 90       	pop	r15
     200:	ef 90       	pop	r14
     202:	df 90       	pop	r13
     204:	cf 90       	pop	r12
     206:	bf 90       	pop	r11
     208:	af 90       	pop	r10
     20a:	08 95       	ret

0000020c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     20c:	0f 93       	push	r16
     20e:	1f 93       	push	r17
     210:	cf 93       	push	r28
     212:	df 93       	push	r29
     214:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     216:	c0 91 e8 00 	lds	r28, 0x00E8
     21a:	d0 91 e9 00 	lds	r29, 0x00E9
     21e:	c8 0f       	add	r28, r24
     220:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     222:	80 91 d8 00 	lds	r24, 0x00D8
     226:	90 91 d9 00 	lds	r25, 0x00D9
     22a:	02 96       	adiw	r24, 0x02	; 2
     22c:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     230:	60 91 d8 00 	lds	r22, 0x00D8
     234:	70 91 d9 00 	lds	r23, 0x00D9
     238:	fb 01       	movw	r30, r22
     23a:	d3 83       	std	Z+3, r29	; 0x03
     23c:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     23e:	80 91 e8 00 	lds	r24, 0x00E8
     242:	90 91 e9 00 	lds	r25, 0x00E9
     246:	c8 17       	cp	r28, r24
     248:	d9 07       	cpc	r29, r25
     24a:	48 f4       	brcc	.+18     	; 0x25e <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     24c:	6e 5f       	subi	r22, 0xFE	; 254
     24e:	7f 4f       	sbci	r23, 0xFF	; 255
     250:	80 91 ec 00 	lds	r24, 0x00EC
     254:	90 91 ed 00 	lds	r25, 0x00ED
     258:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInsert>
     25c:	08 c0       	rjmp	.+16     	; 0x26e <vCoRoutineAddToDelayedList+0x62>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     25e:	6e 5f       	subi	r22, 0xFE	; 254
     260:	7f 4f       	sbci	r23, 0xFF	; 255
     262:	80 91 ea 00 	lds	r24, 0x00EA
     266:	90 91 eb 00 	lds	r25, 0x00EB
     26a:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInsert>
	}

	if( pxEventList )
     26e:	01 15       	cp	r16, r1
     270:	11 05       	cpc	r17, r1
     272:	49 f0       	breq	.+18     	; 0x286 <vCoRoutineAddToDelayedList+0x7a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     274:	60 91 d8 00 	lds	r22, 0x00D8
     278:	70 91 d9 00 	lds	r23, 0x00D9
     27c:	64 5f       	subi	r22, 0xF4	; 244
     27e:	7f 4f       	sbci	r23, 0xFF	; 255
     280:	c8 01       	movw	r24, r16
     282:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInsert>
	}
}
     286:	df 91       	pop	r29
     288:	cf 91       	pop	r28
     28a:	1f 91       	pop	r17
     28c:	0f 91       	pop	r16
     28e:	08 95       	ret

00000290 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     290:	cf 92       	push	r12
     292:	df 92       	push	r13
     294:	ef 92       	push	r14
     296:	ff 92       	push	r15
     298:	0f 93       	push	r16
     29a:	1f 93       	push	r17
     29c:	cf 93       	push	r28
     29e:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2a0:	80 91 da 00 	lds	r24, 0x00DA
     2a4:	88 23       	and	r24, r24
     2a6:	b9 f1       	breq	.+110    	; 0x316 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2a8:	0f 2e       	mov	r0, r31
     2aa:	ff ed       	ldi	r31, 0xDF	; 223
     2ac:	ef 2e       	mov	r14, r31
     2ae:	f0 e0       	ldi	r31, 0x00	; 0
     2b0:	ff 2e       	mov	r15, r31
     2b2:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     2b4:	0f 2e       	mov	r0, r31
     2b6:	fa ed       	ldi	r31, 0xDA	; 218
     2b8:	cf 2e       	mov	r12, r31
     2ba:	f0 e0       	ldi	r31, 0x00	; 0
     2bc:	df 2e       	mov	r13, r31
     2be:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     2c0:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     2c2:	d7 01       	movw	r26, r14
     2c4:	ed 91       	ld	r30, X+
     2c6:	fc 91       	ld	r31, X
     2c8:	c6 81       	ldd	r28, Z+6	; 0x06
     2ca:	d7 81       	ldd	r29, Z+7	; 0x07
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     2cc:	ce 01       	movw	r24, r28
     2ce:	0c 96       	adiw	r24, 0x0c	; 12
     2d0:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     2d4:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     2d6:	8e 01       	movw	r16, r28
     2d8:	0e 5f       	subi	r16, 0xFE	; 254
     2da:	1f 4f       	sbci	r17, 0xFF	; 255
     2dc:	c8 01       	movw	r24, r16
     2de:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     2e2:	8e 89       	ldd	r24, Y+22	; 0x16
     2e4:	90 91 e3 00 	lds	r25, 0x00E3
     2e8:	98 17       	cp	r25, r24
     2ea:	10 f4       	brcc	.+4      	; 0x2f0 <vCoRoutineSchedule+0x60>
     2ec:	80 93 e3 00 	sts	0x00E3, r24
     2f0:	90 e0       	ldi	r25, 0x00	; 0
     2f2:	9c 01       	movw	r18, r24
     2f4:	22 0f       	add	r18, r18
     2f6:	33 1f       	adc	r19, r19
     2f8:	22 0f       	add	r18, r18
     2fa:	33 1f       	adc	r19, r19
     2fc:	22 0f       	add	r18, r18
     2fe:	33 1f       	adc	r19, r19
     300:	82 0f       	add	r24, r18
     302:	93 1f       	adc	r25, r19
     304:	8c 51       	subi	r24, 0x1C	; 28
     306:	9f 4f       	sbci	r25, 0xFF	; 255
     308:	b8 01       	movw	r22, r16
     30a:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     30e:	f6 01       	movw	r30, r12
     310:	80 81       	ld	r24, Z
     312:	88 23       	and	r24, r24
     314:	a9 f6       	brne	.-86     	; 0x2c0 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     316:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <xTaskGetTickCount>
     31a:	20 91 e4 00 	lds	r18, 0x00E4
     31e:	30 91 e5 00 	lds	r19, 0x00E5
     322:	82 1b       	sub	r24, r18
     324:	93 0b       	sbc	r25, r19
     326:	90 93 e7 00 	sts	0x00E7, r25
     32a:	80 93 e6 00 	sts	0x00E6, r24
     32e:	74 c0       	rjmp	.+232    	; 0x418 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     330:	20 91 e8 00 	lds	r18, 0x00E8
     334:	30 91 e9 00 	lds	r19, 0x00E9
     338:	2f 5f       	subi	r18, 0xFF	; 255
     33a:	3f 4f       	sbci	r19, 0xFF	; 255
     33c:	30 93 e9 00 	sts	0x00E9, r19
     340:	20 93 e8 00 	sts	0x00E8, r18
		xPassedTicks--;
     344:	01 97       	sbiw	r24, 0x01	; 1
     346:	90 93 e7 00 	sts	0x00E7, r25
     34a:	80 93 e6 00 	sts	0x00E6, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     34e:	21 15       	cp	r18, r1
     350:	31 05       	cpc	r19, r1
     352:	81 f4       	brne	.+32     	; 0x374 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     354:	80 91 ea 00 	lds	r24, 0x00EA
     358:	90 91 eb 00 	lds	r25, 0x00EB
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     35c:	20 91 ec 00 	lds	r18, 0x00EC
     360:	30 91 ed 00 	lds	r19, 0x00ED
     364:	30 93 eb 00 	sts	0x00EB, r19
     368:	20 93 ea 00 	sts	0x00EA, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     36c:	90 93 ed 00 	sts	0x00ED, r25
     370:	80 93 ec 00 	sts	0x00EC, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     374:	e0 91 ea 00 	lds	r30, 0x00EA
     378:	f0 91 eb 00 	lds	r31, 0x00EB
     37c:	80 81       	ld	r24, Z
     37e:	88 23       	and	r24, r24
     380:	09 f4       	brne	.+2      	; 0x384 <vCoRoutineSchedule+0xf4>
     382:	4a c0       	rjmp	.+148    	; 0x418 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     384:	05 80       	ldd	r0, Z+5	; 0x05
     386:	f6 81       	ldd	r31, Z+6	; 0x06
     388:	e0 2d       	mov	r30, r0
     38a:	c6 81       	ldd	r28, Z+6	; 0x06
     38c:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     38e:	20 91 e8 00 	lds	r18, 0x00E8
     392:	30 91 e9 00 	lds	r19, 0x00E9
     396:	8a 81       	ldd	r24, Y+2	; 0x02
     398:	9b 81       	ldd	r25, Y+3	; 0x03
     39a:	28 17       	cp	r18, r24
     39c:	39 07       	cpc	r19, r25
     39e:	78 f4       	brcc	.+30     	; 0x3be <vCoRoutineSchedule+0x12e>
     3a0:	3b c0       	rjmp	.+118    	; 0x418 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     3a2:	05 80       	ldd	r0, Z+5	; 0x05
     3a4:	f6 81       	ldd	r31, Z+6	; 0x06
     3a6:	e0 2d       	mov	r30, r0
     3a8:	c6 81       	ldd	r28, Z+6	; 0x06
     3aa:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     3ac:	2a 81       	ldd	r18, Y+2	; 0x02
     3ae:	3b 81       	ldd	r19, Y+3	; 0x03
     3b0:	80 91 e8 00 	lds	r24, 0x00E8
     3b4:	90 91 e9 00 	lds	r25, 0x00E9
     3b8:	82 17       	cp	r24, r18
     3ba:	93 07       	cpc	r25, r19
     3bc:	68 f1       	brcs	.+90     	; 0x418 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     3be:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     3c0:	8e 01       	movw	r16, r28
     3c2:	0e 5f       	subi	r16, 0xFE	; 254
     3c4:	1f 4f       	sbci	r17, 0xFF	; 255
     3c6:	c8 01       	movw	r24, r16
     3c8:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     3cc:	8c 89       	ldd	r24, Y+20	; 0x14
     3ce:	9d 89       	ldd	r25, Y+21	; 0x15
     3d0:	00 97       	sbiw	r24, 0x00	; 0
     3d2:	21 f0       	breq	.+8      	; 0x3dc <vCoRoutineSchedule+0x14c>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     3d4:	ce 01       	movw	r24, r28
     3d6:	0c 96       	adiw	r24, 0x0c	; 12
     3d8:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     3dc:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     3de:	8e 89       	ldd	r24, Y+22	; 0x16
     3e0:	90 91 e3 00 	lds	r25, 0x00E3
     3e4:	98 17       	cp	r25, r24
     3e6:	10 f4       	brcc	.+4      	; 0x3ec <vCoRoutineSchedule+0x15c>
     3e8:	80 93 e3 00 	sts	0x00E3, r24
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	9c 01       	movw	r18, r24
     3f0:	22 0f       	add	r18, r18
     3f2:	33 1f       	adc	r19, r19
     3f4:	22 0f       	add	r18, r18
     3f6:	33 1f       	adc	r19, r19
     3f8:	22 0f       	add	r18, r18
     3fa:	33 1f       	adc	r19, r19
     3fc:	82 0f       	add	r24, r18
     3fe:	93 1f       	adc	r25, r19
     400:	8c 51       	subi	r24, 0x1C	; 28
     402:	9f 4f       	sbci	r25, 0xFF	; 255
     404:	b8 01       	movw	r22, r16
     406:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     40a:	e0 91 ea 00 	lds	r30, 0x00EA
     40e:	f0 91 eb 00 	lds	r31, 0x00EB
     412:	80 81       	ld	r24, Z
     414:	88 23       	and	r24, r24
     416:	29 f6       	brne	.-118    	; 0x3a2 <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     418:	80 91 e6 00 	lds	r24, 0x00E6
     41c:	90 91 e7 00 	lds	r25, 0x00E7
     420:	00 97       	sbiw	r24, 0x00	; 0
     422:	09 f0       	breq	.+2      	; 0x426 <vCoRoutineSchedule+0x196>
     424:	85 cf       	rjmp	.-246    	; 0x330 <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     426:	80 91 e8 00 	lds	r24, 0x00E8
     42a:	90 91 e9 00 	lds	r25, 0x00E9
     42e:	90 93 e5 00 	sts	0x00E5, r25
     432:	80 93 e4 00 	sts	0x00E4, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     436:	40 91 e3 00 	lds	r20, 0x00E3
     43a:	84 2f       	mov	r24, r20
     43c:	90 e0       	ldi	r25, 0x00	; 0
     43e:	fc 01       	movw	r30, r24
     440:	ee 0f       	add	r30, r30
     442:	ff 1f       	adc	r31, r31
     444:	ee 0f       	add	r30, r30
     446:	ff 1f       	adc	r31, r31
     448:	ee 0f       	add	r30, r30
     44a:	ff 1f       	adc	r31, r31
     44c:	e8 0f       	add	r30, r24
     44e:	f9 1f       	adc	r31, r25
     450:	ec 51       	subi	r30, 0x1C	; 28
     452:	ff 4f       	sbci	r31, 0xFF	; 255
     454:	20 81       	ld	r18, Z
     456:	22 23       	and	r18, r18
     458:	e9 f4       	brne	.+58     	; 0x494 <vCoRoutineSchedule+0x204>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     45a:	44 23       	and	r20, r20
     45c:	31 f4       	brne	.+12     	; 0x46a <vCoRoutineSchedule+0x1da>
     45e:	55 c0       	rjmp	.+170    	; 0x50a <vCoRoutineSchedule+0x27a>
     460:	44 23       	and	r20, r20
     462:	29 f4       	brne	.+10     	; 0x46e <vCoRoutineSchedule+0x1de>
     464:	40 93 e3 00 	sts	0x00E3, r20
     468:	50 c0       	rjmp	.+160    	; 0x50a <vCoRoutineSchedule+0x27a>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     46a:	24 ee       	ldi	r18, 0xE4	; 228
     46c:	30 e0       	ldi	r19, 0x00	; 0
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     46e:	41 50       	subi	r20, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     470:	84 2f       	mov	r24, r20
     472:	90 e0       	ldi	r25, 0x00	; 0
     474:	fc 01       	movw	r30, r24
     476:	ee 0f       	add	r30, r30
     478:	ff 1f       	adc	r31, r31
     47a:	ee 0f       	add	r30, r30
     47c:	ff 1f       	adc	r31, r31
     47e:	ee 0f       	add	r30, r30
     480:	ff 1f       	adc	r31, r31
     482:	e8 0f       	add	r30, r24
     484:	f9 1f       	adc	r31, r25
     486:	e2 0f       	add	r30, r18
     488:	f3 1f       	adc	r31, r19
     48a:	50 81       	ld	r21, Z
     48c:	55 23       	and	r21, r21
     48e:	41 f3       	breq	.-48     	; 0x460 <vCoRoutineSchedule+0x1d0>
     490:	40 93 e3 00 	sts	0x00E3, r20
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     494:	9c 01       	movw	r18, r24
     496:	22 0f       	add	r18, r18
     498:	33 1f       	adc	r19, r19
     49a:	22 0f       	add	r18, r18
     49c:	33 1f       	adc	r19, r19
     49e:	22 0f       	add	r18, r18
     4a0:	33 1f       	adc	r19, r19
     4a2:	28 0f       	add	r18, r24
     4a4:	39 1f       	adc	r19, r25
     4a6:	d9 01       	movw	r26, r18
     4a8:	ac 51       	subi	r26, 0x1C	; 28
     4aa:	bf 4f       	sbci	r27, 0xFF	; 255
     4ac:	11 96       	adiw	r26, 0x01	; 1
     4ae:	ed 91       	ld	r30, X+
     4b0:	fc 91       	ld	r31, X
     4b2:	12 97       	sbiw	r26, 0x02	; 2
     4b4:	02 80       	ldd	r0, Z+2	; 0x02
     4b6:	f3 81       	ldd	r31, Z+3	; 0x03
     4b8:	e0 2d       	mov	r30, r0
     4ba:	12 96       	adiw	r26, 0x02	; 2
     4bc:	fc 93       	st	X, r31
     4be:	ee 93       	st	-X, r30
     4c0:	11 97       	sbiw	r26, 0x01	; 1
     4c2:	29 51       	subi	r18, 0x19	; 25
     4c4:	3f 4f       	sbci	r19, 0xFF	; 255
     4c6:	e2 17       	cp	r30, r18
     4c8:	f3 07       	cpc	r31, r19
     4ca:	91 f4       	brne	.+36     	; 0x4f0 <vCoRoutineSchedule+0x260>
     4cc:	22 81       	ldd	r18, Z+2	; 0x02
     4ce:	33 81       	ldd	r19, Z+3	; 0x03
     4d0:	ac 01       	movw	r20, r24
     4d2:	44 0f       	add	r20, r20
     4d4:	55 1f       	adc	r21, r21
     4d6:	44 0f       	add	r20, r20
     4d8:	55 1f       	adc	r21, r21
     4da:	44 0f       	add	r20, r20
     4dc:	55 1f       	adc	r21, r21
     4de:	84 0f       	add	r24, r20
     4e0:	95 1f       	adc	r25, r21
     4e2:	dc 01       	movw	r26, r24
     4e4:	ac 51       	subi	r26, 0x1C	; 28
     4e6:	bf 4f       	sbci	r27, 0xFF	; 255
     4e8:	12 96       	adiw	r26, 0x02	; 2
     4ea:	3c 93       	st	X, r19
     4ec:	2e 93       	st	-X, r18
     4ee:	11 97       	sbiw	r26, 0x01	; 1
     4f0:	a6 81       	ldd	r26, Z+6	; 0x06
     4f2:	b7 81       	ldd	r27, Z+7	; 0x07
     4f4:	b0 93 d9 00 	sts	0x00D9, r27
     4f8:	a0 93 d8 00 	sts	0x00D8, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     4fc:	ed 91       	ld	r30, X+
     4fe:	fc 91       	ld	r31, X
     500:	11 97       	sbiw	r26, 0x01	; 1
     502:	cd 01       	movw	r24, r26
     504:	57 96       	adiw	r26, 0x17	; 23
     506:	6c 91       	ld	r22, X
     508:	09 95       	icall

	return;
}
     50a:	df 91       	pop	r29
     50c:	cf 91       	pop	r28
     50e:	1f 91       	pop	r17
     510:	0f 91       	pop	r16
     512:	ff 90       	pop	r15
     514:	ef 90       	pop	r14
     516:	df 90       	pop	r13
     518:	cf 90       	pop	r12
     51a:	08 95       	ret

0000051c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     51c:	0f 93       	push	r16
     51e:	1f 93       	push	r17
     520:	cf 93       	push	r28
     522:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     524:	dc 01       	movw	r26, r24
     526:	15 96       	adiw	r26, 0x05	; 5
     528:	ed 91       	ld	r30, X+
     52a:	fc 91       	ld	r31, X
     52c:	16 97       	sbiw	r26, 0x06	; 6
     52e:	06 81       	ldd	r16, Z+6	; 0x06
     530:	17 81       	ldd	r17, Z+7	; 0x07
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     532:	e8 01       	movw	r28, r16
     534:	2c 96       	adiw	r28, 0x0c	; 12
     536:	ce 01       	movw	r24, r28
     538:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     53c:	8a ed       	ldi	r24, 0xDA	; 218
     53e:	90 e0       	ldi	r25, 0x00	; 0
     540:	be 01       	movw	r22, r28
     542:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     546:	e0 91 d8 00 	lds	r30, 0x00D8
     54a:	f0 91 d9 00 	lds	r31, 0x00D9
	{
		xReturn = pdTRUE;
     54e:	81 e0       	ldi	r24, 0x01	; 1
     550:	d8 01       	movw	r26, r16
     552:	56 96       	adiw	r26, 0x16	; 22
     554:	2c 91       	ld	r18, X
     556:	56 97       	sbiw	r26, 0x16	; 22
     558:	96 89       	ldd	r25, Z+22	; 0x16
     55a:	29 17       	cp	r18, r25
     55c:	08 f4       	brcc	.+2      	; 0x560 <xCoRoutineRemoveFromEventList+0x44>
     55e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     560:	df 91       	pop	r29
     562:	cf 91       	pop	r28
     564:	1f 91       	pop	r17
     566:	0f 91       	pop	r16
     568:	08 95       	ret

0000056a <DIO_voidInit>:
#define PORTB_DIR CONCBIT(DIO_PIN15_DIR, DIO_PIN14_DIR, DIO_PIN13_DIR, DIO_PIN12_DIR, DIO_PIN11_DIR, DIO_PIN10_DIR, DIO_PIN9_DIR, DIO_PIN8_DIR)
#define PORTC_DIR CONCBIT(DIO_PIN23_DIR, DIO_PIN22_DIR, DIO_PIN21_DIR, DIO_PIN20_DIR, DIO_PIN19_DIR, DIO_PIN18_DIR, DIO_PIN17_DIR, DIO_PIN16_DIR)
#define PORTD_DIR CONCBIT(DIO_PIN31_DIR, DIO_PIN30_DIR, DIO_PIN29_DIR, DIO_PIN28_DIR, DIO_PIN27_DIR, DIO_PIN26_DIR, DIO_PIN25_DIR, DIO_PIN24_DIR)
void DIO_voidInit(void)
{
	DDRA = PORTA_DIR;
     56a:	8e ed       	ldi	r24, 0xDE	; 222
     56c:	8a bb       	out	0x1a, r24	; 26
	DDRB = PORTB_DIR;
     56e:	8f ef       	ldi	r24, 0xFF	; 255
     570:	87 bb       	out	0x17, r24	; 23
	DDRC = PORTC_DIR;
     572:	84 bb       	out	0x14, r24	; 20
	DDRD = PORTD_DIR;
     574:	81 bb       	out	0x11, r24	; 17
}
     576:	08 95       	ret

00000578 <DIO_voidSetPin>:


void DIO_voidSetPin (u8 local_pinNumber, u8 local_pinValue)
{

	if (local_pinNumber < 8)
     578:	88 30       	cpi	r24, 0x08	; 8
     57a:	e8 f4       	brcc	.+58     	; 0x5b6 <DIO_voidSetPin+0x3e>
	{
		if (local_pinValue == DIO_HIGH)
     57c:	61 30       	cpi	r22, 0x01	; 1
     57e:	69 f4       	brne	.+26     	; 0x59a <DIO_voidSetPin+0x22>
			SET_BIT (PORTA, local_pinNumber);
     580:	4b b3       	in	r20, 0x1b	; 27
     582:	21 e0       	ldi	r18, 0x01	; 1
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	b9 01       	movw	r22, r18
     588:	02 c0       	rjmp	.+4      	; 0x58e <DIO_voidSetPin+0x16>
     58a:	66 0f       	add	r22, r22
     58c:	77 1f       	adc	r23, r23
     58e:	8a 95       	dec	r24
     590:	e2 f7       	brpl	.-8      	; 0x58a <DIO_voidSetPin+0x12>
     592:	cb 01       	movw	r24, r22
     594:	84 2b       	or	r24, r20
     596:	8b bb       	out	0x1b, r24	; 27
     598:	08 95       	ret
		else
			CLR_BIT (PORTA, local_pinNumber);
     59a:	4b b3       	in	r20, 0x1b	; 27
     59c:	21 e0       	ldi	r18, 0x01	; 1
     59e:	30 e0       	ldi	r19, 0x00	; 0
     5a0:	b9 01       	movw	r22, r18
     5a2:	02 c0       	rjmp	.+4      	; 0x5a8 <DIO_voidSetPin+0x30>
     5a4:	66 0f       	add	r22, r22
     5a6:	77 1f       	adc	r23, r23
     5a8:	8a 95       	dec	r24
     5aa:	e2 f7       	brpl	.-8      	; 0x5a4 <DIO_voidSetPin+0x2c>
     5ac:	cb 01       	movw	r24, r22
     5ae:	80 95       	com	r24
     5b0:	84 23       	and	r24, r20
     5b2:	8b bb       	out	0x1b, r24	; 27
     5b4:	08 95       	ret
	}
	else if (local_pinNumber < 16)
     5b6:	80 31       	cpi	r24, 0x10	; 16
     5b8:	10 f5       	brcc	.+68     	; 0x5fe <DIO_voidSetPin+0x86>
	{
		if (local_pinValue == DIO_HIGH)
     5ba:	61 30       	cpi	r22, 0x01	; 1
     5bc:	81 f4       	brne	.+32     	; 0x5de <DIO_voidSetPin+0x66>
			SET_BIT (PORTB, (local_pinNumber-8));
     5be:	68 b3       	in	r22, 0x18	; 24
     5c0:	28 2f       	mov	r18, r24
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	28 50       	subi	r18, 0x08	; 8
     5c6:	30 40       	sbci	r19, 0x00	; 0
     5c8:	41 e0       	ldi	r20, 0x01	; 1
     5ca:	50 e0       	ldi	r21, 0x00	; 0
     5cc:	ca 01       	movw	r24, r20
     5ce:	02 c0       	rjmp	.+4      	; 0x5d4 <DIO_voidSetPin+0x5c>
     5d0:	88 0f       	add	r24, r24
     5d2:	99 1f       	adc	r25, r25
     5d4:	2a 95       	dec	r18
     5d6:	e2 f7       	brpl	.-8      	; 0x5d0 <DIO_voidSetPin+0x58>
     5d8:	86 2b       	or	r24, r22
     5da:	88 bb       	out	0x18, r24	; 24
     5dc:	08 95       	ret
		else
			CLR_BIT (PORTB, (local_pinNumber-8));
     5de:	48 b3       	in	r20, 0x18	; 24
     5e0:	90 e0       	ldi	r25, 0x00	; 0
     5e2:	08 97       	sbiw	r24, 0x08	; 8
     5e4:	21 e0       	ldi	r18, 0x01	; 1
     5e6:	30 e0       	ldi	r19, 0x00	; 0
     5e8:	b9 01       	movw	r22, r18
     5ea:	02 c0       	rjmp	.+4      	; 0x5f0 <DIO_voidSetPin+0x78>
     5ec:	66 0f       	add	r22, r22
     5ee:	77 1f       	adc	r23, r23
     5f0:	8a 95       	dec	r24
     5f2:	e2 f7       	brpl	.-8      	; 0x5ec <DIO_voidSetPin+0x74>
     5f4:	cb 01       	movw	r24, r22
     5f6:	80 95       	com	r24
     5f8:	84 23       	and	r24, r20
     5fa:	88 bb       	out	0x18, r24	; 24
     5fc:	08 95       	ret
	}
	else if (local_pinNumber < 24)
     5fe:	88 31       	cpi	r24, 0x18	; 24
     600:	10 f5       	brcc	.+68     	; 0x646 <DIO_voidSetPin+0xce>
	{
		if (local_pinValue == DIO_HIGH)
     602:	61 30       	cpi	r22, 0x01	; 1
     604:	81 f4       	brne	.+32     	; 0x626 <DIO_voidSetPin+0xae>
			SET_BIT (PORTC, (local_pinNumber-16));
     606:	65 b3       	in	r22, 0x15	; 21
     608:	28 2f       	mov	r18, r24
     60a:	30 e0       	ldi	r19, 0x00	; 0
     60c:	20 51       	subi	r18, 0x10	; 16
     60e:	30 40       	sbci	r19, 0x00	; 0
     610:	41 e0       	ldi	r20, 0x01	; 1
     612:	50 e0       	ldi	r21, 0x00	; 0
     614:	ca 01       	movw	r24, r20
     616:	02 c0       	rjmp	.+4      	; 0x61c <DIO_voidSetPin+0xa4>
     618:	88 0f       	add	r24, r24
     61a:	99 1f       	adc	r25, r25
     61c:	2a 95       	dec	r18
     61e:	e2 f7       	brpl	.-8      	; 0x618 <DIO_voidSetPin+0xa0>
     620:	86 2b       	or	r24, r22
     622:	85 bb       	out	0x15, r24	; 21
     624:	08 95       	ret
		else
			CLR_BIT (PORTC, (local_pinNumber-16));
     626:	45 b3       	in	r20, 0x15	; 21
     628:	90 e0       	ldi	r25, 0x00	; 0
     62a:	40 97       	sbiw	r24, 0x10	; 16
     62c:	21 e0       	ldi	r18, 0x01	; 1
     62e:	30 e0       	ldi	r19, 0x00	; 0
     630:	b9 01       	movw	r22, r18
     632:	02 c0       	rjmp	.+4      	; 0x638 <DIO_voidSetPin+0xc0>
     634:	66 0f       	add	r22, r22
     636:	77 1f       	adc	r23, r23
     638:	8a 95       	dec	r24
     63a:	e2 f7       	brpl	.-8      	; 0x634 <DIO_voidSetPin+0xbc>
     63c:	cb 01       	movw	r24, r22
     63e:	80 95       	com	r24
     640:	84 23       	and	r24, r20
     642:	85 bb       	out	0x15, r24	; 21
     644:	08 95       	ret
	}
	else if (local_pinNumber < 32)
     646:	80 32       	cpi	r24, 0x20	; 32
     648:	08 f5       	brcc	.+66     	; 0x68c <DIO_voidSetPin+0x114>
	{
		if (local_pinValue == DIO_HIGH)
     64a:	61 30       	cpi	r22, 0x01	; 1
     64c:	81 f4       	brne	.+32     	; 0x66e <DIO_voidSetPin+0xf6>
			SET_BIT (PORTD, (local_pinNumber-24));
     64e:	62 b3       	in	r22, 0x12	; 18
     650:	28 2f       	mov	r18, r24
     652:	30 e0       	ldi	r19, 0x00	; 0
     654:	28 51       	subi	r18, 0x18	; 24
     656:	30 40       	sbci	r19, 0x00	; 0
     658:	41 e0       	ldi	r20, 0x01	; 1
     65a:	50 e0       	ldi	r21, 0x00	; 0
     65c:	ca 01       	movw	r24, r20
     65e:	02 c0       	rjmp	.+4      	; 0x664 <DIO_voidSetPin+0xec>
     660:	88 0f       	add	r24, r24
     662:	99 1f       	adc	r25, r25
     664:	2a 95       	dec	r18
     666:	e2 f7       	brpl	.-8      	; 0x660 <DIO_voidSetPin+0xe8>
     668:	86 2b       	or	r24, r22
     66a:	82 bb       	out	0x12, r24	; 18
     66c:	08 95       	ret
		else
			CLR_BIT (PORTD, (local_pinNumber-24));
     66e:	42 b3       	in	r20, 0x12	; 18
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	48 97       	sbiw	r24, 0x18	; 24
     674:	21 e0       	ldi	r18, 0x01	; 1
     676:	30 e0       	ldi	r19, 0x00	; 0
     678:	b9 01       	movw	r22, r18
     67a:	02 c0       	rjmp	.+4      	; 0x680 <DIO_voidSetPin+0x108>
     67c:	66 0f       	add	r22, r22
     67e:	77 1f       	adc	r23, r23
     680:	8a 95       	dec	r24
     682:	e2 f7       	brpl	.-8      	; 0x67c <DIO_voidSetPin+0x104>
     684:	cb 01       	movw	r24, r22
     686:	80 95       	com	r24
     688:	84 23       	and	r24, r20
     68a:	82 bb       	out	0x12, r24	; 18
     68c:	08 95       	ret

0000068e <DIO_voidSetPort>:
	}
}

void DIO_voidSetPort(u8 Local_PortNumber,u8 Local_Value)
{
    if(Local_PortNumber == 0)
     68e:	88 23       	and	r24, r24
     690:	11 f4       	brne	.+4      	; 0x696 <DIO_voidSetPort+0x8>
	{
	    PORTA = Local_Value;
     692:	6b bb       	out	0x1b, r22	; 27
     694:	08 95       	ret

    }else if(Local_PortNumber == 1)
     696:	81 30       	cpi	r24, 0x01	; 1
     698:	11 f4       	brne	.+4      	; 0x69e <DIO_voidSetPort+0x10>
    {
        PORTB = Local_Value;
     69a:	68 bb       	out	0x18, r22	; 24
     69c:	08 95       	ret
    }else if(Local_PortNumber == 2)
     69e:	82 30       	cpi	r24, 0x02	; 2
     6a0:	11 f4       	brne	.+4      	; 0x6a6 <DIO_voidSetPort+0x18>
    {
        PORTC = Local_Value;
     6a2:	65 bb       	out	0x15, r22	; 21
     6a4:	08 95       	ret
    }else if(Local_PortNumber == 3)
     6a6:	83 30       	cpi	r24, 0x03	; 3
     6a8:	09 f4       	brne	.+2      	; 0x6ac <DIO_voidSetPort+0x1e>
    {
        PORTD = Local_Value;
     6aa:	62 bb       	out	0x12, r22	; 18
     6ac:	08 95       	ret

000006ae <DIO_voidSetPortDir>:
    }
}

void DIO_voidSetPortDir(u8 Local_PortNumber, u8 Local_Dir)
{
    if(Local_PortNumber == 0)
     6ae:	88 23       	and	r24, r24
     6b0:	11 f4       	brne	.+4      	; 0x6b6 <DIO_voidSetPortDir+0x8>
	{
	    DDRA = Local_Dir;
     6b2:	6a bb       	out	0x1a, r22	; 26
     6b4:	08 95       	ret

    }else if(Local_PortNumber == 1)
     6b6:	81 30       	cpi	r24, 0x01	; 1
     6b8:	11 f4       	brne	.+4      	; 0x6be <DIO_voidSetPortDir+0x10>
    {
        DDRB = Local_Dir;
     6ba:	67 bb       	out	0x17, r22	; 23
     6bc:	08 95       	ret
    }else if(Local_PortNumber == 2)
     6be:	82 30       	cpi	r24, 0x02	; 2
     6c0:	11 f4       	brne	.+4      	; 0x6c6 <DIO_voidSetPortDir+0x18>
    {
        DDRC = Local_Dir;
     6c2:	64 bb       	out	0x14, r22	; 20
     6c4:	08 95       	ret
    }else if(Local_PortNumber == 3)
     6c6:	83 30       	cpi	r24, 0x03	; 3
     6c8:	09 f4       	brne	.+2      	; 0x6cc <DIO_voidSetPortDir+0x1e>
    {
        DDRD = Local_Dir;
     6ca:	61 bb       	out	0x11, r22	; 17
     6cc:	08 95       	ret

000006ce <DIO_u8GetPin>:
    }
}

u8 DIO_u8GetPin(u8 local_pinNumber)
{
	if (local_pinNumber < 8)
     6ce:	88 30       	cpi	r24, 0x08	; 8
     6d0:	58 f4       	brcc	.+22     	; 0x6e8 <DIO_u8GetPin+0x1a>
	{
		return (GET_BIT(PINA, local_pinNumber));
     6d2:	29 b3       	in	r18, 0x19	; 25
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	a9 01       	movw	r20, r18
     6d8:	02 c0       	rjmp	.+4      	; 0x6de <DIO_u8GetPin+0x10>
     6da:	55 95       	asr	r21
     6dc:	47 95       	ror	r20
     6de:	8a 95       	dec	r24
     6e0:	e2 f7       	brpl	.-8      	; 0x6da <DIO_u8GetPin+0xc>
     6e2:	ca 01       	movw	r24, r20
     6e4:	81 70       	andi	r24, 0x01	; 1
     6e6:	08 95       	ret
	}
	else if (local_pinNumber < 16)
     6e8:	80 31       	cpi	r24, 0x10	; 16
     6ea:	68 f4       	brcc	.+26     	; 0x706 <DIO_u8GetPin+0x38>
	{
		return (GET_BIT(PINB, (local_pinNumber-8)));
     6ec:	26 b3       	in	r18, 0x16	; 22
     6ee:	30 e0       	ldi	r19, 0x00	; 0
     6f0:	90 e0       	ldi	r25, 0x00	; 0
     6f2:	08 97       	sbiw	r24, 0x08	; 8
     6f4:	a9 01       	movw	r20, r18
     6f6:	02 c0       	rjmp	.+4      	; 0x6fc <DIO_u8GetPin+0x2e>
     6f8:	55 95       	asr	r21
     6fa:	47 95       	ror	r20
     6fc:	8a 95       	dec	r24
     6fe:	e2 f7       	brpl	.-8      	; 0x6f8 <DIO_u8GetPin+0x2a>
     700:	ca 01       	movw	r24, r20
     702:	81 70       	andi	r24, 0x01	; 1
     704:	08 95       	ret
	}
	else if (local_pinNumber < 24)
     706:	88 31       	cpi	r24, 0x18	; 24
     708:	68 f4       	brcc	.+26     	; 0x724 <DIO_u8GetPin+0x56>
	{
		return (GET_BIT(PINC, (local_pinNumber - 16)));
     70a:	23 b3       	in	r18, 0x13	; 19
     70c:	30 e0       	ldi	r19, 0x00	; 0
     70e:	90 e0       	ldi	r25, 0x00	; 0
     710:	40 97       	sbiw	r24, 0x10	; 16
     712:	a9 01       	movw	r20, r18
     714:	02 c0       	rjmp	.+4      	; 0x71a <DIO_u8GetPin+0x4c>
     716:	55 95       	asr	r21
     718:	47 95       	ror	r20
     71a:	8a 95       	dec	r24
     71c:	e2 f7       	brpl	.-8      	; 0x716 <DIO_u8GetPin+0x48>
     71e:	ca 01       	movw	r24, r20
     720:	81 70       	andi	r24, 0x01	; 1
     722:	08 95       	ret
	}
	else if (local_pinNumber < 32)
     724:	80 32       	cpi	r24, 0x20	; 32
     726:	68 f4       	brcc	.+26     	; 0x742 <DIO_u8GetPin+0x74>
	{
		return (GET_BIT(PIND, (local_pinNumber-24)));
     728:	20 b3       	in	r18, 0x10	; 16
     72a:	30 e0       	ldi	r19, 0x00	; 0
     72c:	90 e0       	ldi	r25, 0x00	; 0
     72e:	48 97       	sbiw	r24, 0x18	; 24
     730:	a9 01       	movw	r20, r18
     732:	02 c0       	rjmp	.+4      	; 0x738 <DIO_u8GetPin+0x6a>
     734:	55 95       	asr	r21
     736:	47 95       	ror	r20
     738:	8a 95       	dec	r24
     73a:	e2 f7       	brpl	.-8      	; 0x734 <DIO_u8GetPin+0x66>
     73c:	ca 01       	movw	r24, r20
     73e:	81 70       	andi	r24, 0x01	; 1
     740:	08 95       	ret
	}
	else return 0;
     742:	80 e0       	ldi	r24, 0x00	; 0
}
     744:	08 95       	ret

00000746 <DIO_u8GetPinInPort>:

u8 DIO_u8GetPinInPort(u8 Local_PortNumber, u8 Local_PinNumber)
{
    u8 ret=DIO_LOW;

    if(Local_PortNumber == 0)
     746:	88 23       	and	r24, r24
     748:	51 f4       	brne	.+20     	; 0x75e <DIO_u8GetPinInPort+0x18>
	{
	    ret = GETBIT(PINA, Local_PinNumber);
     74a:	29 b3       	in	r18, 0x19	; 25
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	c9 01       	movw	r24, r18
     750:	02 c0       	rjmp	.+4      	; 0x756 <DIO_u8GetPinInPort+0x10>
     752:	95 95       	asr	r25
     754:	87 95       	ror	r24
     756:	6a 95       	dec	r22
     758:	e2 f7       	brpl	.-8      	; 0x752 <DIO_u8GetPinInPort+0xc>
     75a:	81 70       	andi	r24, 0x01	; 1
     75c:	08 95       	ret

    }else if(Local_PortNumber == 1)
     75e:	81 30       	cpi	r24, 0x01	; 1
     760:	51 f4       	brne	.+20     	; 0x776 <DIO_u8GetPinInPort+0x30>
    {
	    ret = GETBIT(PINB, Local_PinNumber);
     762:	26 b3       	in	r18, 0x16	; 22
     764:	30 e0       	ldi	r19, 0x00	; 0
     766:	c9 01       	movw	r24, r18
     768:	02 c0       	rjmp	.+4      	; 0x76e <DIO_u8GetPinInPort+0x28>
     76a:	95 95       	asr	r25
     76c:	87 95       	ror	r24
     76e:	6a 95       	dec	r22
     770:	e2 f7       	brpl	.-8      	; 0x76a <DIO_u8GetPinInPort+0x24>
     772:	81 70       	andi	r24, 0x01	; 1
     774:	08 95       	ret

    }else if(Local_PortNumber == 2)
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	51 f4       	brne	.+20     	; 0x78e <DIO_u8GetPinInPort+0x48>
    {
	    ret = GETBIT(PINC, Local_PinNumber);
     77a:	23 b3       	in	r18, 0x13	; 19
     77c:	30 e0       	ldi	r19, 0x00	; 0
     77e:	c9 01       	movw	r24, r18
     780:	02 c0       	rjmp	.+4      	; 0x786 <DIO_u8GetPinInPort+0x40>
     782:	95 95       	asr	r25
     784:	87 95       	ror	r24
     786:	6a 95       	dec	r22
     788:	e2 f7       	brpl	.-8      	; 0x782 <DIO_u8GetPinInPort+0x3c>
     78a:	81 70       	andi	r24, 0x01	; 1
     78c:	08 95       	ret

    }else if(Local_PortNumber == 3)
     78e:	83 30       	cpi	r24, 0x03	; 3
     790:	51 f4       	brne	.+20     	; 0x7a6 <DIO_u8GetPinInPort+0x60>
    {
	    ret = GETBIT(PIND, Local_PinNumber);
     792:	20 b3       	in	r18, 0x10	; 16
     794:	30 e0       	ldi	r19, 0x00	; 0
     796:	c9 01       	movw	r24, r18
     798:	02 c0       	rjmp	.+4      	; 0x79e <DIO_u8GetPinInPort+0x58>
     79a:	95 95       	asr	r25
     79c:	87 95       	ror	r24
     79e:	6a 95       	dec	r22
     7a0:	e2 f7       	brpl	.-8      	; 0x79a <DIO_u8GetPinInPort+0x54>
     7a2:	81 70       	andi	r24, 0x01	; 1
     7a4:	08 95       	ret
	else return 0;
}

u8 DIO_u8GetPinInPort(u8 Local_PortNumber, u8 Local_PinNumber)
{
    u8 ret=DIO_LOW;
     7a6:	80 e0       	ldi	r24, 0x00	; 0
	    ret = GETBIT(PIND, Local_PinNumber);
    }

    return ret;

}
     7a8:	08 95       	ret

000007aa <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     7aa:	ef 92       	push	r14
     7ac:	ff 92       	push	r15
     7ae:	0f 93       	push	r16
     7b0:	1f 93       	push	r17
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
     7b6:	8c 01       	movw	r16, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     7b8:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     7bc:	c0 91 00 01 	lds	r28, 0x0100
     7c0:	d0 91 01 01 	lds	r29, 0x0101
     7c4:	0c 0f       	add	r16, r28
     7c6:	1d 1f       	adc	r17, r29
     7c8:	25 e0       	ldi	r18, 0x05	; 5
     7ca:	0c 3d       	cpi	r16, 0xDC	; 220
     7cc:	12 07       	cpc	r17, r18
     7ce:	50 f4       	brcc	.+20     	; 0x7e4 <pvPortMalloc+0x3a>
     7d0:	c0 17       	cp	r28, r16
     7d2:	d1 07       	cpc	r29, r17
     7d4:	50 f4       	brcc	.+20     	; 0x7ea <pvPortMalloc+0x40>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     7d6:	ce 5f       	subi	r28, 0xFE	; 254
     7d8:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
     7da:	10 93 01 01 	sts	0x0101, r17
     7de:	00 93 00 01 	sts	0x0100, r16
     7e2:	05 c0       	rjmp	.+10     	; 0x7ee <pvPortMalloc+0x44>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     7e4:	c0 e0       	ldi	r28, 0x00	; 0
     7e6:	d0 e0       	ldi	r29, 0x00	; 0
     7e8:	02 c0       	rjmp	.+4      	; 0x7ee <pvPortMalloc+0x44>
     7ea:	c0 e0       	ldi	r28, 0x00	; 0
     7ec:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     7ee:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     7f2:	7e 01       	movw	r14, r28
     7f4:	8c 2f       	mov	r24, r28
     7f6:	9f 2d       	mov	r25, r15
     7f8:	df 91       	pop	r29
     7fa:	cf 91       	pop	r28
     7fc:	1f 91       	pop	r17
     7fe:	0f 91       	pop	r16
     800:	ff 90       	pop	r15
     802:	ef 90       	pop	r14
     804:	08 95       	ret

00000806 <vPortFree>:
{
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     806:	08 95       	ret

00000808 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     808:	10 92 01 01 	sts	0x0101, r1
     80c:	10 92 00 01 	sts	0x0100, r1
}
     810:	08 95       	ret

00000812 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     812:	80 91 00 01 	lds	r24, 0x0100
     816:	90 91 01 01 	lds	r25, 0x0101
     81a:	2c ed       	ldi	r18, 0xDC	; 220
     81c:	35 e0       	ldi	r19, 0x05	; 5
     81e:	28 1b       	sub	r18, r24
     820:	39 0b       	sbc	r19, r25
}
     822:	82 2f       	mov	r24, r18
     824:	93 2f       	mov	r25, r19
     826:	08 95       	ret

00000828 <KeyPad_u8AdjustKeyNumber_4x3>:
    return NO_KEY_PRESSED;
}

u8 KeyPad_u8AdjustKeyNumber_4x3(u8 button_number)
{
    switch(button_number)
     828:	86 30       	cpi	r24, 0x06	; 6
     82a:	41 f1       	breq	.+80     	; 0x87c <__stack+0x1d>
     82c:	87 30       	cpi	r24, 0x07	; 7
     82e:	70 f4       	brcc	.+28     	; 0x84c <KeyPad_u8AdjustKeyNumber_4x3+0x24>
     830:	83 30       	cpi	r24, 0x03	; 3
     832:	f1 f0       	breq	.+60     	; 0x870 <__stack+0x11>
     834:	84 30       	cpi	r24, 0x04	; 4
     836:	28 f4       	brcc	.+10     	; 0x842 <KeyPad_u8AdjustKeyNumber_4x3+0x1a>
     838:	81 30       	cpi	r24, 0x01	; 1
     83a:	c1 f0       	breq	.+48     	; 0x86c <__stack+0xd>
     83c:	82 30       	cpi	r24, 0x02	; 2
     83e:	61 f5       	brne	.+88     	; 0x898 <__stack+0x39>
     840:	2d c0       	rjmp	.+90     	; 0x89c <__stack+0x3d>
     842:	84 30       	cpi	r24, 0x04	; 4
     844:	b9 f0       	breq	.+46     	; 0x874 <__stack+0x15>
     846:	85 30       	cpi	r24, 0x05	; 5
     848:	39 f5       	brne	.+78     	; 0x898 <__stack+0x39>
     84a:	16 c0       	rjmp	.+44     	; 0x878 <__stack+0x19>
     84c:	89 30       	cpi	r24, 0x09	; 9
     84e:	e1 f0       	breq	.+56     	; 0x888 <__stack+0x29>
     850:	8a 30       	cpi	r24, 0x0A	; 10
     852:	28 f4       	brcc	.+10     	; 0x85e <KeyPad_u8AdjustKeyNumber_4x3+0x36>
     854:	87 30       	cpi	r24, 0x07	; 7
     856:	a1 f0       	breq	.+40     	; 0x880 <__stack+0x21>
     858:	88 30       	cpi	r24, 0x08	; 8
     85a:	f1 f4       	brne	.+60     	; 0x898 <__stack+0x39>
     85c:	13 c0       	rjmp	.+38     	; 0x884 <__stack+0x25>
     85e:	8b 30       	cpi	r24, 0x0B	; 11
     860:	b9 f0       	breq	.+46     	; 0x890 <__stack+0x31>
     862:	8b 30       	cpi	r24, 0x0B	; 11
     864:	98 f0       	brcs	.+38     	; 0x88c <__stack+0x2d>
     866:	8c 30       	cpi	r24, 0x0C	; 12
     868:	b9 f4       	brne	.+46     	; 0x898 <__stack+0x39>
     86a:	14 c0       	rjmp	.+40     	; 0x894 <__stack+0x35>
	{
	    	case 1: return '1';
     86c:	81 e3       	ldi	r24, 0x31	; 49
     86e:	08 95       	ret
				break;
		case 2: return '2';
				break;
		case 3: return '3';
     870:	83 e3       	ldi	r24, 0x33	; 51
     872:	08 95       	ret
				break;
		case 4: return '4'; // ASCII Code of %
     874:	84 e3       	ldi	r24, 0x34	; 52
     876:	08 95       	ret
				break;
		case 5: return '5';
     878:	85 e3       	ldi	r24, 0x35	; 53
     87a:	08 95       	ret
				break;
		case 6: return '6';
     87c:	86 e3       	ldi	r24, 0x36	; 54
     87e:	08 95       	ret
				break;
		case 7: return '7';
     880:	87 e3       	ldi	r24, 0x37	; 55
     882:	08 95       	ret
				break;
		case 8: return '8'; /* ASCII Code of '*' */
     884:	88 e3       	ldi	r24, 0x38	; 56
     886:	08 95       	ret
				break;
		case 9: return '9';
     888:	89 e3       	ldi	r24, 0x39	; 57
     88a:	08 95       	ret
				break;
		case 10: return '*'; // ASCII Code of =
     88c:	8a e2       	ldi	r24, 0x2A	; 42
     88e:	08 95       	ret
				 break;
		case 11: return '0';
     890:	80 e3       	ldi	r24, 0x30	; 48
     892:	08 95       	ret
				 break;
		case 12: return '#'; // ASCII Code of +
     894:	83 e2       	ldi	r24, 0x23	; 35
     896:	08 95       	ret
				 break;
		default: return NO_KEY_PRESSED;
     898:	8f ef       	ldi	r24, 0xFF	; 255
     89a:	08 95       	ret
{
    switch(button_number)
	{
	    	case 1: return '1';
				break;
		case 2: return '2';
     89c:	82 e3       	ldi	r24, 0x32	; 50
		case 12: return '#'; // ASCII Code of +
				 break;
		default: return NO_KEY_PRESSED;
	}

}
     89e:	08 95       	ret

000008a0 <KeyPad_u8AdjustKeyNumber_4x4>:

u8 KeyPad_u8AdjustKeyNumber_4x4(u8 button_number)
{
    switch(button_number)
     8a0:	88 30       	cpi	r24, 0x08	; 8
     8a2:	81 f1       	breq	.+96     	; 0x904 <KeyPad_u8AdjustKeyNumber_4x4+0x64>
     8a4:	89 30       	cpi	r24, 0x09	; 9
     8a6:	80 f4       	brcc	.+32     	; 0x8c8 <KeyPad_u8AdjustKeyNumber_4x4+0x28>
     8a8:	84 30       	cpi	r24, 0x04	; 4
     8aa:	21 f1       	breq	.+72     	; 0x8f4 <KeyPad_u8AdjustKeyNumber_4x4+0x54>
     8ac:	85 30       	cpi	r24, 0x05	; 5
     8ae:	38 f4       	brcc	.+14     	; 0x8be <KeyPad_u8AdjustKeyNumber_4x4+0x1e>
     8b0:	82 30       	cpi	r24, 0x02	; 2
     8b2:	e1 f1       	breq	.+120    	; 0x92c <KeyPad_u8AdjustKeyNumber_4x4+0x8c>
     8b4:	83 30       	cpi	r24, 0x03	; 3
     8b6:	e0 f4       	brcc	.+56     	; 0x8f0 <KeyPad_u8AdjustKeyNumber_4x4+0x50>
     8b8:	81 30       	cpi	r24, 0x01	; 1
     8ba:	b1 f5       	brne	.+108    	; 0x928 <KeyPad_u8AdjustKeyNumber_4x4+0x88>
     8bc:	17 c0       	rjmp	.+46     	; 0x8ec <KeyPad_u8AdjustKeyNumber_4x4+0x4c>
     8be:	86 30       	cpi	r24, 0x06	; 6
     8c0:	e9 f0       	breq	.+58     	; 0x8fc <KeyPad_u8AdjustKeyNumber_4x4+0x5c>
     8c2:	87 30       	cpi	r24, 0x07	; 7
     8c4:	e8 f4       	brcc	.+58     	; 0x900 <KeyPad_u8AdjustKeyNumber_4x4+0x60>
     8c6:	18 c0       	rjmp	.+48     	; 0x8f8 <KeyPad_u8AdjustKeyNumber_4x4+0x58>
     8c8:	8c 30       	cpi	r24, 0x0C	; 12
     8ca:	21 f1       	breq	.+72     	; 0x914 <KeyPad_u8AdjustKeyNumber_4x4+0x74>
     8cc:	8d 30       	cpi	r24, 0x0D	; 13
     8ce:	28 f4       	brcc	.+10     	; 0x8da <KeyPad_u8AdjustKeyNumber_4x4+0x3a>
     8d0:	8a 30       	cpi	r24, 0x0A	; 10
     8d2:	e1 f0       	breq	.+56     	; 0x90c <KeyPad_u8AdjustKeyNumber_4x4+0x6c>
     8d4:	8b 30       	cpi	r24, 0x0B	; 11
     8d6:	e0 f4       	brcc	.+56     	; 0x910 <KeyPad_u8AdjustKeyNumber_4x4+0x70>
     8d8:	17 c0       	rjmp	.+46     	; 0x908 <KeyPad_u8AdjustKeyNumber_4x4+0x68>
     8da:	8e 30       	cpi	r24, 0x0E	; 14
     8dc:	f9 f0       	breq	.+62     	; 0x91c <KeyPad_u8AdjustKeyNumber_4x4+0x7c>
     8de:	8e 30       	cpi	r24, 0x0E	; 14
     8e0:	d8 f0       	brcs	.+54     	; 0x918 <KeyPad_u8AdjustKeyNumber_4x4+0x78>
     8e2:	8f 30       	cpi	r24, 0x0F	; 15
     8e4:	e9 f0       	breq	.+58     	; 0x920 <KeyPad_u8AdjustKeyNumber_4x4+0x80>
     8e6:	80 31       	cpi	r24, 0x10	; 16
     8e8:	f9 f4       	brne	.+62     	; 0x928 <KeyPad_u8AdjustKeyNumber_4x4+0x88>
     8ea:	1c c0       	rjmp	.+56     	; 0x924 <KeyPad_u8AdjustKeyNumber_4x4+0x84>
	{
		case 1: return '7';
     8ec:	87 e3       	ldi	r24, 0x37	; 55
     8ee:	08 95       	ret
				break;
		case 2: return '8';
				break;
		case 3: return '9';
     8f0:	89 e3       	ldi	r24, 0x39	; 57
     8f2:	08 95       	ret
				break;
		case 4: return '%'; // ASCII Code of %
     8f4:	85 e2       	ldi	r24, 0x25	; 37
     8f6:	08 95       	ret
				break;
		case 5: return '4';
     8f8:	84 e3       	ldi	r24, 0x34	; 52
     8fa:	08 95       	ret
				break;
		case 6: return '5';
     8fc:	85 e3       	ldi	r24, 0x35	; 53
     8fe:	08 95       	ret
				break;
		case 7: return '6';
     900:	86 e3       	ldi	r24, 0x36	; 54
     902:	08 95       	ret
				break;
		case 8: return '*'; /* ASCII Code of '*' */
     904:	8a e2       	ldi	r24, 0x2A	; 42
     906:	08 95       	ret
				break;
		case 9: return '1';
     908:	81 e3       	ldi	r24, 0x31	; 49
     90a:	08 95       	ret
				break;
		case 10: return '2';
     90c:	82 e3       	ldi	r24, 0x32	; 50
     90e:	08 95       	ret
				break;
		case 11: return '3';
     910:	83 e3       	ldi	r24, 0x33	; 51
     912:	08 95       	ret
				break;
		case 12: return '-'; /* ASCII Code of '-' */
     914:	8d e2       	ldi	r24, 0x2D	; 45
     916:	08 95       	ret
				break;
		case 13: return 13;  /* ASCII of Enter */
     918:	8d e0       	ldi	r24, 0x0D	; 13
     91a:	08 95       	ret
				break;
		case 14: return '0';
     91c:	80 e3       	ldi	r24, 0x30	; 48
     91e:	08 95       	ret
				break;
		case 15: return '='; /* ASCII Code of '=' */
     920:	8d e3       	ldi	r24, 0x3D	; 61
     922:	08 95       	ret
				break;
		case 16: return '+'; /* ASCII Code of '+' */
     924:	8b e2       	ldi	r24, 0x2B	; 43
     926:	08 95       	ret
				break;
		default: return NO_KEY_PRESSED;
     928:	8f ef       	ldi	r24, 0xFF	; 255
     92a:	08 95       	ret
{
    switch(button_number)
	{
		case 1: return '7';
				break;
		case 2: return '8';
     92c:	88 e3       	ldi	r24, 0x38	; 56
		case 16: return '+'; /* ASCII Code of '+' */
				break;
		default: return NO_KEY_PRESSED;
	}

}
     92e:	08 95       	ret

00000930 <KeyPad_u8GetPressedKey>:
#include "KeyPad_priv.h"
#include "KeyPad_config.h"
#include "KeyPad_int.h"

u8 KeyPad_u8GetPressedKey(void)
{
     930:	bf 92       	push	r11
     932:	cf 92       	push	r12
     934:	df 92       	push	r13
     936:	ef 92       	push	r14
     938:	ff 92       	push	r15
     93a:	0f 93       	push	r16
     93c:	1f 93       	push	r17
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
     942:	00 e0       	ldi	r16, 0x00	; 0
     944:	10 e0       	ldi	r17, 0x00	; 0
        /*
         * Each time only one of the column pins will be output and
         * the rest will be input pins including the row pins
         */

        DIO_voidSetPortDir(KEYPAD_PORT, (0b00010000<<col));
     946:	cc 24       	eor	r12, r12
     948:	dd 24       	eor	r13, r13
     94a:	68 94       	set
     94c:	c4 f8       	bld	r12, 4
         * clear the output pin column and enable the internal
         * pull up resistors for the other pins
         */
        DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000<<col)));

        for(row=0; row<N_row; row++) /* loop for rows */
     94e:	ee 24       	eor	r14, r14
                #endif
            }
        }
    }

    return NO_KEY_PRESSED;
     950:	b0 2e       	mov	r11, r16
        /*
         * Each time only one of the column pins will be output and
         * the rest will be input pins including the row pins
         */

        DIO_voidSetPortDir(KEYPAD_PORT, (0b00010000<<col));
     952:	e6 01       	movw	r28, r12
     954:	00 2e       	mov	r0, r16
     956:	02 c0       	rjmp	.+4      	; 0x95c <KeyPad_u8GetPressedKey+0x2c>
     958:	cc 0f       	add	r28, r28
     95a:	dd 1f       	adc	r29, r29
     95c:	0a 94       	dec	r0
     95e:	e2 f7       	brpl	.-8      	; 0x958 <KeyPad_u8GetPressedKey+0x28>
     960:	83 e0       	ldi	r24, 0x03	; 3
     962:	6c 2f       	mov	r22, r28
     964:	0e 94 57 03 	call	0x6ae	; 0x6ae <DIO_voidSetPortDir>

        /*
         * clear the output pin column and enable the internal
         * pull up resistors for the other pins
         */
        DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000<<col)));
     968:	ce 01       	movw	r24, r28
     96a:	80 95       	com	r24
     96c:	68 2f       	mov	r22, r24
     96e:	83 e0       	ldi	r24, 0x03	; 3
     970:	0e 94 47 03 	call	0x68e	; 0x68e <DIO_voidSetPort>

        for(row=0; row<N_row; row++) /* loop for rows */
     974:	fe 2c       	mov	r15, r14
        {
            if(DIO_u8GetPinInPort(KEYPAD_PORT, row) == 0) /* if the switch is pressed in this row */
     976:	83 e0       	ldi	r24, 0x03	; 3
     978:	6f 2d       	mov	r22, r15
     97a:	0e 94 a3 03 	call	0x746	; 0x746 <DIO_u8GetPinInPort>
     97e:	88 23       	and	r24, r24
     980:	41 f4       	brne	.+16     	; 0x992 <KeyPad_u8GetPressedKey+0x62>
            {
                #if (N_col == 3)
                    return KeyPad_u8AdjustKeyNumber_4x3((row*N_col)+col+1);
                #elif (N_col == 4)
                    return KeyPad_u8AdjustKeyNumber_4x4((row*N_col)+col+1);
     982:	8b 2d       	mov	r24, r11
     984:	8f 5f       	subi	r24, 0xFF	; 255
     986:	ff 0c       	add	r15, r15
     988:	ff 0c       	add	r15, r15
     98a:	8f 0d       	add	r24, r15
     98c:	0e 94 50 04 	call	0x8a0	; 0x8a0 <KeyPad_u8AdjustKeyNumber_4x4>
     990:	0a c0       	rjmp	.+20     	; 0x9a6 <KeyPad_u8GetPressedKey+0x76>
         * clear the output pin column and enable the internal
         * pull up resistors for the other pins
         */
        DIO_voidSetPort(KEYPAD_PORT, (~(0b00010000<<col)));

        for(row=0; row<N_row; row++) /* loop for rows */
     992:	f3 94       	inc	r15
     994:	9f 2d       	mov	r25, r15
     996:	94 30       	cpi	r25, 0x04	; 4
     998:	71 f7       	brne	.-36     	; 0x976 <KeyPad_u8GetPressedKey+0x46>
     99a:	0f 5f       	subi	r16, 0xFF	; 255
     99c:	1f 4f       	sbci	r17, 0xFF	; 255

u8 KeyPad_u8GetPressedKey(void)
{
    u8 col,row;

    for(col=0; col<N_col; col++) /* loop for columns */
     99e:	04 30       	cpi	r16, 0x04	; 4
     9a0:	11 05       	cpc	r17, r1
     9a2:	b1 f6       	brne	.-84     	; 0x950 <KeyPad_u8GetPressedKey+0x20>
                #endif
            }
        }
    }

    return NO_KEY_PRESSED;
     9a4:	8f ef       	ldi	r24, 0xFF	; 255
}
     9a6:	df 91       	pop	r29
     9a8:	cf 91       	pop	r28
     9aa:	1f 91       	pop	r17
     9ac:	0f 91       	pop	r16
     9ae:	ff 90       	pop	r15
     9b0:	ef 90       	pop	r14
     9b2:	df 90       	pop	r13
     9b4:	cf 90       	pop	r12
     9b6:	bf 90       	pop	r11
     9b8:	08 95       	ret

000009ba <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
     9ba:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9bc:	89 ef       	ldi	r24, 0xF9	; 249
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	01 97       	sbiw	r24, 0x01	; 1
     9c2:	f1 f7       	brne	.-4      	; 0x9c0 <enableTrigger+0x6>
     9c4:	00 c0       	rjmp	.+0      	; 0x9c6 <enableTrigger+0xc>
     9c6:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
     9c8:	c2 9a       	sbi	0x18, 2	; 24
     9ca:	8b ed       	ldi	r24, 0xDB	; 219
     9cc:	95 e0       	ldi	r25, 0x05	; 5
     9ce:	01 97       	sbiw	r24, 0x01	; 1
     9d0:	f1 f7       	brne	.-4      	; 0x9ce <enableTrigger+0x14>
     9d2:	00 c0       	rjmp	.+0      	; 0x9d4 <enableTrigger+0x1a>
     9d4:	00 00       	nop
	_delay_ms(6);


}
     9d6:	08 95       	ret

000009d8 <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
     9d8:	1f 93       	push	r17
     9da:	18 2f       	mov	r17, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     9dc:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     9de:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     9e0:	88 b3       	in	r24, 0x18	; 24
     9e2:	8f 70       	andi	r24, 0x0F	; 15
     9e4:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     9e6:	88 b3       	in	r24, 0x18	; 24
void lcd_sendCommand(unsigned char cmd)
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
     9e8:	91 2f       	mov	r25, r17
     9ea:	90 7f       	andi	r25, 0xF0	; 240

	CLR_BIT(PORTB,0); // to enable command mode 
	CLR_BIT(PORTB,1); // write signal to lcd 

	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
     9ec:	89 2b       	or	r24, r25
     9ee:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     9f0:	0e 94 dd 04 	call	0x9ba	; 0x9ba <enableTrigger>

	PORTB &=0x0f;
     9f4:	88 b3       	in	r24, 0x18	; 24
     9f6:	8f 70       	andi	r24, 0x0F	; 15
     9f8:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     9fa:	88 b3       	in	r24, 0x18	; 24
{

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);
     9fc:	12 95       	swap	r17
     9fe:	10 7f       	andi	r17, 0xF0	; 240
	PORTB &=0x0f;
	PORTB |=high_nibble;// to send high nibble command  
	enableTrigger(); // triggre lcd enable 

	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble command 
     a00:	18 2b       	or	r17, r24
     a02:	18 bb       	out	0x18, r17	; 24
	enableTrigger();
     a04:	0e 94 dd 04 	call	0x9ba	; 0x9ba <enableTrigger>

}
     a08:	1f 91       	pop	r17
     a0a:	08 95       	ret

00000a0c <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     a0c:	8f ef       	ldi	r24, 0xFF	; 255
     a0e:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     a10:	84 e0       	ldi	r24, 0x04	; 4
     a12:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     a14:	83 e3       	ldi	r24, 0x33	; 51
     a16:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <lcd_sendCommand>
	lcd_sendCommand (0x32);
     a1a:	82 e3       	ldi	r24, 0x32	; 50
     a1c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <lcd_sendCommand>
	lcd_sendCommand (0x28);
     a20:	88 e2       	ldi	r24, 0x28	; 40
     a22:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     a26:	8c e0       	ldi	r24, 0x0C	; 12
     a28:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <lcd_sendCommand>

		
}
     a2c:	08 95       	ret

00000a2e <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     a2e:	1f 93       	push	r17
     a30:	18 2f       	mov	r17, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     a32:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     a34:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     a36:	88 b3       	in	r24, 0x18	; 24
     a38:	8f 70       	andi	r24, 0x0F	; 15
     a3a:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     a3c:	88 b3       	in	r24, 0x18	; 24
	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
     a3e:	91 2f       	mov	r25, r17
     a40:	90 7f       	andi	r25, 0xF0	; 240
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
     a42:	89 2b       	or	r24, r25
     a44:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     a46:	0e 94 dd 04 	call	0x9ba	; 0x9ba <enableTrigger>
	
	PORTB &=0x0f;
     a4a:	88 b3       	in	r24, 0x18	; 24
     a4c:	8f 70       	andi	r24, 0x0F	; 15
     a4e:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     a50:	88 b3       	in	r24, 0x18	; 24

	SET_BIT(PORTB,0); //  enable data mode 
	CLR_BIT(PORTB,1); // activate lcd write 

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
     a52:	12 95       	swap	r17
     a54:	10 7f       	andi	r17, 0xF0	; 240
	PORTB &= 0x0f;
	PORTB |=high_nibble;// to send high nibble data  
	enableTrigger(); // triggre lcd enable 
	
	PORTB &=0x0f;
	PORTB |=low_nibble; // to send low nibble data 
     a56:	18 2b       	or	r17, r24
     a58:	18 bb       	out	0x18, r17	; 24
	enableTrigger();
     a5a:	0e 94 dd 04 	call	0x9ba	; 0x9ba <enableTrigger>
	

}
     a5e:	1f 91       	pop	r17
     a60:	08 95       	ret

00000a62 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     a62:	81 30       	cpi	r24, 0x01	; 1
     a64:	51 f0       	breq	.+20     	; 0xa7a <lcd_gotoxy+0x18>
     a66:	81 30       	cpi	r24, 0x01	; 1
     a68:	28 f0       	brcs	.+10     	; 0xa74 <lcd_gotoxy+0x12>
     a6a:	82 30       	cpi	r24, 0x02	; 2
     a6c:	49 f0       	breq	.+18     	; 0xa80 <lcd_gotoxy+0x1e>
     a6e:	83 30       	cpi	r24, 0x03	; 3
     a70:	69 f4       	brne	.+26     	; 0xa8c <lcd_gotoxy+0x2a>
     a72:	09 c0       	rjmp	.+18     	; 0xa86 <lcd_gotoxy+0x24>
	{
		case 0:

			position=position+x;
     a74:	86 2f       	mov	r24, r22
     a76:	80 58       	subi	r24, 0x80	; 128
					
		break;
     a78:	0a c0       	rjmp	.+20     	; 0xa8e <lcd_gotoxy+0x2c>

		case 1:

			position=0xc0;
			position=position+x;
     a7a:	86 2f       	mov	r24, r22
     a7c:	80 54       	subi	r24, 0x40	; 64

		break;
     a7e:	07 c0       	rjmp	.+14     	; 0xa8e <lcd_gotoxy+0x2c>

		case 2:

			position=position+x;
     a80:	86 2f       	mov	r24, r22
     a82:	80 58       	subi	r24, 0x80	; 128

		break;
     a84:	04 c0       	rjmp	.+8      	; 0xa8e <lcd_gotoxy+0x2c>

		case 3:
			position=position+x;
     a86:	86 2f       	mov	r24, r22
     a88:	80 58       	subi	r24, 0x80	; 128
		break;
     a8a:	01 c0       	rjmp	.+2      	; 0xa8e <lcd_gotoxy+0x2c>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     a8c:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     a8e:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <lcd_sendCommand>


}
     a92:	08 95       	ret

00000a94 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     a94:	81 e0       	ldi	r24, 0x01	; 1
     a96:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <lcd_sendCommand>


}
     a9a:	08 95       	ret

00000a9c <lcd_dispString>:


void lcd_dispString(char * ptr)
{
     a9c:	cf 93       	push	r28
     a9e:	df 93       	push	r29
     aa0:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     aa2:	88 81       	ld	r24, Y
     aa4:	88 23       	and	r24, r24
     aa6:	31 f0       	breq	.+12     	; 0xab4 <lcd_dispString+0x18>


}


void lcd_dispString(char * ptr)
     aa8:	21 96       	adiw	r28, 0x01	; 1
{

	while(* ptr!= '\0')
	{
		lcd_displayChar(* ptr);
     aaa:	0e 94 17 05 	call	0xa2e	; 0xa2e <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     aae:	89 91       	ld	r24, Y+
     ab0:	88 23       	and	r24, r24
     ab2:	d9 f7       	brne	.-10     	; 0xaaa <lcd_dispString+0xe>
	
	}



}
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	08 95       	ret

00000aba <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
     aba:	cf 93       	push	r28
     abc:	df 93       	push	r29
     abe:	ec 01       	movw	r28, r24
     ac0:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
     ac2:	64 2f       	mov	r22, r20
     ac4:	0e 94 31 05 	call	0xa62	; 0xa62 <lcd_gotoxy>
	lcd_dispString(ptr);
     ac8:	ce 01       	movw	r24, r28
     aca:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_dispString>

	


}
     ace:	df 91       	pop	r29
     ad0:	cf 91       	pop	r28
     ad2:	08 95       	ret

00000ad4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     ad4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     ad6:	03 96       	adiw	r24, 0x03	; 3
     ad8:	92 83       	std	Z+2, r25	; 0x02
     ada:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     adc:	2f ef       	ldi	r18, 0xFF	; 255
     ade:	3f ef       	ldi	r19, 0xFF	; 255
     ae0:	34 83       	std	Z+4, r19	; 0x04
     ae2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     ae4:	96 83       	std	Z+6, r25	; 0x06
     ae6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     ae8:	90 87       	std	Z+8, r25	; 0x08
     aea:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     aec:	10 82       	st	Z, r1
}
     aee:	08 95       	ret

00000af0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     af0:	fc 01       	movw	r30, r24
     af2:	11 86       	std	Z+9, r1	; 0x09
     af4:	10 86       	std	Z+8, r1	; 0x08
}
     af6:	08 95       	ret

00000af8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     af8:	cf 93       	push	r28
     afa:	df 93       	push	r29
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     b00:	21 81       	ldd	r18, Z+1	; 0x01
     b02:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     b04:	e9 01       	movw	r28, r18
     b06:	8a 81       	ldd	r24, Y+2	; 0x02
     b08:	9b 81       	ldd	r25, Y+3	; 0x03
     b0a:	13 96       	adiw	r26, 0x03	; 3
     b0c:	9c 93       	st	X, r25
     b0e:	8e 93       	st	-X, r24
     b10:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     b12:	81 81       	ldd	r24, Z+1	; 0x01
     b14:	92 81       	ldd	r25, Z+2	; 0x02
     b16:	15 96       	adiw	r26, 0x05	; 5
     b18:	9c 93       	st	X, r25
     b1a:	8e 93       	st	-X, r24
     b1c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     b1e:	8a 81       	ldd	r24, Y+2	; 0x02
     b20:	9b 81       	ldd	r25, Y+3	; 0x03
     b22:	ec 01       	movw	r28, r24
     b24:	7d 83       	std	Y+5, r23	; 0x05
     b26:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     b28:	e9 01       	movw	r28, r18
     b2a:	7b 83       	std	Y+3, r23	; 0x03
     b2c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     b2e:	72 83       	std	Z+2, r23	; 0x02
     b30:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b32:	19 96       	adiw	r26, 0x09	; 9
     b34:	fc 93       	st	X, r31
     b36:	ee 93       	st	-X, r30
     b38:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     b3a:	80 81       	ld	r24, Z
     b3c:	8f 5f       	subi	r24, 0xFF	; 255
     b3e:	80 83       	st	Z, r24
}
     b40:	df 91       	pop	r29
     b42:	cf 91       	pop	r28
     b44:	08 95       	ret

00000b46 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     b46:	cf 93       	push	r28
     b48:	df 93       	push	r29
     b4a:	fc 01       	movw	r30, r24
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     b4c:	db 01       	movw	r26, r22
     b4e:	2d 91       	ld	r18, X+
     b50:	3c 91       	ld	r19, X
     b52:	11 97       	sbiw	r26, 0x01	; 1
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     b54:	bf ef       	ldi	r27, 0xFF	; 255
     b56:	2f 3f       	cpi	r18, 0xFF	; 255
     b58:	3b 07       	cpc	r19, r27
     b5a:	19 f4       	brne	.+6      	; 0xb62 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     b5c:	a7 81       	ldd	r26, Z+7	; 0x07
     b5e:	b0 85       	ldd	r27, Z+8	; 0x08
     b60:	18 c0       	rjmp	.+48     	; 0xb92 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     b62:	dc 01       	movw	r26, r24
     b64:	13 96       	adiw	r26, 0x03	; 3
     b66:	12 96       	adiw	r26, 0x02	; 2
     b68:	cd 91       	ld	r28, X+
     b6a:	dc 91       	ld	r29, X
     b6c:	13 97       	sbiw	r26, 0x03	; 3
     b6e:	88 81       	ld	r24, Y
     b70:	99 81       	ldd	r25, Y+1	; 0x01
     b72:	28 17       	cp	r18, r24
     b74:	39 07       	cpc	r19, r25
     b76:	68 f0       	brcs	.+26     	; 0xb92 <vListInsert+0x4c>
     b78:	12 96       	adiw	r26, 0x02	; 2
     b7a:	0d 90       	ld	r0, X+
     b7c:	bc 91       	ld	r27, X
     b7e:	a0 2d       	mov	r26, r0
     b80:	12 96       	adiw	r26, 0x02	; 2
     b82:	cd 91       	ld	r28, X+
     b84:	dc 91       	ld	r29, X
     b86:	13 97       	sbiw	r26, 0x03	; 3
     b88:	88 81       	ld	r24, Y
     b8a:	99 81       	ldd	r25, Y+1	; 0x01
     b8c:	28 17       	cp	r18, r24
     b8e:	39 07       	cpc	r19, r25
     b90:	98 f7       	brcc	.-26     	; 0xb78 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     b92:	12 96       	adiw	r26, 0x02	; 2
     b94:	8d 91       	ld	r24, X+
     b96:	9c 91       	ld	r25, X
     b98:	13 97       	sbiw	r26, 0x03	; 3
     b9a:	eb 01       	movw	r28, r22
     b9c:	9b 83       	std	Y+3, r25	; 0x03
     b9e:	8a 83       	std	Y+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     ba0:	ec 01       	movw	r28, r24
     ba2:	7d 83       	std	Y+5, r23	; 0x05
     ba4:	6c 83       	std	Y+4, r22	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     ba6:	eb 01       	movw	r28, r22
     ba8:	bd 83       	std	Y+5, r27	; 0x05
     baa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     bac:	13 96       	adiw	r26, 0x03	; 3
     bae:	7c 93       	st	X, r23
     bb0:	6e 93       	st	-X, r22
     bb2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     bb4:	f9 87       	std	Y+9, r31	; 0x09
     bb6:	e8 87       	std	Y+8, r30	; 0x08

	( pxList->uxNumberOfItems )++;
     bb8:	80 81       	ld	r24, Z
     bba:	8f 5f       	subi	r24, 0xFF	; 255
     bbc:	80 83       	st	Z, r24
}
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	08 95       	ret

00000bc4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     bc4:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     bc6:	a2 81       	ldd	r26, Z+2	; 0x02
     bc8:	b3 81       	ldd	r27, Z+3	; 0x03
     bca:	84 81       	ldd	r24, Z+4	; 0x04
     bcc:	95 81       	ldd	r25, Z+5	; 0x05
     bce:	15 96       	adiw	r26, 0x05	; 5
     bd0:	9c 93       	st	X, r25
     bd2:	8e 93       	st	-X, r24
     bd4:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     bd6:	a4 81       	ldd	r26, Z+4	; 0x04
     bd8:	b5 81       	ldd	r27, Z+5	; 0x05
     bda:	82 81       	ldd	r24, Z+2	; 0x02
     bdc:	93 81       	ldd	r25, Z+3	; 0x03
     bde:	13 96       	adiw	r26, 0x03	; 3
     be0:	9c 93       	st	X, r25
     be2:	8e 93       	st	-X, r24
     be4:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     be6:	a0 85       	ldd	r26, Z+8	; 0x08
     be8:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     bea:	11 96       	adiw	r26, 0x01	; 1
     bec:	8d 91       	ld	r24, X+
     bee:	9c 91       	ld	r25, X
     bf0:	12 97       	sbiw	r26, 0x02	; 2
     bf2:	8e 17       	cp	r24, r30
     bf4:	9f 07       	cpc	r25, r31
     bf6:	31 f4       	brne	.+12     	; 0xc04 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     bf8:	84 81       	ldd	r24, Z+4	; 0x04
     bfa:	95 81       	ldd	r25, Z+5	; 0x05
     bfc:	12 96       	adiw	r26, 0x02	; 2
     bfe:	9c 93       	st	X, r25
     c00:	8e 93       	st	-X, r24
     c02:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     c04:	11 86       	std	Z+9, r1	; 0x09
     c06:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     c08:	8c 91       	ld	r24, X
     c0a:	81 50       	subi	r24, 0x01	; 1
     c0c:	8c 93       	st	X, r24
}
     c0e:	08 95       	ret

00000c10 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     c10:	21 e1       	ldi	r18, 0x11	; 17
     c12:	fc 01       	movw	r30, r24
     c14:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     c16:	92 e2       	ldi	r25, 0x22	; 34
     c18:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     c1a:	83 e3       	ldi	r24, 0x33	; 51
     c1c:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c1e:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c20:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     c22:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     c24:	80 e8       	ldi	r24, 0x80	; 128
     c26:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     c28:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     c2a:	82 e0       	ldi	r24, 0x02	; 2
     c2c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     c2e:	83 e0       	ldi	r24, 0x03	; 3
     c30:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     c32:	84 e0       	ldi	r24, 0x04	; 4
     c34:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     c36:	85 e0       	ldi	r24, 0x05	; 5
     c38:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     c3a:	86 e0       	ldi	r24, 0x06	; 6
     c3c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     c3e:	87 e0       	ldi	r24, 0x07	; 7
     c40:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     c42:	88 e0       	ldi	r24, 0x08	; 8
     c44:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     c46:	89 e0       	ldi	r24, 0x09	; 9
     c48:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     c4a:	80 e1       	ldi	r24, 0x10	; 16
     c4c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     c4e:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     c50:	82 e1       	ldi	r24, 0x12	; 18
     c52:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     c54:	83 e1       	ldi	r24, 0x13	; 19
     c56:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     c58:	84 e1       	ldi	r24, 0x14	; 20
     c5a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     c5c:	85 e1       	ldi	r24, 0x15	; 21
     c5e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     c60:	86 e1       	ldi	r24, 0x16	; 22
     c62:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     c64:	87 e1       	ldi	r24, 0x17	; 23
     c66:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     c68:	88 e1       	ldi	r24, 0x18	; 24
     c6a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     c6c:	89 e1       	ldi	r24, 0x19	; 25
     c6e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     c70:	80 e2       	ldi	r24, 0x20	; 32
     c72:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     c74:	81 e2       	ldi	r24, 0x21	; 33
     c76:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     c78:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     c7a:	83 e2       	ldi	r24, 0x23	; 35
     c7c:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c7e:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     c80:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     c82:	86 e2       	ldi	r24, 0x26	; 38
     c84:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     c86:	87 e2       	ldi	r24, 0x27	; 39
     c88:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     c8a:	88 e2       	ldi	r24, 0x28	; 40
     c8c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     c8e:	89 e2       	ldi	r24, 0x29	; 41
     c90:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     c92:	80 e3       	ldi	r24, 0x30	; 48
     c94:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     c96:	81 e3       	ldi	r24, 0x31	; 49
     c98:	82 93       	st	-Z, r24
	pxTopOfStack--;
     c9a:	9f 01       	movw	r18, r30
     c9c:	21 50       	subi	r18, 0x01	; 1
     c9e:	30 40       	sbci	r19, 0x00	; 0

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     ca0:	82 2f       	mov	r24, r18
     ca2:	93 2f       	mov	r25, r19
     ca4:	08 95       	ret

00000ca6 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
     ca6:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     ca8:	89 e8       	ldi	r24, 0x89	; 137
     caa:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     cac:	8b e0       	ldi	r24, 0x0B	; 11
     cae:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     cb0:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     cb2:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     cb4:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     cb6:	a0 91 e8 06 	lds	r26, 0x06E8
     cba:	b0 91 e9 06 	lds	r27, 0x06E9
     cbe:	cd 91       	ld	r28, X+
     cc0:	cd bf       	out	0x3d, r28	; 61
     cc2:	dd 91       	ld	r29, X+
     cc4:	de bf       	out	0x3e, r29	; 62
     cc6:	ff 91       	pop	r31
     cc8:	ef 91       	pop	r30
     cca:	df 91       	pop	r29
     ccc:	cf 91       	pop	r28
     cce:	bf 91       	pop	r27
     cd0:	af 91       	pop	r26
     cd2:	9f 91       	pop	r25
     cd4:	8f 91       	pop	r24
     cd6:	7f 91       	pop	r23
     cd8:	6f 91       	pop	r22
     cda:	5f 91       	pop	r21
     cdc:	4f 91       	pop	r20
     cde:	3f 91       	pop	r19
     ce0:	2f 91       	pop	r18
     ce2:	1f 91       	pop	r17
     ce4:	0f 91       	pop	r16
     ce6:	ff 90       	pop	r15
     ce8:	ef 90       	pop	r14
     cea:	df 90       	pop	r13
     cec:	cf 90       	pop	r12
     cee:	bf 90       	pop	r11
     cf0:	af 90       	pop	r10
     cf2:	9f 90       	pop	r9
     cf4:	8f 90       	pop	r8
     cf6:	7f 90       	pop	r7
     cf8:	6f 90       	pop	r6
     cfa:	5f 90       	pop	r5
     cfc:	4f 90       	pop	r4
     cfe:	3f 90       	pop	r3
     d00:	2f 90       	pop	r2
     d02:	1f 90       	pop	r1
     d04:	0f 90       	pop	r0
     d06:	0f be       	out	0x3f, r0	; 63
     d08:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     d0a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	08 95       	ret

00000d10 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     d10:	08 95       	ret

00000d12 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d12:	0f 92       	push	r0
     d14:	0f b6       	in	r0, 0x3f	; 63
     d16:	f8 94       	cli
     d18:	0f 92       	push	r0
     d1a:	1f 92       	push	r1
     d1c:	11 24       	eor	r1, r1
     d1e:	2f 92       	push	r2
     d20:	3f 92       	push	r3
     d22:	4f 92       	push	r4
     d24:	5f 92       	push	r5
     d26:	6f 92       	push	r6
     d28:	7f 92       	push	r7
     d2a:	8f 92       	push	r8
     d2c:	9f 92       	push	r9
     d2e:	af 92       	push	r10
     d30:	bf 92       	push	r11
     d32:	cf 92       	push	r12
     d34:	df 92       	push	r13
     d36:	ef 92       	push	r14
     d38:	ff 92       	push	r15
     d3a:	0f 93       	push	r16
     d3c:	1f 93       	push	r17
     d3e:	2f 93       	push	r18
     d40:	3f 93       	push	r19
     d42:	4f 93       	push	r20
     d44:	5f 93       	push	r21
     d46:	6f 93       	push	r22
     d48:	7f 93       	push	r23
     d4a:	8f 93       	push	r24
     d4c:	9f 93       	push	r25
     d4e:	af 93       	push	r26
     d50:	bf 93       	push	r27
     d52:	cf 93       	push	r28
     d54:	df 93       	push	r29
     d56:	ef 93       	push	r30
     d58:	ff 93       	push	r31
     d5a:	a0 91 e8 06 	lds	r26, 0x06E8
     d5e:	b0 91 e9 06 	lds	r27, 0x06E9
     d62:	0d b6       	in	r0, 0x3d	; 61
     d64:	0d 92       	st	X+, r0
     d66:	0e b6       	in	r0, 0x3e	; 62
     d68:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     d6a:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     d6e:	a0 91 e8 06 	lds	r26, 0x06E8
     d72:	b0 91 e9 06 	lds	r27, 0x06E9
     d76:	cd 91       	ld	r28, X+
     d78:	cd bf       	out	0x3d, r28	; 61
     d7a:	dd 91       	ld	r29, X+
     d7c:	de bf       	out	0x3e, r29	; 62
     d7e:	ff 91       	pop	r31
     d80:	ef 91       	pop	r30
     d82:	df 91       	pop	r29
     d84:	cf 91       	pop	r28
     d86:	bf 91       	pop	r27
     d88:	af 91       	pop	r26
     d8a:	9f 91       	pop	r25
     d8c:	8f 91       	pop	r24
     d8e:	7f 91       	pop	r23
     d90:	6f 91       	pop	r22
     d92:	5f 91       	pop	r21
     d94:	4f 91       	pop	r20
     d96:	3f 91       	pop	r19
     d98:	2f 91       	pop	r18
     d9a:	1f 91       	pop	r17
     d9c:	0f 91       	pop	r16
     d9e:	ff 90       	pop	r15
     da0:	ef 90       	pop	r14
     da2:	df 90       	pop	r13
     da4:	cf 90       	pop	r12
     da6:	bf 90       	pop	r11
     da8:	af 90       	pop	r10
     daa:	9f 90       	pop	r9
     dac:	8f 90       	pop	r8
     dae:	7f 90       	pop	r7
     db0:	6f 90       	pop	r6
     db2:	5f 90       	pop	r5
     db4:	4f 90       	pop	r4
     db6:	3f 90       	pop	r3
     db8:	2f 90       	pop	r2
     dba:	1f 90       	pop	r1
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63
     dc0:	0f 90       	pop	r0

	asm volatile ( "ret" );
     dc2:	08 95       	ret

00000dc4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     dc4:	0f 92       	push	r0
     dc6:	0f b6       	in	r0, 0x3f	; 63
     dc8:	f8 94       	cli
     dca:	0f 92       	push	r0
     dcc:	1f 92       	push	r1
     dce:	11 24       	eor	r1, r1
     dd0:	2f 92       	push	r2
     dd2:	3f 92       	push	r3
     dd4:	4f 92       	push	r4
     dd6:	5f 92       	push	r5
     dd8:	6f 92       	push	r6
     dda:	7f 92       	push	r7
     ddc:	8f 92       	push	r8
     dde:	9f 92       	push	r9
     de0:	af 92       	push	r10
     de2:	bf 92       	push	r11
     de4:	cf 92       	push	r12
     de6:	df 92       	push	r13
     de8:	ef 92       	push	r14
     dea:	ff 92       	push	r15
     dec:	0f 93       	push	r16
     dee:	1f 93       	push	r17
     df0:	2f 93       	push	r18
     df2:	3f 93       	push	r19
     df4:	4f 93       	push	r20
     df6:	5f 93       	push	r21
     df8:	6f 93       	push	r22
     dfa:	7f 93       	push	r23
     dfc:	8f 93       	push	r24
     dfe:	9f 93       	push	r25
     e00:	af 93       	push	r26
     e02:	bf 93       	push	r27
     e04:	cf 93       	push	r28
     e06:	df 93       	push	r29
     e08:	ef 93       	push	r30
     e0a:	ff 93       	push	r31
     e0c:	a0 91 e8 06 	lds	r26, 0x06E8
     e10:	b0 91 e9 06 	lds	r27, 0x06E9
     e14:	0d b6       	in	r0, 0x3d	; 61
     e16:	0d 92       	st	X+, r0
     e18:	0e b6       	in	r0, 0x3e	; 62
     e1a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     e1c:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vTaskIncrementTick>
	vTaskSwitchContext();
     e20:	0e 94 fb 11 	call	0x23f6	; 0x23f6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e24:	a0 91 e8 06 	lds	r26, 0x06E8
     e28:	b0 91 e9 06 	lds	r27, 0x06E9
     e2c:	cd 91       	ld	r28, X+
     e2e:	cd bf       	out	0x3d, r28	; 61
     e30:	dd 91       	ld	r29, X+
     e32:	de bf       	out	0x3e, r29	; 62
     e34:	ff 91       	pop	r31
     e36:	ef 91       	pop	r30
     e38:	df 91       	pop	r29
     e3a:	cf 91       	pop	r28
     e3c:	bf 91       	pop	r27
     e3e:	af 91       	pop	r26
     e40:	9f 91       	pop	r25
     e42:	8f 91       	pop	r24
     e44:	7f 91       	pop	r23
     e46:	6f 91       	pop	r22
     e48:	5f 91       	pop	r21
     e4a:	4f 91       	pop	r20
     e4c:	3f 91       	pop	r19
     e4e:	2f 91       	pop	r18
     e50:	1f 91       	pop	r17
     e52:	0f 91       	pop	r16
     e54:	ff 90       	pop	r15
     e56:	ef 90       	pop	r14
     e58:	df 90       	pop	r13
     e5a:	cf 90       	pop	r12
     e5c:	bf 90       	pop	r11
     e5e:	af 90       	pop	r10
     e60:	9f 90       	pop	r9
     e62:	8f 90       	pop	r8
     e64:	7f 90       	pop	r7
     e66:	6f 90       	pop	r6
     e68:	5f 90       	pop	r5
     e6a:	4f 90       	pop	r4
     e6c:	3f 90       	pop	r3
     e6e:	2f 90       	pop	r2
     e70:	1f 90       	pop	r1
     e72:	0f 90       	pop	r0
     e74:	0f be       	out	0x3f, r0	; 63
     e76:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e78:	08 95       	ret

00000e7a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void  TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void  TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     e7a:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <vPortYieldFromTick>
		asm volatile ( "reti" );
     e7e:	18 95       	reti

00000e80 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     e80:	cf 93       	push	r28
     e82:	df 93       	push	r29
     e84:	fc 01       	movw	r30, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     e86:	a0 81       	ld	r26, Z
     e88:	b1 81       	ldd	r27, Z+1	; 0x01
     e8a:	10 97       	sbiw	r26, 0x00	; 0
     e8c:	b9 f0       	breq	.+46     	; 0xebc <prvCopyDataFromQueue+0x3c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     e8e:	44 8d       	ldd	r20, Z+28	; 0x1c
     e90:	26 81       	ldd	r18, Z+6	; 0x06
     e92:	37 81       	ldd	r19, Z+7	; 0x07
     e94:	24 0f       	add	r18, r20
     e96:	31 1d       	adc	r19, r1
     e98:	37 83       	std	Z+7, r19	; 0x07
     e9a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     e9c:	c2 81       	ldd	r28, Z+2	; 0x02
     e9e:	d3 81       	ldd	r29, Z+3	; 0x03
     ea0:	2c 17       	cp	r18, r28
     ea2:	3d 07       	cpc	r19, r29
     ea4:	10 f0       	brcs	.+4      	; 0xeaa <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     ea6:	b7 83       	std	Z+7, r27	; 0x07
     ea8:	a6 83       	std	Z+6, r26	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     eaa:	36 81       	ldd	r19, Z+6	; 0x06
     eac:	27 81       	ldd	r18, Z+7	; 0x07
     eae:	86 2f       	mov	r24, r22
     eb0:	97 2f       	mov	r25, r23
     eb2:	63 2f       	mov	r22, r19
     eb4:	72 2f       	mov	r23, r18
     eb6:	50 e0       	ldi	r21, 0x00	; 0
     eb8:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <memcpy>
	}
}
     ebc:	df 91       	pop	r29
     ebe:	cf 91       	pop	r28
     ec0:	08 95       	ret

00000ec2 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     ec2:	cf 93       	push	r28
     ec4:	df 93       	push	r29
     ec6:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     ec8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     eca:	22 23       	and	r18, r18
     ecc:	a9 f1       	breq	.+106    	; 0xf38 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     ece:	44 23       	and	r20, r20
     ed0:	b9 f4       	brne	.+46     	; 0xf00 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     ed2:	8c 81       	ldd	r24, Y+4	; 0x04
     ed4:	9d 81       	ldd	r25, Y+5	; 0x05
     ed6:	42 2f       	mov	r20, r18
     ed8:	50 e0       	ldi	r21, 0x00	; 0
     eda:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     ede:	2c 8d       	ldd	r18, Y+28	; 0x1c
     ee0:	8c 81       	ldd	r24, Y+4	; 0x04
     ee2:	9d 81       	ldd	r25, Y+5	; 0x05
     ee4:	82 0f       	add	r24, r18
     ee6:	91 1d       	adc	r25, r1
     ee8:	9d 83       	std	Y+5, r25	; 0x05
     eea:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     eec:	2a 81       	ldd	r18, Y+2	; 0x02
     eee:	3b 81       	ldd	r19, Y+3	; 0x03
     ef0:	82 17       	cp	r24, r18
     ef2:	93 07       	cpc	r25, r19
     ef4:	08 f1       	brcs	.+66     	; 0xf38 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     ef6:	88 81       	ld	r24, Y
     ef8:	99 81       	ldd	r25, Y+1	; 0x01
     efa:	9d 83       	std	Y+5, r25	; 0x05
     efc:	8c 83       	std	Y+4, r24	; 0x04
     efe:	1c c0       	rjmp	.+56     	; 0xf38 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     f00:	8e 81       	ldd	r24, Y+6	; 0x06
     f02:	9f 81       	ldd	r25, Y+7	; 0x07
     f04:	42 2f       	mov	r20, r18
     f06:	50 e0       	ldi	r21, 0x00	; 0
     f08:	0e 94 8c 16 	call	0x2d18	; 0x2d18 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     f0c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     f0e:	30 e0       	ldi	r19, 0x00	; 0
     f10:	30 95       	com	r19
     f12:	21 95       	neg	r18
     f14:	3f 4f       	sbci	r19, 0xFF	; 255
     f16:	8e 81       	ldd	r24, Y+6	; 0x06
     f18:	9f 81       	ldd	r25, Y+7	; 0x07
     f1a:	82 0f       	add	r24, r18
     f1c:	93 1f       	adc	r25, r19
     f1e:	9f 83       	std	Y+7, r25	; 0x07
     f20:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     f22:	48 81       	ld	r20, Y
     f24:	59 81       	ldd	r21, Y+1	; 0x01
     f26:	84 17       	cp	r24, r20
     f28:	95 07       	cpc	r25, r21
     f2a:	30 f4       	brcc	.+12     	; 0xf38 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     f2c:	8a 81       	ldd	r24, Y+2	; 0x02
     f2e:	9b 81       	ldd	r25, Y+3	; 0x03
     f30:	28 0f       	add	r18, r24
     f32:	39 1f       	adc	r19, r25
     f34:	3f 83       	std	Y+7, r19	; 0x07
     f36:	2e 83       	std	Y+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     f38:	8a 8d       	ldd	r24, Y+26	; 0x1a
     f3a:	8f 5f       	subi	r24, 0xFF	; 255
     f3c:	8a 8f       	std	Y+26, r24	; 0x1a
}
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	08 95       	ret

00000f44 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
     f44:	0f 93       	push	r16
     f46:	1f 93       	push	r17
     f48:	cf 93       	push	r28
     f4a:	df 93       	push	r29
     f4c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     f4e:	0f b6       	in	r0, 0x3f	; 63
     f50:	f8 94       	cli
     f52:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     f54:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f56:	18 16       	cp	r1, r24
     f58:	bc f4       	brge	.+46     	; 0xf88 <prvUnlockQueue+0x44>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f5a:	89 89       	ldd	r24, Y+17	; 0x11
     f5c:	88 23       	and	r24, r24
     f5e:	29 f4       	brne	.+10     	; 0xf6a <prvUnlockQueue+0x26>
     f60:	13 c0       	rjmp	.+38     	; 0xf88 <prvUnlockQueue+0x44>
     f62:	89 89       	ldd	r24, Y+17	; 0x11
     f64:	88 23       	and	r24, r24
     f66:	21 f4       	brne	.+8      	; 0xf70 <prvUnlockQueue+0x2c>
     f68:	0f c0       	rjmp	.+30     	; 0xf88 <prvUnlockQueue+0x44>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f6a:	8e 01       	movw	r16, r28
     f6c:	0f 5e       	subi	r16, 0xEF	; 239
     f6e:	1f 4f       	sbci	r17, 0xFF	; 255
     f70:	c8 01       	movw	r24, r16
     f72:	0e 94 86 12 	call	0x250c	; 0x250c <xTaskRemoveFromEventList>
     f76:	88 23       	and	r24, r24
     f78:	11 f0       	breq	.+4      	; 0xf7e <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
     f7a:	0e 94 0d 13 	call	0x261a	; 0x261a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
     f7e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f80:	81 50       	subi	r24, 0x01	; 1
     f82:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     f84:	18 16       	cp	r1, r24
     f86:	6c f3       	brlt	.-38     	; 0xf62 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
     f88:	8f ef       	ldi	r24, 0xFF	; 255
     f8a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     f8c:	0f 90       	pop	r0
     f8e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     f90:	0f b6       	in	r0, 0x3f	; 63
     f92:	f8 94       	cli
     f94:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     f96:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f98:	18 16       	cp	r1, r24
     f9a:	bc f4       	brge	.+46     	; 0xfca <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f9c:	88 85       	ldd	r24, Y+8	; 0x08
     f9e:	88 23       	and	r24, r24
     fa0:	29 f4       	brne	.+10     	; 0xfac <prvUnlockQueue+0x68>
     fa2:	13 c0       	rjmp	.+38     	; 0xfca <prvUnlockQueue+0x86>
     fa4:	88 85       	ldd	r24, Y+8	; 0x08
     fa6:	88 23       	and	r24, r24
     fa8:	21 f4       	brne	.+8      	; 0xfb2 <prvUnlockQueue+0x6e>
     faa:	0f c0       	rjmp	.+30     	; 0xfca <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fac:	8e 01       	movw	r16, r28
     fae:	08 5f       	subi	r16, 0xF8	; 248
     fb0:	1f 4f       	sbci	r17, 0xFF	; 255
     fb2:	c8 01       	movw	r24, r16
     fb4:	0e 94 86 12 	call	0x250c	; 0x250c <xTaskRemoveFromEventList>
     fb8:	88 23       	and	r24, r24
     fba:	11 f0       	breq	.+4      	; 0xfc0 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
     fbc:	0e 94 0d 13 	call	0x261a	; 0x261a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     fc0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     fc2:	81 50       	subi	r24, 0x01	; 1
     fc4:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     fc6:	18 16       	cp	r1, r24
     fc8:	6c f3       	brlt	.-38     	; 0xfa4 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     fca:	8f ef       	ldi	r24, 0xFF	; 255
     fcc:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     fce:	0f 90       	pop	r0
     fd0:	0f be       	out	0x3f, r0	; 63
}
     fd2:	df 91       	pop	r29
     fd4:	cf 91       	pop	r28
     fd6:	1f 91       	pop	r17
     fd8:	0f 91       	pop	r16
     fda:	08 95       	ret

00000fdc <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     fdc:	8f 92       	push	r8
     fde:	9f 92       	push	r9
     fe0:	af 92       	push	r10
     fe2:	bf 92       	push	r11
     fe4:	cf 92       	push	r12
     fe6:	df 92       	push	r13
     fe8:	ef 92       	push	r14
     fea:	ff 92       	push	r15
     fec:	0f 93       	push	r16
     fee:	1f 93       	push	r17
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	18 2f       	mov	r17, r24
     ff6:	06 2f       	mov	r16, r22
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     ff8:	88 23       	and	r24, r24
     ffa:	09 f4       	brne	.+2      	; 0xffe <xQueueCreate+0x22>
     ffc:	49 c0       	rjmp	.+146    	; 0x1090 <xQueueCreate+0xb4>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     ffe:	8f e1       	ldi	r24, 0x1F	; 31
    1000:	90 e0       	ldi	r25, 0x00	; 0
    1002:	0e 94 d5 03 	call	0x7aa	; 0x7aa <pvPortMalloc>
    1006:	e8 2e       	mov	r14, r24
    1008:	f9 2e       	mov	r15, r25
    100a:	e7 01       	movw	r28, r14
		if( pxNewQueue != NULL )
    100c:	20 97       	sbiw	r28, 0x00	; 0
    100e:	09 f4       	brne	.+2      	; 0x1012 <xQueueCreate+0x36>
    1010:	42 c0       	rjmp	.+132    	; 0x1096 <xQueueCreate+0xba>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1012:	a1 2e       	mov	r10, r17
    1014:	bb 24       	eor	r11, r11
    1016:	80 2e       	mov	r8, r16
    1018:	99 24       	eor	r9, r9
    101a:	8a 9c       	mul	r8, r10
    101c:	60 01       	movw	r12, r0
    101e:	8b 9c       	mul	r8, r11
    1020:	d0 0c       	add	r13, r0
    1022:	9a 9c       	mul	r9, r10
    1024:	d0 0c       	add	r13, r0
    1026:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1028:	c6 01       	movw	r24, r12
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	0e 94 d5 03 	call	0x7aa	; 0x7aa <pvPortMalloc>
    1030:	28 2f       	mov	r18, r24
    1032:	39 2f       	mov	r19, r25
    1034:	39 83       	std	Y+1, r19	; 0x01
    1036:	28 83       	st	Y, r18
			if( pxNewQueue->pcHead != NULL )
    1038:	21 15       	cp	r18, r1
    103a:	31 05       	cpc	r19, r1
    103c:	19 f1       	breq	.+70     	; 0x1084 <xQueueCreate+0xa8>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    103e:	c2 0e       	add	r12, r18
    1040:	d3 1e       	adc	r13, r19
    1042:	db 82       	std	Y+3, r13	; 0x03
    1044:	ca 82       	std	Y+2, r12	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1046:	1a 8e       	std	Y+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1048:	3d 83       	std	Y+5, r19	; 0x05
    104a:	2c 83       	std	Y+4, r18	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    104c:	08 94       	sec
    104e:	a1 08       	sbc	r10, r1
    1050:	b1 08       	sbc	r11, r1
    1052:	a8 9c       	mul	r10, r8
    1054:	c0 01       	movw	r24, r0
    1056:	a9 9c       	mul	r10, r9
    1058:	90 0d       	add	r25, r0
    105a:	b8 9c       	mul	r11, r8
    105c:	90 0d       	add	r25, r0
    105e:	11 24       	eor	r1, r1
    1060:	28 0f       	add	r18, r24
    1062:	39 1f       	adc	r19, r25
    1064:	3f 83       	std	Y+7, r19	; 0x07
    1066:	2e 83       	std	Y+6, r18	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1068:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    106a:	0c 8f       	std	Y+28, r16	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    106c:	8f ef       	ldi	r24, 0xFF	; 255
    106e:	8d 8f       	std	Y+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1070:	8e 8f       	std	Y+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1072:	ce 01       	movw	r24, r28
    1074:	08 96       	adiw	r24, 0x08	; 8
    1076:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    107a:	ce 01       	movw	r24, r28
    107c:	41 96       	adiw	r24, 0x11	; 17
    107e:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
    1082:	0b c0       	rjmp	.+22     	; 0x109a <xQueueCreate+0xbe>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1084:	ce 01       	movw	r24, r28
    1086:	0e 94 03 04 	call	0x806	; 0x806 <vPortFree>

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    108a:	c0 e0       	ldi	r28, 0x00	; 0
    108c:	d0 e0       	ldi	r29, 0x00	; 0
    108e:	05 c0       	rjmp	.+10     	; 0x109a <xQueueCreate+0xbe>
    1090:	c0 e0       	ldi	r28, 0x00	; 0
    1092:	d0 e0       	ldi	r29, 0x00	; 0
    1094:	02 c0       	rjmp	.+4      	; 0x109a <xQueueCreate+0xbe>
    1096:	c0 e0       	ldi	r28, 0x00	; 0
    1098:	d0 e0       	ldi	r29, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    109a:	7e 01       	movw	r14, r28
    109c:	8c 2f       	mov	r24, r28
    109e:	9f 2d       	mov	r25, r15
    10a0:	df 91       	pop	r29
    10a2:	cf 91       	pop	r28
    10a4:	1f 91       	pop	r17
    10a6:	0f 91       	pop	r16
    10a8:	ff 90       	pop	r15
    10aa:	ef 90       	pop	r14
    10ac:	df 90       	pop	r13
    10ae:	cf 90       	pop	r12
    10b0:	bf 90       	pop	r11
    10b2:	af 90       	pop	r10
    10b4:	9f 90       	pop	r9
    10b6:	8f 90       	pop	r8
    10b8:	08 95       	ret

000010ba <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    10ba:	5f 92       	push	r5
    10bc:	6f 92       	push	r6
    10be:	7f 92       	push	r7
    10c0:	8f 92       	push	r8
    10c2:	9f 92       	push	r9
    10c4:	af 92       	push	r10
    10c6:	bf 92       	push	r11
    10c8:	cf 92       	push	r12
    10ca:	df 92       	push	r13
    10cc:	ef 92       	push	r14
    10ce:	ff 92       	push	r15
    10d0:	0f 93       	push	r16
    10d2:	1f 93       	push	r17
    10d4:	df 93       	push	r29
    10d6:	cf 93       	push	r28
    10d8:	00 d0       	rcall	.+0      	; 0x10da <xQueueGenericSend+0x20>
    10da:	00 d0       	rcall	.+0      	; 0x10dc <xQueueGenericSend+0x22>
    10dc:	0f 92       	push	r0
    10de:	cd b7       	in	r28, 0x3d	; 61
    10e0:	de b7       	in	r29, 0x3e	; 62
    10e2:	8c 01       	movw	r16, r24
    10e4:	3b 01       	movw	r6, r22
    10e6:	5d 83       	std	Y+5, r21	; 0x05
    10e8:	4c 83       	std	Y+4, r20	; 0x04
    10ea:	52 2e       	mov	r5, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    10ec:	dd 24       	eor	r13, r13
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    10ee:	7e 01       	movw	r14, r28
    10f0:	08 94       	sec
    10f2:	e1 1c       	adc	r14, r1
    10f4:	f1 1c       	adc	r15, r1
					xEntryTimeSet = pdTRUE;
    10f6:	cc 24       	eor	r12, r12
    10f8:	c3 94       	inc	r12

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    10fa:	aa 24       	eor	r10, r10
    10fc:	bb 24       	eor	r11, r11
    10fe:	68 94       	set
    1100:	a2 f8       	bld	r10, 2
    1102:	ac 0e       	add	r10, r28
    1104:	bd 1e       	adc	r11, r29
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1106:	88 24       	eor	r8, r8
    1108:	99 24       	eor	r9, r9
    110a:	68 94       	set
    110c:	83 f8       	bld	r8, 3
    110e:	88 0e       	add	r8, r24
    1110:	99 1e       	adc	r9, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1112:	0f b6       	in	r0, 0x3f	; 63
    1114:	f8 94       	cli
    1116:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1118:	f8 01       	movw	r30, r16
    111a:	92 8d       	ldd	r25, Z+26	; 0x1a
    111c:	83 8d       	ldd	r24, Z+27	; 0x1b
    111e:	98 17       	cp	r25, r24
    1120:	a8 f4       	brcc	.+42     	; 0x114c <xQueueGenericSend+0x92>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1122:	c8 01       	movw	r24, r16
    1124:	b3 01       	movw	r22, r6
    1126:	45 2d       	mov	r20, r5
    1128:	0e 94 61 07 	call	0xec2	; 0xec2 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    112c:	f8 01       	movw	r30, r16
    112e:	81 89       	ldd	r24, Z+17	; 0x11
    1130:	88 23       	and	r24, r24
    1132:	41 f0       	breq	.+16     	; 0x1144 <xQueueGenericSend+0x8a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1134:	c8 01       	movw	r24, r16
    1136:	41 96       	adiw	r24, 0x11	; 17
    1138:	0e 94 86 12 	call	0x250c	; 0x250c <xTaskRemoveFromEventList>
    113c:	81 30       	cpi	r24, 0x01	; 1
    113e:	11 f4       	brne	.+4      	; 0x1144 <xQueueGenericSend+0x8a>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1140:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1144:	0f 90       	pop	r0
    1146:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1148:	81 e0       	ldi	r24, 0x01	; 1
    114a:	4e c0       	rjmp	.+156    	; 0x11e8 <xQueueGenericSend+0x12e>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    114c:	8c 81       	ldd	r24, Y+4	; 0x04
    114e:	9d 81       	ldd	r25, Y+5	; 0x05
    1150:	00 97       	sbiw	r24, 0x00	; 0
    1152:	21 f4       	brne	.+8      	; 0x115c <xQueueGenericSend+0xa2>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1154:	0f 90       	pop	r0
    1156:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1158:	80 e0       	ldi	r24, 0x00	; 0
    115a:	46 c0       	rjmp	.+140    	; 0x11e8 <xQueueGenericSend+0x12e>
				}
				else if( xEntryTimeSet == pdFALSE )
    115c:	dd 20       	and	r13, r13
    115e:	21 f4       	brne	.+8      	; 0x1168 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1160:	c7 01       	movw	r24, r14
    1162:	0e 94 cc 12 	call	0x2598	; 0x2598 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1166:	dc 2c       	mov	r13, r12
				}
			}
		}
		taskEXIT_CRITICAL();
    1168:	0f 90       	pop	r0
    116a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    116c:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1170:	0f b6       	in	r0, 0x3f	; 63
    1172:	f8 94       	cli
    1174:	0f 92       	push	r0
    1176:	f8 01       	movw	r30, r16
    1178:	85 8d       	ldd	r24, Z+29	; 0x1d
    117a:	8f 3f       	cpi	r24, 0xFF	; 255
    117c:	09 f4       	brne	.+2      	; 0x1180 <xQueueGenericSend+0xc6>
    117e:	15 8e       	std	Z+29, r1	; 0x1d
    1180:	f8 01       	movw	r30, r16
    1182:	86 8d       	ldd	r24, Z+30	; 0x1e
    1184:	8f 3f       	cpi	r24, 0xFF	; 255
    1186:	09 f4       	brne	.+2      	; 0x118a <xQueueGenericSend+0xd0>
    1188:	16 8e       	std	Z+30, r1	; 0x1e
    118a:	0f 90       	pop	r0
    118c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    118e:	c7 01       	movw	r24, r14
    1190:	b5 01       	movw	r22, r10
    1192:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xTaskCheckForTimeOut>
    1196:	88 23       	and	r24, r24
    1198:	09 f5       	brne	.+66     	; 0x11dc <xQueueGenericSend+0x122>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    119a:	0f b6       	in	r0, 0x3f	; 63
    119c:	f8 94       	cli
    119e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    11a0:	f8 01       	movw	r30, r16
    11a2:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    11a4:	0f 90       	pop	r0
    11a6:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    11a8:	f8 01       	movw	r30, r16
    11aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    11ac:	98 17       	cp	r25, r24
    11ae:	81 f4       	brne	.+32     	; 0x11d0 <xQueueGenericSend+0x116>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    11b0:	6c 81       	ldd	r22, Y+4	; 0x04
    11b2:	7d 81       	ldd	r23, Y+5	; 0x05
    11b4:	c4 01       	movw	r24, r8
    11b6:	0e 94 69 12 	call	0x24d2	; 0x24d2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    11ba:	c8 01       	movw	r24, r16
    11bc:	0e 94 a2 07 	call	0xf44	; 0xf44 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    11c0:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
    11c4:	88 23       	and	r24, r24
    11c6:	09 f0       	breq	.+2      	; 0x11ca <xQueueGenericSend+0x110>
    11c8:	a4 cf       	rjmp	.-184    	; 0x1112 <xQueueGenericSend+0x58>
				{
					portYIELD_WITHIN_API();
    11ca:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
    11ce:	a1 cf       	rjmp	.-190    	; 0x1112 <xQueueGenericSend+0x58>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    11d0:	c8 01       	movw	r24, r16
    11d2:	0e 94 a2 07 	call	0xf44	; 0xf44 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    11d6:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
    11da:	9b cf       	rjmp	.-202    	; 0x1112 <xQueueGenericSend+0x58>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    11dc:	c8 01       	movw	r24, r16
    11de:	0e 94 a2 07 	call	0xf44	; 0xf44 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    11e2:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    11e6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    11e8:	0f 90       	pop	r0
    11ea:	0f 90       	pop	r0
    11ec:	0f 90       	pop	r0
    11ee:	0f 90       	pop	r0
    11f0:	0f 90       	pop	r0
    11f2:	cf 91       	pop	r28
    11f4:	df 91       	pop	r29
    11f6:	1f 91       	pop	r17
    11f8:	0f 91       	pop	r16
    11fa:	ff 90       	pop	r15
    11fc:	ef 90       	pop	r14
    11fe:	df 90       	pop	r13
    1200:	cf 90       	pop	r12
    1202:	bf 90       	pop	r11
    1204:	af 90       	pop	r10
    1206:	9f 90       	pop	r9
    1208:	8f 90       	pop	r8
    120a:	7f 90       	pop	r7
    120c:	6f 90       	pop	r6
    120e:	5f 90       	pop	r5
    1210:	08 95       	ret

00001212 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1212:	0f 93       	push	r16
    1214:	1f 93       	push	r17
    1216:	cf 93       	push	r28
    1218:	df 93       	push	r29
    121a:	ec 01       	movw	r28, r24
    121c:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    121e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1220:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1222:	98 17       	cp	r25, r24
    1224:	c0 f4       	brcc	.+48     	; 0x1256 <xQueueGenericSendFromISR+0x44>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1226:	ce 01       	movw	r24, r28
    1228:	42 2f       	mov	r20, r18
    122a:	0e 94 61 07 	call	0xec2	; 0xec2 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    122e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1230:	8f 3f       	cpi	r24, 0xFF	; 255
    1232:	69 f4       	brne	.+26     	; 0x124e <xQueueGenericSendFromISR+0x3c>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1234:	89 89       	ldd	r24, Y+17	; 0x11
    1236:	88 23       	and	r24, r24
    1238:	81 f0       	breq	.+32     	; 0x125a <xQueueGenericSendFromISR+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    123a:	ce 01       	movw	r24, r28
    123c:	41 96       	adiw	r24, 0x11	; 17
    123e:	0e 94 86 12 	call	0x250c	; 0x250c <xTaskRemoveFromEventList>
    1242:	88 23       	and	r24, r24
    1244:	61 f0       	breq	.+24     	; 0x125e <xQueueGenericSendFromISR+0x4c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    1246:	81 e0       	ldi	r24, 0x01	; 1
    1248:	f8 01       	movw	r30, r16
    124a:	80 83       	st	Z, r24
    124c:	09 c0       	rjmp	.+18     	; 0x1260 <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    124e:	8f 5f       	subi	r24, 0xFF	; 255
    1250:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1252:	81 e0       	ldi	r24, 0x01	; 1
    1254:	05 c0       	rjmp	.+10     	; 0x1260 <xQueueGenericSendFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1256:	80 e0       	ldi	r24, 0x00	; 0
    1258:	03 c0       	rjmp	.+6      	; 0x1260 <xQueueGenericSendFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    125a:	81 e0       	ldi	r24, 0x01	; 1
    125c:	01 c0       	rjmp	.+2      	; 0x1260 <xQueueGenericSendFromISR+0x4e>
    125e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1260:	df 91       	pop	r29
    1262:	cf 91       	pop	r28
    1264:	1f 91       	pop	r17
    1266:	0f 91       	pop	r16
    1268:	08 95       	ret

0000126a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    126a:	5f 92       	push	r5
    126c:	6f 92       	push	r6
    126e:	7f 92       	push	r7
    1270:	8f 92       	push	r8
    1272:	9f 92       	push	r9
    1274:	af 92       	push	r10
    1276:	bf 92       	push	r11
    1278:	cf 92       	push	r12
    127a:	df 92       	push	r13
    127c:	ef 92       	push	r14
    127e:	ff 92       	push	r15
    1280:	0f 93       	push	r16
    1282:	1f 93       	push	r17
    1284:	df 93       	push	r29
    1286:	cf 93       	push	r28
    1288:	00 d0       	rcall	.+0      	; 0x128a <xQueueGenericReceive+0x20>
    128a:	00 d0       	rcall	.+0      	; 0x128c <xQueueGenericReceive+0x22>
    128c:	0f 92       	push	r0
    128e:	cd b7       	in	r28, 0x3d	; 61
    1290:	de b7       	in	r29, 0x3e	; 62
    1292:	8c 01       	movw	r16, r24
    1294:	3b 01       	movw	r6, r22
    1296:	5d 83       	std	Y+5, r21	; 0x05
    1298:	4c 83       	std	Y+4, r20	; 0x04
    129a:	52 2e       	mov	r5, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    129c:	dd 24       	eor	r13, r13
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    129e:	7e 01       	movw	r14, r28
    12a0:	08 94       	sec
    12a2:	e1 1c       	adc	r14, r1
    12a4:	f1 1c       	adc	r15, r1
					xEntryTimeSet = pdTRUE;
    12a6:	cc 24       	eor	r12, r12
    12a8:	c3 94       	inc	r12

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    12aa:	aa 24       	eor	r10, r10
    12ac:	bb 24       	eor	r11, r11
    12ae:	68 94       	set
    12b0:	a2 f8       	bld	r10, 2
    12b2:	ac 0e       	add	r10, r28
    12b4:	bd 1e       	adc	r11, r29
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    12b6:	0f 2e       	mov	r0, r31
    12b8:	f1 e1       	ldi	r31, 0x11	; 17
    12ba:	8f 2e       	mov	r8, r31
    12bc:	99 24       	eor	r9, r9
    12be:	f0 2d       	mov	r31, r0
    12c0:	88 0e       	add	r8, r24
    12c2:	99 1e       	adc	r9, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	f8 94       	cli
    12c8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    12ca:	f8 01       	movw	r30, r16
    12cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    12ce:	88 23       	and	r24, r24
    12d0:	51 f1       	breq	.+84     	; 0x1326 <xQueueGenericReceive+0xbc>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    12d2:	e6 80       	ldd	r14, Z+6	; 0x06
    12d4:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    12d6:	c8 01       	movw	r24, r16
    12d8:	b3 01       	movw	r22, r6
    12da:	0e 94 40 07 	call	0xe80	; 0xe80 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    12de:	55 20       	and	r5, r5
    12e0:	81 f4       	brne	.+32     	; 0x1302 <xQueueGenericReceive+0x98>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    12e2:	f8 01       	movw	r30, r16
    12e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    12e6:	81 50       	subi	r24, 0x01	; 1
    12e8:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    12ea:	80 85       	ldd	r24, Z+8	; 0x08
    12ec:	88 23       	and	r24, r24
    12ee:	b9 f0       	breq	.+46     	; 0x131e <xQueueGenericReceive+0xb4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    12f0:	c8 01       	movw	r24, r16
    12f2:	08 96       	adiw	r24, 0x08	; 8
    12f4:	0e 94 86 12 	call	0x250c	; 0x250c <xTaskRemoveFromEventList>
    12f8:	81 30       	cpi	r24, 0x01	; 1
    12fa:	89 f4       	brne	.+34     	; 0x131e <xQueueGenericReceive+0xb4>
						{
							portYIELD_WITHIN_API();
    12fc:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
    1300:	0e c0       	rjmp	.+28     	; 0x131e <xQueueGenericReceive+0xb4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1302:	f8 01       	movw	r30, r16
    1304:	f7 82       	std	Z+7, r15	; 0x07
    1306:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1308:	81 89       	ldd	r24, Z+17	; 0x11
    130a:	88 23       	and	r24, r24
    130c:	41 f0       	breq	.+16     	; 0x131e <xQueueGenericReceive+0xb4>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    130e:	c8 01       	movw	r24, r16
    1310:	41 96       	adiw	r24, 0x11	; 17
    1312:	0e 94 86 12 	call	0x250c	; 0x250c <xTaskRemoveFromEventList>
    1316:	88 23       	and	r24, r24
    1318:	11 f0       	breq	.+4      	; 0x131e <xQueueGenericReceive+0xb4>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    131a:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1322:	81 e0       	ldi	r24, 0x01	; 1
    1324:	4c c0       	rjmp	.+152    	; 0x13be <xQueueGenericReceive+0x154>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1326:	8c 81       	ldd	r24, Y+4	; 0x04
    1328:	9d 81       	ldd	r25, Y+5	; 0x05
    132a:	00 97       	sbiw	r24, 0x00	; 0
    132c:	21 f4       	brne	.+8      	; 0x1336 <xQueueGenericReceive+0xcc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    132e:	0f 90       	pop	r0
    1330:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1332:	80 e0       	ldi	r24, 0x00	; 0
    1334:	44 c0       	rjmp	.+136    	; 0x13be <xQueueGenericReceive+0x154>
				}
				else if( xEntryTimeSet == pdFALSE )
    1336:	dd 20       	and	r13, r13
    1338:	21 f4       	brne	.+8      	; 0x1342 <xQueueGenericReceive+0xd8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    133a:	c7 01       	movw	r24, r14
    133c:	0e 94 cc 12 	call	0x2598	; 0x2598 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1340:	dc 2c       	mov	r13, r12
				}
			}
		}
		taskEXIT_CRITICAL();
    1342:	0f 90       	pop	r0
    1344:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1346:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    134a:	0f b6       	in	r0, 0x3f	; 63
    134c:	f8 94       	cli
    134e:	0f 92       	push	r0
    1350:	f8 01       	movw	r30, r16
    1352:	85 8d       	ldd	r24, Z+29	; 0x1d
    1354:	8f 3f       	cpi	r24, 0xFF	; 255
    1356:	09 f4       	brne	.+2      	; 0x135a <xQueueGenericReceive+0xf0>
    1358:	15 8e       	std	Z+29, r1	; 0x1d
    135a:	f8 01       	movw	r30, r16
    135c:	86 8d       	ldd	r24, Z+30	; 0x1e
    135e:	8f 3f       	cpi	r24, 0xFF	; 255
    1360:	09 f4       	brne	.+2      	; 0x1364 <xQueueGenericReceive+0xfa>
    1362:	16 8e       	std	Z+30, r1	; 0x1e
    1364:	0f 90       	pop	r0
    1366:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1368:	c7 01       	movw	r24, r14
    136a:	b5 01       	movw	r22, r10
    136c:	0e 94 d7 12 	call	0x25ae	; 0x25ae <xTaskCheckForTimeOut>
    1370:	88 23       	and	r24, r24
    1372:	f9 f4       	brne	.+62     	; 0x13b2 <xQueueGenericReceive+0x148>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1374:	0f b6       	in	r0, 0x3f	; 63
    1376:	f8 94       	cli
    1378:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    137a:	f8 01       	movw	r30, r16
    137c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    137e:	0f 90       	pop	r0
    1380:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1382:	88 23       	and	r24, r24
    1384:	81 f4       	brne	.+32     	; 0x13a6 <xQueueGenericReceive+0x13c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1386:	6c 81       	ldd	r22, Y+4	; 0x04
    1388:	7d 81       	ldd	r23, Y+5	; 0x05
    138a:	c4 01       	movw	r24, r8
    138c:	0e 94 69 12 	call	0x24d2	; 0x24d2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1390:	c8 01       	movw	r24, r16
    1392:	0e 94 a2 07 	call	0xf44	; 0xf44 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1396:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
    139a:	88 23       	and	r24, r24
    139c:	09 f0       	breq	.+2      	; 0x13a0 <xQueueGenericReceive+0x136>
    139e:	92 cf       	rjmp	.-220    	; 0x12c4 <xQueueGenericReceive+0x5a>
				{
					portYIELD_WITHIN_API();
    13a0:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
    13a4:	8f cf       	rjmp	.-226    	; 0x12c4 <xQueueGenericReceive+0x5a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13a6:	c8 01       	movw	r24, r16
    13a8:	0e 94 a2 07 	call	0xf44	; 0xf44 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    13ac:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
    13b0:	89 cf       	rjmp	.-238    	; 0x12c4 <xQueueGenericReceive+0x5a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    13b2:	c8 01       	movw	r24, r16
    13b4:	0e 94 a2 07 	call	0xf44	; 0xf44 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    13b8:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    13bc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    13be:	0f 90       	pop	r0
    13c0:	0f 90       	pop	r0
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	0f 90       	pop	r0
    13c8:	cf 91       	pop	r28
    13ca:	df 91       	pop	r29
    13cc:	1f 91       	pop	r17
    13ce:	0f 91       	pop	r16
    13d0:	ff 90       	pop	r15
    13d2:	ef 90       	pop	r14
    13d4:	df 90       	pop	r13
    13d6:	cf 90       	pop	r12
    13d8:	bf 90       	pop	r11
    13da:	af 90       	pop	r10
    13dc:	9f 90       	pop	r9
    13de:	8f 90       	pop	r8
    13e0:	7f 90       	pop	r7
    13e2:	6f 90       	pop	r6
    13e4:	5f 90       	pop	r5
    13e6:	08 95       	ret

000013e8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    13e8:	0f 93       	push	r16
    13ea:	1f 93       	push	r17
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
    13f0:	ec 01       	movw	r28, r24
    13f2:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    13f4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    13f6:	88 23       	and	r24, r24
    13f8:	d1 f0       	breq	.+52     	; 0x142e <xQueueReceiveFromISR+0x46>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    13fa:	ce 01       	movw	r24, r28
    13fc:	0e 94 40 07 	call	0xe80	; 0xe80 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1400:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1402:	81 50       	subi	r24, 0x01	; 1
    1404:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1406:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1408:	8f 3f       	cpi	r24, 0xFF	; 255
    140a:	69 f4       	brne	.+26     	; 0x1426 <xQueueReceiveFromISR+0x3e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    140c:	88 85       	ldd	r24, Y+8	; 0x08
    140e:	88 23       	and	r24, r24
    1410:	81 f0       	breq	.+32     	; 0x1432 <xQueueReceiveFromISR+0x4a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1412:	ce 01       	movw	r24, r28
    1414:	08 96       	adiw	r24, 0x08	; 8
    1416:	0e 94 86 12 	call	0x250c	; 0x250c <xTaskRemoveFromEventList>
    141a:	88 23       	and	r24, r24
    141c:	61 f0       	breq	.+24     	; 0x1436 <xQueueReceiveFromISR+0x4e>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    141e:	81 e0       	ldi	r24, 0x01	; 1
    1420:	f8 01       	movw	r30, r16
    1422:	80 83       	st	Z, r24
    1424:	09 c0       	rjmp	.+18     	; 0x1438 <xQueueReceiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1426:	8f 5f       	subi	r24, 0xFF	; 255
    1428:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    142a:	81 e0       	ldi	r24, 0x01	; 1
    142c:	05 c0       	rjmp	.+10     	; 0x1438 <xQueueReceiveFromISR+0x50>
		}
		else
		{
			xReturn = pdFAIL;
    142e:	80 e0       	ldi	r24, 0x00	; 0
    1430:	03 c0       	rjmp	.+6      	; 0x1438 <xQueueReceiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	01 c0       	rjmp	.+2      	; 0x1438 <xQueueReceiveFromISR+0x50>
    1436:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1438:	df 91       	pop	r29
    143a:	cf 91       	pop	r28
    143c:	1f 91       	pop	r17
    143e:	0f 91       	pop	r16
    1440:	08 95       	ret

00001442 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1442:	0f b6       	in	r0, 0x3f	; 63
    1444:	f8 94       	cli
    1446:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1448:	fc 01       	movw	r30, r24
    144a:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    144c:	0f 90       	pop	r0
    144e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1450:	08 95       	ret

00001452 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1452:	fc 01       	movw	r30, r24
    1454:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1456:	08 95       	ret

00001458 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    145e:	88 81       	ld	r24, Y
    1460:	99 81       	ldd	r25, Y+1	; 0x01
    1462:	0e 94 03 04 	call	0x806	; 0x806 <vPortFree>
	vPortFree( pxQueue );
    1466:	ce 01       	movw	r24, r28
    1468:	0e 94 03 04 	call	0x806	; 0x806 <vPortFree>
}
    146c:	df 91       	pop	r29
    146e:	cf 91       	pop	r28
    1470:	08 95       	ret

00001472 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1472:	fc 01       	movw	r30, r24
    1474:	92 8d       	ldd	r25, Z+26	; 0x1a
    1476:	81 e0       	ldi	r24, 0x01	; 1
    1478:	91 11       	cpse	r25, r1
    147a:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    147c:	08 95       	ret

0000147e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    147e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1480:	22 8d       	ldd	r18, Z+26	; 0x1a
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	93 8d       	ldd	r25, Z+27	; 0x1b
    1486:	29 13       	cpse	r18, r25
    1488:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    148a:	08 95       	ret

0000148c <Task4>:
}
void Task4(void * pvParameters)
{
	while(1)
	{
	int p=KeyPad_u8GetPressedKey();
    148c:	0e 94 98 04 	call	0x930	; 0x930 <KeyPad_u8GetPressedKey>
	if (p!=255)
    1490:	8f 3f       	cpi	r24, 0xFF	; 255
    1492:	e1 f3       	breq	.-8      	; 0x148c <Task4>
	{
		xSemaphoreGive(handle_sem1);
    1494:	80 91 83 07 	lds	r24, 0x0783
    1498:	90 91 84 07 	lds	r25, 0x0784
    149c:	60 e0       	ldi	r22, 0x00	; 0
    149e:	70 e0       	ldi	r23, 0x00	; 0
    14a0:	40 e0       	ldi	r20, 0x00	; 0
    14a2:	50 e0       	ldi	r21, 0x00	; 0
    14a4:	20 e0       	ldi	r18, 0x00	; 0
    14a6:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xQueueGenericSend>
    14aa:	f0 cf       	rjmp	.-32     	; 0x148c <Task4>

000014ac <Task3>:
		}
		vTaskDelete(handle_task2);
}
void Task3(void * pvParameters)
{
xSemaphoreTake(handle_sem1,portMAX_DELAY);
    14ac:	80 91 83 07 	lds	r24, 0x0783
    14b0:	90 91 84 07 	lds	r25, 0x0784
    14b4:	60 e0       	ldi	r22, 0x00	; 0
    14b6:	70 e0       	ldi	r23, 0x00	; 0
    14b8:	4f ef       	ldi	r20, 0xFF	; 255
    14ba:	5f ef       	ldi	r21, 0xFF	; 255
    14bc:	20 e0       	ldi	r18, 0x00	; 0
    14be:	0e 94 35 09 	call	0x126a	; 0x126a <xQueueGenericReceive>
	while(1)
	{
		xSemaphoreTake(handle_sem1,portMAX_DELAY);
    14c2:	80 91 83 07 	lds	r24, 0x0783
    14c6:	90 91 84 07 	lds	r25, 0x0784
    14ca:	60 e0       	ldi	r22, 0x00	; 0
    14cc:	70 e0       	ldi	r23, 0x00	; 0
    14ce:	4f ef       	ldi	r20, 0xFF	; 255
    14d0:	5f ef       	ldi	r21, 0xFF	; 255
    14d2:	20 e0       	ldi	r18, 0x00	; 0
    14d4:	0e 94 35 09 	call	0x126a	; 0x126a <xQueueGenericReceive>
		vTaskDelete(handle_task2);
    14d8:	80 91 87 07 	lds	r24, 0x0787
    14dc:	90 91 88 07 	lds	r25, 0x0788
    14e0:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskDelete>
		vTaskDelete(handle_task3);
    14e4:	80 91 85 07 	lds	r24, 0x0785
    14e8:	90 91 86 07 	lds	r25, 0x0786
    14ec:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskDelete>
		vTaskDelete(handle_task4);
    14f0:	80 91 4d 07 	lds	r24, 0x074D
    14f4:	90 91 4e 07 	lds	r25, 0x074E
    14f8:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <vTaskDelete>
    14fc:	e2 cf       	rjmp	.-60     	; 0x14c2 <Task3+0x16>

000014fe <LED_Pattern>:
		_delay_ms(500);	
		x = 0;
	}
}
void LED_Pattern(void * pvParameters)
{
    14fe:	0f 93       	push	r16
    1500:	1f 93       	push	r17
    1502:	df 93       	push	r29
    1504:	cf 93       	push	r28
    1506:	00 d0       	rcall	.+0      	; 0x1508 <LED_Pattern+0xa>
    1508:	cd b7       	in	r28, 0x3d	; 61
    150a:	de b7       	in	r29, 0x3e	; 62
	int yled = xTaskGetTickCount();
    150c:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <xTaskGetTickCount>
    1510:	9a 83       	std	Y+2, r25	; 0x02
    1512:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		vTaskDelayUntil(&yled,25);
    1514:	8e 01       	movw	r16, r28
    1516:	0f 5f       	subi	r16, 0xFF	; 255
    1518:	1f 4f       	sbci	r17, 0xFF	; 255
    151a:	c8 01       	movw	r24, r16
    151c:	69 e1       	ldi	r22, 0x19	; 25
    151e:	70 e0       	ldi	r23, 0x00	; 0
    1520:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
    1524:	fa cf       	rjmp	.-12     	; 0x151a <LED_Pattern+0x1c>

00001526 <Task2>:
			lcd_clrScreen();
		}
	
}
void Task2(void * pvParameters)
{
    1526:	6f 92       	push	r6
    1528:	7f 92       	push	r7
    152a:	8f 92       	push	r8
    152c:	9f 92       	push	r9
    152e:	af 92       	push	r10
    1530:	bf 92       	push	r11
    1532:	cf 92       	push	r12
    1534:	df 92       	push	r13
    1536:	ef 92       	push	r14
    1538:	ff 92       	push	r15
    153a:	0f 93       	push	r16
    153c:	1f 93       	push	r17
    153e:	df 93       	push	r29
    1540:	cf 93       	push	r28
    1542:	cd b7       	in	r28, 0x3d	; 61
    1544:	de b7       	in	r29, 0x3e	; 62
    1546:	2a 97       	sbiw	r28, 0x0a	; 10
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	f8 94       	cli
    154c:	de bf       	out	0x3e, r29	; 62
    154e:	0f be       	out	0x3f, r0	; 63
    1550:	cd bf       	out	0x3d, r28	; 61
	char v[]="Welcome";
    1552:	de 01       	movw	r26, r28
    1554:	11 96       	adiw	r26, 0x01	; 1
    1556:	ea e7       	ldi	r30, 0x7A	; 122
    1558:	f0 e0       	ldi	r31, 0x00	; 0
    155a:	88 e0       	ldi	r24, 0x08	; 8
    155c:	01 90       	ld	r0, Z+
    155e:	0d 92       	st	X+, r0
    1560:	81 50       	subi	r24, 0x01	; 1
    1562:	e1 f7       	brne	.-8      	; 0x155c <Task2+0x36>
	int i=0;
	int y1 = xTaskGetTickCount();
    1564:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <xTaskGetTickCount>
    1568:	9a 87       	std	Y+10, r25	; 0x0a
    156a:	89 87       	std	Y+9, r24	; 0x09
	
}
void Task2(void * pvParameters)
{
	char v[]="Welcome";
	int i=0;
    156c:	88 24       	eor	r8, r8
    156e:	99 24       	eor	r9, r9
	int y1 = xTaskGetTickCount();
		while(i<3)
		{
		vTaskDelayUntil(&y1,20);
    1570:	0f 2e       	mov	r0, r31
    1572:	f9 e0       	ldi	r31, 0x09	; 9
    1574:	6f 2e       	mov	r6, r31
    1576:	77 24       	eor	r7, r7
    1578:	f0 2d       	mov	r31, r0
    157a:	6c 0e       	add	r6, r28
    157c:	7d 1e       	adc	r7, r29
		for (int i1=0;i1<10;i1++)
    157e:	ee 24       	eor	r14, r14
    1580:	ff 24       	eor	r15, r15
		{
			lcd_disp_string_xy(v,0,i1);
    1582:	5e 01       	movw	r10, r28
    1584:	08 94       	sec
    1586:	a1 1c       	adc	r10, r1
    1588:	b1 1c       	adc	r11, r1
	char v[]="Welcome";
	int i=0;
	int y1 = xTaskGetTickCount();
		while(i<3)
		{
		vTaskDelayUntil(&y1,20);
    158a:	c3 01       	movw	r24, r6
    158c:	c6 2c       	mov	r12, r6
    158e:	d9 2e       	mov	r13, r25
    1590:	64 e1       	ldi	r22, 0x14	; 20
    1592:	70 e0       	ldi	r23, 0x00	; 0
    1594:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
		for (int i1=0;i1<10;i1++)
    1598:	87 01       	movw	r16, r14
		{
			lcd_disp_string_xy(v,0,i1);
    159a:	c5 01       	movw	r24, r10
    159c:	b7 01       	movw	r22, r14
    159e:	a8 01       	movw	r20, r16
    15a0:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_disp_string_xy>
    15a4:	8f e4       	ldi	r24, 0x4F	; 79
    15a6:	93 ec       	ldi	r25, 0xC3	; 195
    15a8:	01 97       	sbiw	r24, 0x01	; 1
    15aa:	f1 f7       	brne	.-4      	; 0x15a8 <Task2+0x82>
    15ac:	00 c0       	rjmp	.+0      	; 0x15ae <Task2+0x88>
    15ae:	00 00       	nop
			_delay_ms(25);
			lcd_clrScreen();
    15b0:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
	int i=0;
	int y1 = xTaskGetTickCount();
		while(i<3)
		{
		vTaskDelayUntil(&y1,20);
		for (int i1=0;i1<10;i1++)
    15b4:	0f 5f       	subi	r16, 0xFF	; 255
    15b6:	1f 4f       	sbci	r17, 0xFF	; 255
    15b8:	0a 30       	cpi	r16, 0x0A	; 10
    15ba:	11 05       	cpc	r17, r1
    15bc:	71 f7       	brne	.-36     	; 0x159a <Task2+0x74>
    15be:	0b e0       	ldi	r16, 0x0B	; 11
    15c0:	10 e0       	ldi	r17, 0x00	; 0
			_delay_ms(25);
			lcd_clrScreen();
		}
		for (int i2=11;i2>=0;i2--)
		{
			lcd_disp_string_xy(v,0,i2);
    15c2:	c5 01       	movw	r24, r10
    15c4:	b7 01       	movw	r22, r14
    15c6:	a8 01       	movw	r20, r16
    15c8:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_disp_string_xy>
    15cc:	af e4       	ldi	r26, 0x4F	; 79
    15ce:	b3 ec       	ldi	r27, 0xC3	; 195
    15d0:	11 97       	sbiw	r26, 0x01	; 1
    15d2:	f1 f7       	brne	.-4      	; 0x15d0 <Task2+0xaa>
    15d4:	00 c0       	rjmp	.+0      	; 0x15d6 <Task2+0xb0>
    15d6:	00 00       	nop
			_delay_ms(25);
			lcd_clrScreen();
    15d8:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
		{
			lcd_disp_string_xy(v,0,i1);
			_delay_ms(25);
			lcd_clrScreen();
		}
		for (int i2=11;i2>=0;i2--)
    15dc:	01 50       	subi	r16, 0x01	; 1
    15de:	10 40       	sbci	r17, 0x00	; 0
    15e0:	bf ef       	ldi	r27, 0xFF	; 255
    15e2:	0f 3f       	cpi	r16, 0xFF	; 255
    15e4:	1b 07       	cpc	r17, r27
    15e6:	69 f7       	brne	.-38     	; 0x15c2 <Task2+0x9c>
		{
			lcd_disp_string_xy(v,0,i2);
			_delay_ms(25);
			lcd_clrScreen();
		}
		i++;
    15e8:	08 94       	sec
    15ea:	81 1c       	adc	r8, r1
    15ec:	91 1c       	adc	r9, r1
void Task2(void * pvParameters)
{
	char v[]="Welcome";
	int i=0;
	int y1 = xTaskGetTickCount();
		while(i<3)
    15ee:	83 e0       	ldi	r24, 0x03	; 3
    15f0:	88 16       	cp	r8, r24
    15f2:	91 04       	cpc	r9, r1
    15f4:	51 f6       	brne	.-108    	; 0x158a <Task2+0x64>
		}
		i=0;
		while(1)
		{
		vTaskDelayUntil(&y1,20);
		lcd_dispString("Press any key");
    15f6:	00 e6       	ldi	r16, 0x60	; 96
    15f8:	10 e0       	ldi	r17, 0x00	; 0
		lcd_disp_string_xy("to continue",1,0);
    15fa:	0f 2e       	mov	r0, r31
    15fc:	fe e6       	ldi	r31, 0x6E	; 110
    15fe:	ef 2e       	mov	r14, r31
    1600:	f0 e0       	ldi	r31, 0x00	; 0
    1602:	ff 2e       	mov	r15, r31
    1604:	f0 2d       	mov	r31, r0
		i++;
		}
		i=0;
		while(1)
		{
		vTaskDelayUntil(&y1,20);
    1606:	8c 2d       	mov	r24, r12
    1608:	9d 2d       	mov	r25, r13
    160a:	64 e1       	ldi	r22, 0x14	; 20
    160c:	70 e0       	ldi	r23, 0x00	; 0
    160e:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
		lcd_dispString("Press any key");
    1612:	c8 01       	movw	r24, r16
    1614:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_dispString>
		lcd_disp_string_xy("to continue",1,0);
    1618:	c7 01       	movw	r24, r14
    161a:	61 e0       	ldi	r22, 0x01	; 1
    161c:	70 e0       	ldi	r23, 0x00	; 0
    161e:	40 e0       	ldi	r20, 0x00	; 0
    1620:	50 e0       	ldi	r21, 0x00	; 0
    1622:	0e 94 5d 05 	call	0xaba	; 0xaba <lcd_disp_string_xy>
    1626:	8f ef       	ldi	r24, 0xFF	; 255
    1628:	94 e3       	ldi	r25, 0x34	; 52
    162a:	ac e0       	ldi	r26, 0x0C	; 12
    162c:	81 50       	subi	r24, 0x01	; 1
    162e:	90 40       	sbci	r25, 0x00	; 0
    1630:	a0 40       	sbci	r26, 0x00	; 0
    1632:	e1 f7       	brne	.-8      	; 0x162c <Task2+0x106>
    1634:	00 c0       	rjmp	.+0      	; 0x1636 <Task2+0x110>
    1636:	00 00       	nop
		_delay_ms(500);
		lcd_clrScreen();
    1638:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
    163c:	8f e7       	ldi	r24, 0x7F	; 127
    163e:	9a e1       	ldi	r25, 0x1A	; 26
    1640:	a6 e0       	ldi	r26, 0x06	; 6
    1642:	81 50       	subi	r24, 0x01	; 1
    1644:	90 40       	sbci	r25, 0x00	; 0
    1646:	a0 40       	sbci	r26, 0x00	; 0
    1648:	e1 f7       	brne	.-8      	; 0x1642 <Task2+0x11c>
    164a:	00 c0       	rjmp	.+0      	; 0x164c <Task2+0x126>
    164c:	00 00       	nop
    164e:	db cf       	rjmp	.-74     	; 0x1606 <Task2+0xe0>

00001650 <Task5>:
		

	}
}
void Task5(void * pvParameters)
{
    1650:	2f 92       	push	r2
    1652:	3f 92       	push	r3
    1654:	4f 92       	push	r4
    1656:	5f 92       	push	r5
    1658:	6f 92       	push	r6
    165a:	7f 92       	push	r7
    165c:	8f 92       	push	r8
    165e:	9f 92       	push	r9
    1660:	af 92       	push	r10
    1662:	bf 92       	push	r11
    1664:	cf 92       	push	r12
    1666:	df 92       	push	r13
    1668:	ef 92       	push	r14
    166a:	ff 92       	push	r15
    166c:	0f 93       	push	r16
    166e:	1f 93       	push	r17
    1670:	df 93       	push	r29
    1672:	cf 93       	push	r28
    1674:	00 d0       	rcall	.+0      	; 0x1676 <Task5+0x26>
    1676:	cd b7       	in	r28, 0x3d	; 61
    1678:	de b7       	in	r29, 0x3e	; 62
	int counter =0;
	int y5=xTaskGetTickCount();
    167a:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <xTaskGetTickCount>
    167e:	9a 83       	std	Y+2, r25	; 0x02
    1680:	89 83       	std	Y+1, r24	; 0x01

	}
}
void Task5(void * pvParameters)
{
	int counter =0;
    1682:	88 24       	eor	r8, r8
    1684:	99 24       	eor	r9, r9
	int y5=xTaskGetTickCount();
	while (1)
	{
		vTaskDelayUntil(&y5,100);
    1686:	3e 01       	movw	r6, r28
    1688:	08 94       	sec
    168a:	61 1c       	adc	r6, r1
    168c:	71 1c       	adc	r7, r1
		/*check if key pressed and start timer 
		if key pressed the timer will reset
		and if time == 10 s  it  will make some function
		*/
		counter++;
		if ((pressed_number!=255)|(KeyPad_u8GetPressedKey()!=255))
    168e:	11 e0       	ldi	r17, 0x01	; 1
			counter=0;
		}
		if (counter>=100)
		{//blinking led
			lcd_clrScreen();
			lcd_dispString("NO Pressed");
    1690:	0f 2e       	mov	r0, r31
    1692:	f2 e8       	ldi	r31, 0x82	; 130
    1694:	2f 2e       	mov	r2, r31
    1696:	f0 e0       	ldi	r31, 0x00	; 0
    1698:	3f 2e       	mov	r3, r31
    169a:	f0 2d       	mov	r31, r0
			DIO_voidSetPin(LED,1);
			PORTC = 0x01;
			xTaskCreate( LED_Pattern, "Task_Name", 100, NULL, 1, &handle_LED);
    169c:	0f 2e       	mov	r0, r31
    169e:	fb e4       	ldi	r31, 0x4B	; 75
    16a0:	4f 2e       	mov	r4, r31
    16a2:	f7 e0       	ldi	r31, 0x07	; 7
    16a4:	5f 2e       	mov	r5, r31
    16a6:	f0 2d       	mov	r31, r0
    16a8:	02 c0       	rjmp	.+4      	; 0x16ae <Task5+0x5e>
		and if time == 10 s  it  will make some function
		*/
		counter++;
		if ((pressed_number!=255)|(KeyPad_u8GetPressedKey()!=255))
		{
			counter=0;
    16aa:	88 24       	eor	r8, r8
    16ac:	99 24       	eor	r9, r9
{
	int counter =0;
	int y5=xTaskGetTickCount();
	while (1)
	{
		vTaskDelayUntil(&y5,100);
    16ae:	c3 01       	movw	r24, r6
    16b0:	64 e6       	ldi	r22, 0x64	; 100
    16b2:	70 e0       	ldi	r23, 0x00	; 0
    16b4:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
		/*check if key pressed and start timer 
		if key pressed the timer will reset
		and if time == 10 s  it  will make some function
		*/
		counter++;
    16b8:	08 94       	sec
    16ba:	81 1c       	adc	r8, r1
    16bc:	91 1c       	adc	r9, r1
		if ((pressed_number!=255)|(KeyPad_u8GetPressedKey()!=255))
    16be:	01 2f       	mov	r16, r17
    16c0:	80 91 e2 06 	lds	r24, 0x06E2
    16c4:	8f 3f       	cpi	r24, 0xFF	; 255
    16c6:	09 f4       	brne	.+2      	; 0x16ca <Task5+0x7a>
    16c8:	00 e0       	ldi	r16, 0x00	; 0
    16ca:	0e 94 98 04 	call	0x930	; 0x930 <KeyPad_u8GetPressedKey>
    16ce:	00 23       	and	r16, r16
    16d0:	61 f7       	brne	.-40     	; 0x16aa <Task5+0x5a>
    16d2:	91 2f       	mov	r25, r17
    16d4:	8f 3f       	cpi	r24, 0xFF	; 255
    16d6:	09 f4       	brne	.+2      	; 0x16da <Task5+0x8a>
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	99 23       	and	r25, r25
    16dc:	31 f7       	brne	.-52     	; 0x16aa <Task5+0x5a>
		{
			counter=0;
		}
		if (counter>=100)
    16de:	84 e6       	ldi	r24, 0x64	; 100
    16e0:	88 16       	cp	r8, r24
    16e2:	91 04       	cpc	r9, r1
    16e4:	24 f3       	brlt	.-56     	; 0x16ae <Task5+0x5e>
		{//blinking led
			lcd_clrScreen();
    16e6:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
			lcd_dispString("NO Pressed");
    16ea:	c1 01       	movw	r24, r2
    16ec:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_dispString>
			DIO_voidSetPin(LED,1);
    16f0:	88 e1       	ldi	r24, 0x18	; 24
    16f2:	61 2f       	mov	r22, r17
    16f4:	0e 94 bc 02 	call	0x578	; 0x578 <DIO_voidSetPin>
			PORTC = 0x01;
    16f8:	15 bb       	out	0x15, r17	; 21
			xTaskCreate( LED_Pattern, "Task_Name", 100, NULL, 1, &handle_LED);
    16fa:	8f e7       	ldi	r24, 0x7F	; 127
    16fc:	9a e0       	ldi	r25, 0x0A	; 10
    16fe:	6d e8       	ldi	r22, 0x8D	; 141
    1700:	70 e0       	ldi	r23, 0x00	; 0
    1702:	44 e6       	ldi	r20, 0x64	; 100
    1704:	50 e0       	ldi	r21, 0x00	; 0
    1706:	20 e0       	ldi	r18, 0x00	; 0
    1708:	30 e0       	ldi	r19, 0x00	; 0
    170a:	01 2f       	mov	r16, r17
    170c:	72 01       	movw	r14, r4
    170e:	cc 24       	eor	r12, r12
    1710:	dd 24       	eor	r13, r13
    1712:	aa 24       	eor	r10, r10
    1714:	bb 24       	eor	r11, r11
    1716:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskGenericCreate>
    171a:	c9 cf       	rjmp	.-110    	; 0x16ae <Task5+0x5e>

0000171c <main>:
char result[16];
char num2[16];


int main( void )
{
    171c:	af 92       	push	r10
    171e:	bf 92       	push	r11
    1720:	cf 92       	push	r12
    1722:	df 92       	push	r13
    1724:	ef 92       	push	r14
    1726:	ff 92       	push	r15
    1728:	0f 93       	push	r16
	lcd_init();
    172a:	0e 94 06 05 	call	0xa0c	; 0xa0c <lcd_init>
	DDRA = 0xFF;
    172e:	8f ef       	ldi	r24, 0xFF	; 255
    1730:	8a bb       	out	0x1a, r24	; 26
	DDRD = 0x0F;
    1732:	9f e0       	ldi	r25, 0x0F	; 15
    1734:	91 bb       	out	0x11, r25	; 17
	DDRC = 0x01;
    1736:	91 e0       	ldi	r25, 0x01	; 1
    1738:	94 bb       	out	0x14, r25	; 20
	PORTD = 0xFF;
    173a:	82 bb       	out	0x12, r24	; 18
	xTaskCreate( Task1, "Task1_Name", 100, NULL, 1, &handle_task1);
    173c:	8c ee       	ldi	r24, 0xEC	; 236
    173e:	9d e0       	ldi	r25, 0x0D	; 13
    1740:	67 e9       	ldi	r22, 0x97	; 151
    1742:	70 e0       	ldi	r23, 0x00	; 0
    1744:	44 e6       	ldi	r20, 0x64	; 100
    1746:	50 e0       	ldi	r21, 0x00	; 0
    1748:	20 e0       	ldi	r18, 0x00	; 0
    174a:	30 e0       	ldi	r19, 0x00	; 0
    174c:	01 e0       	ldi	r16, 0x01	; 1
    174e:	0f 2e       	mov	r0, r31
    1750:	f1 e7       	ldi	r31, 0x71	; 113
    1752:	ef 2e       	mov	r14, r31
    1754:	f7 e0       	ldi	r31, 0x07	; 7
    1756:	ff 2e       	mov	r15, r31
    1758:	f0 2d       	mov	r31, r0
    175a:	cc 24       	eor	r12, r12
    175c:	dd 24       	eor	r13, r13
    175e:	aa 24       	eor	r10, r10
    1760:	bb 24       	eor	r11, r11
    1762:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskGenericCreate>
	xTaskCreate( Task2, "Task2_Name", 100, NULL, 1, &handle_task2);
    1766:	83 e9       	ldi	r24, 0x93	; 147
    1768:	9a e0       	ldi	r25, 0x0A	; 10
    176a:	62 ea       	ldi	r22, 0xA2	; 162
    176c:	70 e0       	ldi	r23, 0x00	; 0
    176e:	44 e6       	ldi	r20, 0x64	; 100
    1770:	50 e0       	ldi	r21, 0x00	; 0
    1772:	20 e0       	ldi	r18, 0x00	; 0
    1774:	30 e0       	ldi	r19, 0x00	; 0
    1776:	0f 2e       	mov	r0, r31
    1778:	f7 e8       	ldi	r31, 0x87	; 135
    177a:	ef 2e       	mov	r14, r31
    177c:	f7 e0       	ldi	r31, 0x07	; 7
    177e:	ff 2e       	mov	r15, r31
    1780:	f0 2d       	mov	r31, r0
    1782:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskGenericCreate>
	xTaskCreate( Task3, "Task3_Name", 100, NULL, 1, &handle_task3);
    1786:	86 e5       	ldi	r24, 0x56	; 86
    1788:	9a e0       	ldi	r25, 0x0A	; 10
    178a:	6d ea       	ldi	r22, 0xAD	; 173
    178c:	70 e0       	ldi	r23, 0x00	; 0
    178e:	44 e6       	ldi	r20, 0x64	; 100
    1790:	50 e0       	ldi	r21, 0x00	; 0
    1792:	20 e0       	ldi	r18, 0x00	; 0
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	0f 2e       	mov	r0, r31
    1798:	f5 e8       	ldi	r31, 0x85	; 133
    179a:	ef 2e       	mov	r14, r31
    179c:	f7 e0       	ldi	r31, 0x07	; 7
    179e:	ff 2e       	mov	r15, r31
    17a0:	f0 2d       	mov	r31, r0
    17a2:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskGenericCreate>
	xTaskCreate( Task4, "Task4_Name", 100, NULL, 1, &handle_task4);
    17a6:	86 e4       	ldi	r24, 0x46	; 70
    17a8:	9a e0       	ldi	r25, 0x0A	; 10
    17aa:	68 eb       	ldi	r22, 0xB8	; 184
    17ac:	70 e0       	ldi	r23, 0x00	; 0
    17ae:	44 e6       	ldi	r20, 0x64	; 100
    17b0:	50 e0       	ldi	r21, 0x00	; 0
    17b2:	20 e0       	ldi	r18, 0x00	; 0
    17b4:	30 e0       	ldi	r19, 0x00	; 0
    17b6:	0f 2e       	mov	r0, r31
    17b8:	fd e4       	ldi	r31, 0x4D	; 77
    17ba:	ef 2e       	mov	r14, r31
    17bc:	f7 e0       	ldi	r31, 0x07	; 7
    17be:	ff 2e       	mov	r15, r31
    17c0:	f0 2d       	mov	r31, r0
    17c2:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskGenericCreate>
	xTaskCreate( Task5, "Task5_Name", 100, NULL, 1, &handle_task5);
    17c6:	88 e2       	ldi	r24, 0x28	; 40
    17c8:	9b e0       	ldi	r25, 0x0B	; 11
    17ca:	63 ec       	ldi	r22, 0xC3	; 195
    17cc:	70 e0       	ldi	r23, 0x00	; 0
    17ce:	44 e6       	ldi	r20, 0x64	; 100
    17d0:	50 e0       	ldi	r21, 0x00	; 0
    17d2:	20 e0       	ldi	r18, 0x00	; 0
    17d4:	30 e0       	ldi	r19, 0x00	; 0
    17d6:	0f 2e       	mov	r0, r31
    17d8:	ff e5       	ldi	r31, 0x5F	; 95
    17da:	ef 2e       	mov	r14, r31
    17dc:	f7 e0       	ldi	r31, 0x07	; 7
    17de:	ff 2e       	mov	r15, r31
    17e0:	f0 2d       	mov	r31, r0
    17e2:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskGenericCreate>
	vSemaphoreCreateBinary(handle_sem1);
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	60 e0       	ldi	r22, 0x00	; 0
    17ea:	0e 94 ee 07 	call	0xfdc	; 0xfdc <xQueueCreate>
    17ee:	90 93 84 07 	sts	0x0784, r25
    17f2:	80 93 83 07 	sts	0x0783, r24
    17f6:	00 97       	sbiw	r24, 0x00	; 0
    17f8:	39 f0       	breq	.+14     	; 0x1808 <main+0xec>
    17fa:	60 e0       	ldi	r22, 0x00	; 0
    17fc:	70 e0       	ldi	r23, 0x00	; 0
    17fe:	40 e0       	ldi	r20, 0x00	; 0
    1800:	50 e0       	ldi	r21, 0x00	; 0
    1802:	20 e0       	ldi	r18, 0x00	; 0
    1804:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xQueueGenericSend>
	vTaskStartScheduler();	
    1808:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vTaskStartScheduler>
	return 0;
}
    180c:	80 e0       	ldi	r24, 0x00	; 0
    180e:	90 e0       	ldi	r25, 0x00	; 0
    1810:	0f 91       	pop	r16
    1812:	ff 90       	pop	r15
    1814:	ef 90       	pop	r14
    1816:	df 90       	pop	r13
    1818:	cf 90       	pop	r12
    181a:	bf 90       	pop	r11
    181c:	af 90       	pop	r10
    181e:	08 95       	ret

00001820 <vApplicationIdleHook>:
void vApplicationIdleHook( void ){
	if(x++ == 1000){
    1820:	80 91 de 06 	lds	r24, 0x06DE
    1824:	90 91 df 06 	lds	r25, 0x06DF
    1828:	9c 01       	movw	r18, r24
    182a:	2f 5f       	subi	r18, 0xFF	; 255
    182c:	3f 4f       	sbci	r19, 0xFF	; 255
    182e:	30 93 df 06 	sts	0x06DF, r19
    1832:	20 93 de 06 	sts	0x06DE, r18
    1836:	23 e0       	ldi	r18, 0x03	; 3
    1838:	88 3e       	cpi	r24, 0xE8	; 232
    183a:	92 07       	cpc	r25, r18
    183c:	81 f4       	brne	.+32     	; 0x185e <vApplicationIdleHook+0x3e>
		PORTA ^= 0xFF;
    183e:	8b b3       	in	r24, 0x1b	; 27
    1840:	80 95       	com	r24
    1842:	8b bb       	out	0x1b, r24	; 27
    1844:	8f ef       	ldi	r24, 0xFF	; 255
    1846:	94 e3       	ldi	r25, 0x34	; 52
    1848:	ac e0       	ldi	r26, 0x0C	; 12
    184a:	81 50       	subi	r24, 0x01	; 1
    184c:	90 40       	sbci	r25, 0x00	; 0
    184e:	a0 40       	sbci	r26, 0x00	; 0
    1850:	e1 f7       	brne	.-8      	; 0x184a <vApplicationIdleHook+0x2a>
    1852:	00 c0       	rjmp	.+0      	; 0x1854 <vApplicationIdleHook+0x34>
    1854:	00 00       	nop
		_delay_ms(500);	
		x = 0;
    1856:	10 92 df 06 	sts	0x06DF, r1
    185a:	10 92 de 06 	sts	0x06DE, r1
    185e:	08 95       	ret

00001860 <LCD_Display_KP>:
}
void LCD_Display_KP(void)
{
	
	
		if (pressed_number!=old_value)
    1860:	80 91 e2 06 	lds	r24, 0x06E2
    1864:	90 91 ce 00 	lds	r25, 0x00CE
    1868:	89 17       	cp	r24, r25
    186a:	11 f0       	breq	.+4      	; 0x1870 <LCD_Display_KP+0x10>
		{
			old_value=pressed_number;
    186c:	80 93 ce 00 	sts	0x00CE, r24
			if(pressed_number != 255)
			{
			
			}				
		}
		if (pressed_number==13)
    1870:	8d 30       	cpi	r24, 0x0D	; 13
    1872:	11 f4       	brne	.+4      	; 0x1878 <LCD_Display_KP+0x18>
		{
			lcd_clrScreen();
    1874:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
    1878:	08 95       	ret

0000187a <tostring>:
			
			}				
	}
}
void tostring(char str[], int num)
{
    187a:	cf 92       	push	r12
    187c:	df 92       	push	r13
    187e:	ef 92       	push	r14
    1880:	ff 92       	push	r15
    1882:	0f 93       	push	r16
    1884:	1f 93       	push	r17
    1886:	cf 93       	push	r28
    1888:	df 93       	push	r29
    188a:	7c 01       	movw	r14, r24
    188c:	fb 01       	movw	r30, r22
    int i, rem, len = 0, n;
 
    n = num;
    while (n != 0)
    188e:	30 97       	sbiw	r30, 0x00	; 0
    1890:	19 f1       	breq	.+70     	; 0x18d8 <tostring+0x5e>
			}				
	}
}
void tostring(char str[], int num)
{
    int i, rem, len = 0, n;
    1892:	20 e0       	ldi	r18, 0x00	; 0
    1894:	30 e0       	ldi	r19, 0x00	; 0
 
    n = num;
    while (n != 0)
    {
        len++;
        n /= 10;
    1896:	ca e0       	ldi	r28, 0x0A	; 10
    1898:	d0 e0       	ldi	r29, 0x00	; 0
    int i, rem, len = 0, n;
 
    n = num;
    while (n != 0)
    {
        len++;
    189a:	2f 5f       	subi	r18, 0xFF	; 255
    189c:	3f 4f       	sbci	r19, 0xFF	; 255
        n /= 10;
    189e:	cb 01       	movw	r24, r22
    18a0:	be 01       	movw	r22, r28
    18a2:	0e 94 65 16 	call	0x2cca	; 0x2cca <__divmodhi4>
void tostring(char str[], int num)
{
    int i, rem, len = 0, n;
 
    n = num;
    while (n != 0)
    18a6:	61 15       	cp	r22, r1
    18a8:	71 05       	cpc	r23, r1
    18aa:	b9 f7       	brne	.-18     	; 0x189a <tostring+0x20>
    {
        len++;
    18ac:	69 01       	movw	r12, r18
        n /= 10;
    }
    for (i = 0; i < len; i++)
    18ae:	12 16       	cp	r1, r18
    18b0:	13 06       	cpc	r1, r19
    18b2:	ac f4       	brge	.+42     	; 0x18de <tostring+0x64>
				
			
			}				
	}
}
void tostring(char str[], int num)
    18b4:	e7 01       	movw	r28, r14
    18b6:	c2 0f       	add	r28, r18
    18b8:	d3 1f       	adc	r29, r19
    18ba:	87 01       	movw	r16, r14
        len++;
        n /= 10;
    }
    for (i = 0; i < len; i++)
    {
        rem = num % 10;
    18bc:	2a e0       	ldi	r18, 0x0A	; 10
    18be:	30 e0       	ldi	r19, 0x00	; 0
    18c0:	cf 01       	movw	r24, r30
    18c2:	b9 01       	movw	r22, r18
    18c4:	0e 94 65 16 	call	0x2cca	; 0x2cca <__divmodhi4>
        num = num / 10;
    18c8:	e6 2f       	mov	r30, r22
    18ca:	f7 2f       	mov	r31, r23
        str[len - (i + 1)] = rem + '0';
    18cc:	80 5d       	subi	r24, 0xD0	; 208
    18ce:	8a 93       	st	-Y, r24
    while (n != 0)
    {
        len++;
        n /= 10;
    }
    for (i = 0; i < len; i++)
    18d0:	c0 17       	cp	r28, r16
    18d2:	d1 07       	cpc	r29, r17
    18d4:	a9 f7       	brne	.-22     	; 0x18c0 <tostring+0x46>
    18d6:	04 c0       	rjmp	.+8      	; 0x18e0 <tostring+0x66>
			}				
	}
}
void tostring(char str[], int num)
{
    int i, rem, len = 0, n;
    18d8:	cc 24       	eor	r12, r12
    18da:	dd 24       	eor	r13, r13
    18dc:	01 c0       	rjmp	.+2      	; 0x18e0 <tostring+0x66>
 
    n = num;
    while (n != 0)
    {
        len++;
    18de:	69 01       	movw	r12, r18
    {
        rem = num % 10;
        num = num / 10;
        str[len - (i + 1)] = rem + '0';
    }
    str[len] = '\0';
    18e0:	ec 0c       	add	r14, r12
    18e2:	fd 1c       	adc	r15, r13
    18e4:	f7 01       	movw	r30, r14
    18e6:	10 82       	st	Z, r1
}
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	1f 91       	pop	r17
    18ee:	0f 91       	pop	r16
    18f0:	ff 90       	pop	r15
    18f2:	ef 90       	pop	r14
    18f4:	df 90       	pop	r13
    18f6:	cf 90       	pop	r12
    18f8:	08 95       	ret

000018fa <toint>:
 
int toint(char str[])
{
    18fa:	2f 92       	push	r2
    18fc:	3f 92       	push	r3
    18fe:	4f 92       	push	r4
    1900:	5f 92       	push	r5
    1902:	6f 92       	push	r6
    1904:	7f 92       	push	r7
    1906:	8f 92       	push	r8
    1908:	9f 92       	push	r9
    190a:	af 92       	push	r10
    190c:	bf 92       	push	r11
    190e:	cf 92       	push	r12
    1910:	df 92       	push	r13
    1912:	ef 92       	push	r14
    1914:	ff 92       	push	r15
    1916:	0f 93       	push	r16
    1918:	1f 93       	push	r17
    191a:	cf 93       	push	r28
    191c:	df 93       	push	r29
    int len = strlen(str);
    191e:	e8 2f       	mov	r30, r24
    1920:	f9 2f       	mov	r31, r25
    1922:	df 01       	movw	r26, r30
    1924:	0d 90       	ld	r0, X+
    1926:	00 20       	and	r0, r0
    1928:	e9 f7       	brne	.-6      	; 0x1924 <toint+0x2a>
    192a:	11 97       	sbiw	r26, 0x01	; 1
    192c:	ae 1b       	sub	r26, r30
    192e:	bf 0b       	sbc	r27, r31
    1930:	1d 01       	movw	r2, r26
    int i, num = 0;
 
    for (i = 0; i < len; i++)
    1932:	1a 16       	cp	r1, r26
    1934:	1b 06       	cpc	r1, r27
    1936:	0c f0       	brlt	.+2      	; 0x193a <toint+0x40>
    1938:	47 c0       	rjmp	.+142    	; 0x19c8 <toint+0xce>
        str[len - (i + 1)] = rem + '0';
    }
    str[len] = '\0';
}
 
int toint(char str[])
    193a:	2c 01       	movw	r4, r24
    193c:	4a 0e       	add	r4, r26
    193e:	5b 1e       	adc	r5, r27
{
    int len = strlen(str);
    int i, num = 0;
    1940:	cc 24       	eor	r12, r12
    1942:	dd 24       	eor	r13, r13
 
    for (i = 0; i < len; i++)
    1944:	c0 e0       	ldi	r28, 0x00	; 0
    1946:	d0 e0       	ldi	r29, 0x00	; 0
    {
        num = num + ((str[len - (i + 1)] - '0') * pow(10, i));
    1948:	f2 01       	movw	r30, r4
    194a:	62 91       	ld	r22, -Z
    194c:	2f 01       	movw	r4, r30
    194e:	70 e0       	ldi	r23, 0x00	; 0
    1950:	60 53       	subi	r22, 0x30	; 48
    1952:	70 40       	sbci	r23, 0x00	; 0
    1954:	88 27       	eor	r24, r24
    1956:	77 fd       	sbrc	r23, 7
    1958:	80 95       	com	r24
    195a:	98 2f       	mov	r25, r24
    195c:	0e 94 a9 13 	call	0x2752	; 0x2752 <__floatsisf>
    1960:	3b 01       	movw	r6, r22
    1962:	4c 01       	movw	r8, r24
    1964:	be 01       	movw	r22, r28
    1966:	88 27       	eor	r24, r24
    1968:	77 fd       	sbrc	r23, 7
    196a:	80 95       	com	r24
    196c:	98 2f       	mov	r25, r24
    196e:	0e 94 a9 13 	call	0x2752	; 0x2752 <__floatsisf>
    1972:	9b 01       	movw	r18, r22
    1974:	ac 01       	movw	r20, r24
    1976:	60 e0       	ldi	r22, 0x00	; 0
    1978:	70 e0       	ldi	r23, 0x00	; 0
    197a:	80 e2       	ldi	r24, 0x20	; 32
    197c:	91 e4       	ldi	r25, 0x41	; 65
    197e:	0e 94 98 14 	call	0x2930	; 0x2930 <pow>
    1982:	06 2f       	mov	r16, r22
    1984:	17 2f       	mov	r17, r23
    1986:	f8 2e       	mov	r15, r24
    1988:	e9 2e       	mov	r14, r25
    198a:	b6 01       	movw	r22, r12
    198c:	88 27       	eor	r24, r24
    198e:	77 fd       	sbrc	r23, 7
    1990:	80 95       	com	r24
    1992:	98 2f       	mov	r25, r24
    1994:	0e 94 a9 13 	call	0x2752	; 0x2752 <__floatsisf>
    1998:	5b 01       	movw	r10, r22
    199a:	6c 01       	movw	r12, r24
    199c:	c4 01       	movw	r24, r8
    199e:	b3 01       	movw	r22, r6
    19a0:	20 2f       	mov	r18, r16
    19a2:	31 2f       	mov	r19, r17
    19a4:	4f 2d       	mov	r20, r15
    19a6:	5e 2d       	mov	r21, r14
    19a8:	0e 94 35 14 	call	0x286a	; 0x286a <__mulsf3>
    19ac:	9b 01       	movw	r18, r22
    19ae:	ac 01       	movw	r20, r24
    19b0:	c6 01       	movw	r24, r12
    19b2:	b5 01       	movw	r22, r10
    19b4:	0e 94 12 13 	call	0x2624	; 0x2624 <__addsf3>
    19b8:	0e 94 76 13 	call	0x26ec	; 0x26ec <__fixsfsi>
    19bc:	6b 01       	movw	r12, r22
int toint(char str[])
{
    int len = strlen(str);
    int i, num = 0;
 
    for (i = 0; i < len; i++)
    19be:	21 96       	adiw	r28, 0x01	; 1
    19c0:	c2 15       	cp	r28, r2
    19c2:	d3 05       	cpc	r29, r3
    19c4:	0c f2       	brlt	.-126    	; 0x1948 <toint+0x4e>
    19c6:	02 c0       	rjmp	.+4      	; 0x19cc <toint+0xd2>
}
 
int toint(char str[])
{
    int len = strlen(str);
    int i, num = 0;
    19c8:	cc 24       	eor	r12, r12
    19ca:	dd 24       	eor	r13, r13
    {
        num = num + ((str[len - (i + 1)] - '0') * pow(10, i));
    }
 
   return num;
    19cc:	8c 2d       	mov	r24, r12
    19ce:	9d 2d       	mov	r25, r13
    19d0:	df 91       	pop	r29
    19d2:	cf 91       	pop	r28
    19d4:	1f 91       	pop	r17
    19d6:	0f 91       	pop	r16
    19d8:	ff 90       	pop	r15
    19da:	ef 90       	pop	r14
    19dc:	df 90       	pop	r13
    19de:	cf 90       	pop	r12
    19e0:	bf 90       	pop	r11
    19e2:	af 90       	pop	r10
    19e4:	9f 90       	pop	r9
    19e6:	8f 90       	pop	r8
    19e8:	7f 90       	pop	r7
    19ea:	6f 90       	pop	r6
    19ec:	5f 90       	pop	r5
    19ee:	4f 90       	pop	r4
    19f0:	3f 90       	pop	r3
    19f2:	2f 90       	pop	r2
    19f4:	08 95       	ret

000019f6 <calculator>:
		xSemaphoreGive(handle_sem1);
	}
	}	
}
void calculator(void)
{
    19f6:	cf 93       	push	r28
    19f8:	df 93       	push	r29
	while (t)
    19fa:	80 91 cf 00 	lds	r24, 0x00CF
    19fe:	88 23       	and	r24, r24
    1a00:	81 f0       	breq	.+32     	; 0x1a22 <calculator+0x2c>
    1a02:	e1 e6       	ldi	r30, 0x61	; 97
    1a04:	f7 e0       	ldi	r31, 0x07	; 7
    1a06:	c3 e7       	ldi	r28, 0x73	; 115
    1a08:	d7 e0       	ldi	r29, 0x07	; 7
    1a0a:	af e4       	ldi	r26, 0x4F	; 79
    1a0c:	b7 e0       	ldi	r27, 0x07	; 7
	{
		xSemaphoreGive(handle_sem1);
	}
	}	
}
void calculator(void)
    1a0e:	cf 01       	movw	r24, r30
    1a10:	40 96       	adiw	r24, 0x10	; 16
{
	while (t)
	{
		for (int k=0;k<16;k++ )
	{
		num[k]=0;
    1a12:	11 92       	st	Z+, r1
		result[k]=0;
    1a14:	19 92       	st	Y+, r1
		num2[k]=0;
    1a16:	1d 92       	st	X+, r1
}
void calculator(void)
{
	while (t)
	{
		for (int k=0;k<16;k++ )
    1a18:	e8 17       	cp	r30, r24
    1a1a:	f9 07       	cpc	r31, r25
    1a1c:	d1 f7       	brne	.-12     	; 0x1a12 <calculator+0x1c>
	{
		num[k]=0;
		result[k]=0;
		num2[k]=0;
	}
	t=0;
    1a1e:	10 92 cf 00 	sts	0x00CF, r1
	}
		if (pressed_number!=old_value)
    1a22:	60 91 e2 06 	lds	r22, 0x06E2
    1a26:	80 91 ce 00 	lds	r24, 0x00CE
    1a2a:	68 17       	cp	r22, r24
    1a2c:	09 f4       	brne	.+2      	; 0x1a30 <calculator+0x3a>
    1a2e:	d1 c0       	rjmp	.+418    	; 0x1bd2 <calculator+0x1dc>
		{
			old_value=pressed_number;
    1a30:	60 93 ce 00 	sts	0x00CE, r22
			if(pressed_number != 255)
    1a34:	6f 3f       	cpi	r22, 0xFF	; 255
    1a36:	09 f4       	brne	.+2      	; 0x1a3a <calculator+0x44>
    1a38:	cc c0       	rjmp	.+408    	; 0x1bd2 <calculator+0x1dc>
			{
				if ((pressed_number=='+')|(pressed_number=='-')|(pressed_number=='*')|(pressed_number=='%'))
    1a3a:	21 e0       	ldi	r18, 0x01	; 1
    1a3c:	30 e0       	ldi	r19, 0x00	; 0
    1a3e:	65 32       	cpi	r22, 0x25	; 37
    1a40:	11 f0       	breq	.+4      	; 0x1a46 <calculator+0x50>
    1a42:	20 e0       	ldi	r18, 0x00	; 0
    1a44:	30 e0       	ldi	r19, 0x00	; 0
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	90 e0       	ldi	r25, 0x00	; 0
    1a4a:	6a 32       	cpi	r22, 0x2A	; 42
    1a4c:	11 f0       	breq	.+4      	; 0x1a52 <calculator+0x5c>
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	82 2b       	or	r24, r18
    1a54:	93 2b       	or	r25, r19
    1a56:	41 e0       	ldi	r20, 0x01	; 1
    1a58:	6b 32       	cpi	r22, 0x2B	; 43
    1a5a:	09 f0       	breq	.+2      	; 0x1a5e <calculator+0x68>
    1a5c:	40 e0       	ldi	r20, 0x00	; 0
    1a5e:	21 e0       	ldi	r18, 0x01	; 1
    1a60:	6d 32       	cpi	r22, 0x2D	; 45
    1a62:	09 f0       	breq	.+2      	; 0x1a66 <calculator+0x70>
    1a64:	20 e0       	ldi	r18, 0x00	; 0
    1a66:	42 2b       	or	r20, r18
    1a68:	50 e0       	ldi	r21, 0x00	; 0
    1a6a:	84 2b       	or	r24, r20
    1a6c:	95 2b       	or	r25, r21
    1a6e:	00 97       	sbiw	r24, 0x00	; 0
    1a70:	41 f0       	breq	.+16     	; 0x1a82 <calculator+0x8c>
				{
					state=1;
    1a72:	81 e0       	ldi	r24, 0x01	; 1
    1a74:	80 93 e6 06 	sts	0x06E6, r24
					v=1;
    1a78:	80 93 e3 06 	sts	0x06E3, r24
					op=pressed_number;
    1a7c:	60 93 e4 06 	sts	0x06E4, r22
    1a80:	1f c0       	rjmp	.+62     	; 0x1ac0 <calculator+0xca>
				}
				else if (pressed_number==13)
    1a82:	6d 30       	cpi	r22, 0x0D	; 13
    1a84:	e9 f4       	brne	.+58     	; 0x1ac0 <calculator+0xca>
				{
					lcd_clrScreen();
    1a86:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
					c1=0;
    1a8a:	10 92 e5 06 	sts	0x06E5, r1
					state=0;
    1a8e:	10 92 e6 06 	sts	0x06E6, r1
					op=0;
    1a92:	10 92 e4 06 	sts	0x06E4, r1
					res=0;
    1a96:	10 92 e1 06 	sts	0x06E1, r1
    1a9a:	10 92 e0 06 	sts	0x06E0, r1
    1a9e:	e1 e6       	ldi	r30, 0x61	; 97
    1aa0:	f7 e0       	ldi	r31, 0x07	; 7
    1aa2:	c3 e7       	ldi	r28, 0x73	; 115
    1aa4:	d7 e0       	ldi	r29, 0x07	; 7
    1aa6:	af e4       	ldi	r26, 0x4F	; 79
    1aa8:	b7 e0       	ldi	r27, 0x07	; 7
	{
		xSemaphoreGive(handle_sem1);
	}
	}	
}
void calculator(void)
    1aaa:	cf 01       	movw	r24, r30
    1aac:	40 96       	adiw	r24, 0x10	; 16
					state=0;
					op=0;
					res=0;
					for (int k=0;k<16;k++ )
					{
						num[k]=0;
    1aae:	11 92       	st	Z+, r1
						result[k]=0;
    1ab0:	19 92       	st	Y+, r1
						num2[k]=0;
    1ab2:	1d 92       	st	X+, r1
					lcd_clrScreen();
					c1=0;
					state=0;
					op=0;
					res=0;
					for (int k=0;k<16;k++ )
    1ab4:	e8 17       	cp	r30, r24
    1ab6:	f9 07       	cpc	r31, r25
    1ab8:	d1 f7       	brne	.-12     	; 0x1aae <calculator+0xb8>
					{
						num[k]=0;
						result[k]=0;
						num2[k]=0;
					}
					lcd_displayChar('0');
    1aba:	80 e3       	ldi	r24, 0x30	; 48
    1abc:	0e 94 17 05 	call	0xa2e	; 0xa2e <lcd_displayChar>
				}
				if ((pressed_number=='0')|(pressed_number=='1')|(pressed_number=='2')|(pressed_number=='3')|(pressed_number=='4')|(pressed_number=='5')|(pressed_number=='6')|(pressed_number=='7')|(pressed_number=='8')|(pressed_number=='9'))
    1ac0:	80 91 e2 06 	lds	r24, 0x06E2
    1ac4:	98 2f       	mov	r25, r24
    1ac6:	90 53       	subi	r25, 0x30	; 48
    1ac8:	9a 30       	cpi	r25, 0x0A	; 10
    1aca:	78 f5       	brcc	.+94     	; 0x1b2a <calculator+0x134>
				{
					if (state==0)
    1acc:	90 91 e6 06 	lds	r25, 0x06E6
    1ad0:	99 23       	and	r25, r25
    1ad2:	79 f4       	brne	.+30     	; 0x1af2 <calculator+0xfc>
					{
					lcd_displayChar(pressed_number);
    1ad4:	0e 94 17 05 	call	0xa2e	; 0xa2e <lcd_displayChar>
					num[c1]=pressed_number;
    1ad8:	80 91 e5 06 	lds	r24, 0x06E5
    1adc:	e1 e6       	ldi	r30, 0x61	; 97
    1ade:	f7 e0       	ldi	r31, 0x07	; 7
    1ae0:	e8 0f       	add	r30, r24
    1ae2:	f1 1d       	adc	r31, r1
    1ae4:	90 91 e2 06 	lds	r25, 0x06E2
    1ae8:	90 83       	st	Z, r25
					c1++;
    1aea:	8f 5f       	subi	r24, 0xFF	; 255
    1aec:	80 93 e5 06 	sts	0x06E5, r24
    1af0:	1c c0       	rjmp	.+56     	; 0x1b2a <calculator+0x134>
					}
					else if (state==1)
    1af2:	91 30       	cpi	r25, 0x01	; 1
    1af4:	d1 f4       	brne	.+52     	; 0x1b2a <calculator+0x134>
					{
						if (v)
    1af6:	80 91 e3 06 	lds	r24, 0x06E3
    1afa:	88 23       	and	r24, r24
    1afc:	31 f0       	breq	.+12     	; 0x1b0a <calculator+0x114>
						{
							c1=0;
    1afe:	10 92 e5 06 	sts	0x06E5, r1
							lcd_clrScreen();
    1b02:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
							v=0;
    1b06:	10 92 e3 06 	sts	0x06E3, r1
						}
					lcd_displayChar(pressed_number);
    1b0a:	80 91 e2 06 	lds	r24, 0x06E2
    1b0e:	0e 94 17 05 	call	0xa2e	; 0xa2e <lcd_displayChar>
					num2[c1]=pressed_number;
    1b12:	80 91 e5 06 	lds	r24, 0x06E5
    1b16:	ef e4       	ldi	r30, 0x4F	; 79
    1b18:	f7 e0       	ldi	r31, 0x07	; 7
    1b1a:	e8 0f       	add	r30, r24
    1b1c:	f1 1d       	adc	r31, r1
    1b1e:	90 91 e2 06 	lds	r25, 0x06E2
    1b22:	90 83       	st	Z, r25
					c1++;
    1b24:	8f 5f       	subi	r24, 0xFF	; 255
    1b26:	80 93 e5 06 	sts	0x06E5, r24
					}
					

				}
		if (pressed_number=='=')
    1b2a:	80 91 e2 06 	lds	r24, 0x06E2
    1b2e:	8d 33       	cpi	r24, 0x3D	; 61
    1b30:	09 f0       	breq	.+2      	; 0x1b34 <calculator+0x13e>
    1b32:	4f c0       	rjmp	.+158    	; 0x1bd2 <calculator+0x1dc>
		{			int m,n=0;
					m=toint(num);
    1b34:	81 e6       	ldi	r24, 0x61	; 97
    1b36:	97 e0       	ldi	r25, 0x07	; 7
    1b38:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <toint>
    1b3c:	ec 01       	movw	r28, r24
					n=toint(num2);
    1b3e:	8f e4       	ldi	r24, 0x4F	; 79
    1b40:	97 e0       	ldi	r25, 0x07	; 7
    1b42:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <toint>
    1b46:	bc 01       	movw	r22, r24
					switch (op)
    1b48:	80 91 e4 06 	lds	r24, 0x06E4
    1b4c:	8a 32       	cpi	r24, 0x2A	; 42
    1b4e:	c1 f0       	breq	.+48     	; 0x1b80 <calculator+0x18a>
    1b50:	8b 32       	cpi	r24, 0x2B	; 43
    1b52:	18 f4       	brcc	.+6      	; 0x1b5a <calculator+0x164>
    1b54:	85 32       	cpi	r24, 0x25	; 37
    1b56:	39 f5       	brne	.+78     	; 0x1ba6 <calculator+0x1b0>
    1b58:	1f c0       	rjmp	.+62     	; 0x1b98 <calculator+0x1a2>
    1b5a:	8b 32       	cpi	r24, 0x2B	; 43
    1b5c:	19 f0       	breq	.+6      	; 0x1b64 <calculator+0x16e>
    1b5e:	8d 32       	cpi	r24, 0x2D	; 45
    1b60:	11 f5       	brne	.+68     	; 0x1ba6 <calculator+0x1b0>
    1b62:	07 c0       	rjmp	.+14     	; 0x1b72 <calculator+0x17c>
					{
						case '+':
						{	
						res=m+n;
    1b64:	6c 0f       	add	r22, r28
    1b66:	7d 1f       	adc	r23, r29
    1b68:	70 93 e1 06 	sts	0x06E1, r23
    1b6c:	60 93 e0 06 	sts	0x06E0, r22
						}
						break;
    1b70:	1a c0       	rjmp	.+52     	; 0x1ba6 <calculator+0x1b0>
						case '-':
						{
						res=m-n;
    1b72:	c6 1b       	sub	r28, r22
    1b74:	d7 0b       	sbc	r29, r23
    1b76:	d0 93 e1 06 	sts	0x06E1, r29
    1b7a:	c0 93 e0 06 	sts	0x06E0, r28
						}
						break;
    1b7e:	13 c0       	rjmp	.+38     	; 0x1ba6 <calculator+0x1b0>
						case '*':
						{
						res=m*n;
    1b80:	6c 9f       	mul	r22, r28
    1b82:	c0 01       	movw	r24, r0
    1b84:	6d 9f       	mul	r22, r29
    1b86:	90 0d       	add	r25, r0
    1b88:	7c 9f       	mul	r23, r28
    1b8a:	90 0d       	add	r25, r0
    1b8c:	11 24       	eor	r1, r1
    1b8e:	90 93 e1 06 	sts	0x06E1, r25
    1b92:	80 93 e0 06 	sts	0x06E0, r24
						}
						break;	
    1b96:	07 c0       	rjmp	.+14     	; 0x1ba6 <calculator+0x1b0>
						case'%':
						{
						res=m/n;
    1b98:	ce 01       	movw	r24, r28
    1b9a:	0e 94 65 16 	call	0x2cca	; 0x2cca <__divmodhi4>
    1b9e:	70 93 e1 06 	sts	0x06E1, r23
    1ba2:	60 93 e0 06 	sts	0x06E0, r22
						}												
						break;
					}
			tostring(result,res);
    1ba6:	c3 e7       	ldi	r28, 0x73	; 115
    1ba8:	d7 e0       	ldi	r29, 0x07	; 7
    1baa:	60 91 e0 06 	lds	r22, 0x06E0
    1bae:	70 91 e1 06 	lds	r23, 0x06E1
    1bb2:	ce 01       	movw	r24, r28
    1bb4:	0e 94 3d 0c 	call	0x187a	; 0x187a <tostring>
			tostring(num,res);
    1bb8:	60 91 e0 06 	lds	r22, 0x06E0
    1bbc:	70 91 e1 06 	lds	r23, 0x06E1
    1bc0:	81 e6       	ldi	r24, 0x61	; 97
    1bc2:	97 e0       	ldi	r25, 0x07	; 7
    1bc4:	0e 94 3d 0c 	call	0x187a	; 0x187a <tostring>
			lcd_clrScreen();
    1bc8:	0e 94 4a 05 	call	0xa94	; 0xa94 <lcd_clrScreen>
			lcd_dispString(result);
    1bcc:	ce 01       	movw	r24, r28
    1bce:	0e 94 4e 05 	call	0xa9c	; 0xa9c <lcd_dispString>
				
				
			
			}				
	}
}
    1bd2:	df 91       	pop	r29
    1bd4:	cf 91       	pop	r28
    1bd6:	08 95       	ret

00001bd8 <Task1>:
		}
		
	}
}
void Task1(void * pvParameters)
{
    1bd8:	0f 93       	push	r16
    1bda:	1f 93       	push	r17
    1bdc:	df 93       	push	r29
    1bde:	cf 93       	push	r28
    1be0:	00 d0       	rcall	.+0      	; 0x1be2 <Task1+0xa>
    1be2:	cd b7       	in	r28, 0x3d	; 61
    1be4:	de b7       	in	r29, 0x3e	; 62
	int y = xTaskGetTickCount();
    1be6:	0e 94 e4 0f 	call	0x1fc8	; 0x1fc8 <xTaskGetTickCount>
    1bea:	9a 83       	std	Y+2, r25	; 0x02
    1bec:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		vTaskDelayUntil(&y,20);
    1bee:	8e 01       	movw	r16, r28
    1bf0:	0f 5f       	subi	r16, 0xFF	; 255
    1bf2:	1f 4f       	sbci	r17, 0xFF	; 255
    1bf4:	c8 01       	movw	r24, r16
    1bf6:	64 e1       	ldi	r22, 0x14	; 20
    1bf8:	70 e0       	ldi	r23, 0x00	; 0
    1bfa:	0e 94 b1 11 	call	0x2362	; 0x2362 <vTaskDelayUntil>
		//LCD_Display_KP();
		pressed_number = KeyPad_u8GetPressedKey();	
    1bfe:	0e 94 98 04 	call	0x930	; 0x930 <KeyPad_u8GetPressedKey>
    1c02:	80 93 e2 06 	sts	0x06E2, r24
		calculator();
    1c06:	0e 94 fb 0c 	call	0x19f6	; 0x19f6 <calculator>
    1c0a:	f4 cf       	rjmp	.-24     	; 0x1bf4 <Task1+0x1c>

00001c0c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    1c0c:	cf 93       	push	r28
    1c0e:	df 93       	push	r29
    1c10:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1c12:	e0 91 e8 06 	lds	r30, 0x06E8
    1c16:	f0 91 e9 06 	lds	r31, 0x06E9
    1c1a:	93 83       	std	Z+3, r25	; 0x03
    1c1c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1c1e:	80 91 ec 06 	lds	r24, 0x06EC
    1c22:	90 91 ed 06 	lds	r25, 0x06ED
    1c26:	c8 17       	cp	r28, r24
    1c28:	d9 07       	cpc	r29, r25
    1c2a:	68 f4       	brcc	.+26     	; 0x1c46 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c2c:	80 91 26 07 	lds	r24, 0x0726
    1c30:	90 91 27 07 	lds	r25, 0x0727
    1c34:	60 91 e8 06 	lds	r22, 0x06E8
    1c38:	70 91 e9 06 	lds	r23, 0x06E9
    1c3c:	6e 5f       	subi	r22, 0xFE	; 254
    1c3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c40:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInsert>
    1c44:	17 c0       	rjmp	.+46     	; 0x1c74 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1c46:	80 91 28 07 	lds	r24, 0x0728
    1c4a:	90 91 29 07 	lds	r25, 0x0729
    1c4e:	60 91 e8 06 	lds	r22, 0x06E8
    1c52:	70 91 e9 06 	lds	r23, 0x06E9
    1c56:	6e 5f       	subi	r22, 0xFE	; 254
    1c58:	7f 4f       	sbci	r23, 0xFF	; 255
    1c5a:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1c5e:	80 91 d5 00 	lds	r24, 0x00D5
    1c62:	90 91 d6 00 	lds	r25, 0x00D6
    1c66:	c8 17       	cp	r28, r24
    1c68:	d9 07       	cpc	r29, r25
    1c6a:	20 f4       	brcc	.+8      	; 0x1c74 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1c6c:	d0 93 d6 00 	sts	0x00D6, r29
    1c70:	c0 93 d5 00 	sts	0x00D5, r28
		}
	}
}
    1c74:	df 91       	pop	r29
    1c76:	cf 91       	pop	r28
    1c78:	08 95       	ret

00001c7a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1c7a:	2f 92       	push	r2
    1c7c:	3f 92       	push	r3
    1c7e:	4f 92       	push	r4
    1c80:	5f 92       	push	r5
    1c82:	6f 92       	push	r6
    1c84:	7f 92       	push	r7
    1c86:	8f 92       	push	r8
    1c88:	9f 92       	push	r9
    1c8a:	af 92       	push	r10
    1c8c:	bf 92       	push	r11
    1c8e:	cf 92       	push	r12
    1c90:	df 92       	push	r13
    1c92:	ef 92       	push	r14
    1c94:	ff 92       	push	r15
    1c96:	0f 93       	push	r16
    1c98:	1f 93       	push	r17
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29
    1c9e:	2c 01       	movw	r4, r24
    1ca0:	4b 01       	movw	r8, r22
    1ca2:	5a 01       	movw	r10, r20
    1ca4:	39 01       	movw	r6, r18
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1ca6:	81 e2       	ldi	r24, 0x21	; 33
    1ca8:	90 e0       	ldi	r25, 0x00	; 0
    1caa:	0e 94 d5 03 	call	0x7aa	; 0x7aa <pvPortMalloc>
    1cae:	28 2e       	mov	r2, r24
    1cb0:	e1 01       	movw	r28, r2
    1cb2:	1e 01       	movw	r2, r28
    1cb4:	39 2e       	mov	r3, r25
    1cb6:	e1 01       	movw	r28, r2

	if( pxNewTCB != NULL )
    1cb8:	20 97       	sbiw	r28, 0x00	; 0
    1cba:	09 f4       	brne	.+2      	; 0x1cbe <xTaskGenericCreate+0x44>
    1cbc:	e5 c0       	rjmp	.+458    	; 0x1e88 <xTaskGenericCreate+0x20e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1cbe:	c1 14       	cp	r12, r1
    1cc0:	d1 04       	cpc	r13, r1
    1cc2:	09 f0       	breq	.+2      	; 0x1cc6 <xTaskGenericCreate+0x4c>
    1cc4:	f9 c0       	rjmp	.+498    	; 0x1eb8 <xTaskGenericCreate+0x23e>
    1cc6:	c5 01       	movw	r24, r10
    1cc8:	0e 94 d5 03 	call	0x7aa	; 0x7aa <pvPortMalloc>
    1ccc:	c8 2e       	mov	r12, r24
    1cce:	d9 2e       	mov	r13, r25
    1cd0:	8f 8b       	std	Y+23, r24	; 0x17
    1cd2:	98 8f       	std	Y+24, r25	; 0x18

		if( pxNewTCB->pxStack == NULL )
    1cd4:	c1 14       	cp	r12, r1
    1cd6:	d1 04       	cpc	r13, r1
    1cd8:	29 f4       	brne	.+10     	; 0x1ce4 <xTaskGenericCreate+0x6a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1cda:	c1 01       	movw	r24, r2
    1cdc:	0e 94 03 04 	call	0x806	; 0x806 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1ce0:	8f ef       	ldi	r24, 0xFF	; 255
    1ce2:	d7 c0       	rjmp	.+430    	; 0x1e92 <xTaskGenericCreate+0x218>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1ce4:	8c 2d       	mov	r24, r12
    1ce6:	9d 2d       	mov	r25, r13
    1ce8:	65 ea       	ldi	r22, 0xA5	; 165
    1cea:	70 e0       	ldi	r23, 0x00	; 0
    1cec:	4a 2d       	mov	r20, r10
    1cee:	5b 2d       	mov	r21, r11
    1cf0:	0e 94 95 16 	call	0x2d2a	; 0x2d2a <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1cf4:	08 94       	sec
    1cf6:	a1 08       	sbc	r10, r1
    1cf8:	b1 08       	sbc	r11, r1
    1cfa:	8f 89       	ldd	r24, Y+23	; 0x17
    1cfc:	98 8d       	ldd	r25, Y+24	; 0x18
    1cfe:	a8 0e       	add	r10, r24
    1d00:	b9 1e       	adc	r11, r25
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1d02:	ce 01       	movw	r24, r28
    1d04:	49 96       	adiw	r24, 0x19	; 25
    1d06:	b4 01       	movw	r22, r8
    1d08:	48 e0       	ldi	r20, 0x08	; 8
    1d0a:	50 e0       	ldi	r21, 0x00	; 0
    1d0c:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1d10:	18 a2       	std	Y+32, r1	; 0x20
    1d12:	10 2f       	mov	r17, r16
    1d14:	05 30       	cpi	r16, 0x05	; 5
    1d16:	08 f0       	brcs	.+2      	; 0x1d1a <xTaskGenericCreate+0xa0>
    1d18:	14 e0       	ldi	r17, 0x04	; 4
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1d1a:	1e 8b       	std	Y+22, r17	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1d1c:	cc 24       	eor	r12, r12
    1d1e:	dd 24       	eor	r13, r13
    1d20:	68 94       	set
    1d22:	c1 f8       	bld	r12, 1
    1d24:	cc 0e       	add	r12, r28
    1d26:	dd 1e       	adc	r13, r29
    1d28:	c6 01       	movw	r24, r12
    1d2a:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1d2e:	ce 01       	movw	r24, r28
    1d30:	0c 96       	adiw	r24, 0x0c	; 12
    1d32:	0e 94 78 05 	call	0xaf0	; 0xaf0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1d36:	d9 87       	std	Y+9, r29	; 0x09
    1d38:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1d3a:	85 e0       	ldi	r24, 0x05	; 5
    1d3c:	90 e0       	ldi	r25, 0x00	; 0
    1d3e:	81 1b       	sub	r24, r17
    1d40:	91 09       	sbc	r25, r1
    1d42:	9d 87       	std	Y+13, r25	; 0x0d
    1d44:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1d46:	db 8b       	std	Y+19, r29	; 0x13
    1d48:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1d4a:	c5 01       	movw	r24, r10
    1d4c:	b2 01       	movw	r22, r4
    1d4e:	a3 01       	movw	r20, r6
    1d50:	0e 94 08 06 	call	0xc10	; 0xc10 <pxPortInitialiseStack>
    1d54:	99 83       	std	Y+1, r25	; 0x01
    1d56:	88 83       	st	Y, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1d58:	e1 14       	cp	r14, r1
    1d5a:	f1 04       	cpc	r15, r1
    1d5c:	19 f0       	breq	.+6      	; 0x1d64 <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1d5e:	f7 01       	movw	r30, r14
    1d60:	d1 83       	std	Z+1, r29	; 0x01
    1d62:	c0 83       	st	Z, r28
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1d64:	0f b6       	in	r0, 0x3f	; 63
    1d66:	f8 94       	cli
    1d68:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1d6a:	80 91 2b 07 	lds	r24, 0x072B
    1d6e:	8f 5f       	subi	r24, 0xFF	; 255
    1d70:	80 93 2b 07 	sts	0x072B, r24
			if( pxCurrentTCB == NULL )
    1d74:	80 91 e8 06 	lds	r24, 0x06E8
    1d78:	90 91 e9 06 	lds	r25, 0x06E9
    1d7c:	00 97       	sbiw	r24, 0x00	; 0
    1d7e:	09 f0       	breq	.+2      	; 0x1d82 <xTaskGenericCreate+0x108>
    1d80:	42 c0       	rjmp	.+132    	; 0x1e06 <xTaskGenericCreate+0x18c>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1d82:	d0 93 e9 06 	sts	0x06E9, r29
    1d86:	c0 93 e8 06 	sts	0x06E8, r28

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1d8a:	80 91 2b 07 	lds	r24, 0x072B
    1d8e:	81 30       	cpi	r24, 0x01	; 1
    1d90:	09 f0       	breq	.+2      	; 0x1d94 <xTaskGenericCreate+0x11a>
    1d92:	48 c0       	rjmp	.+144    	; 0x1e24 <xTaskGenericCreate+0x1aa>
    1d94:	ee 24       	eor	r14, r14
    1d96:	ff 24       	eor	r15, r15
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1d98:	c7 01       	movw	r24, r14
    1d9a:	88 0f       	add	r24, r24
    1d9c:	99 1f       	adc	r25, r25
    1d9e:	88 0f       	add	r24, r24
    1da0:	99 1f       	adc	r25, r25
    1da2:	88 0f       	add	r24, r24
    1da4:	99 1f       	adc	r25, r25
    1da6:	8e 0d       	add	r24, r14
    1da8:	9f 1d       	adc	r25, r15
    1daa:	80 51       	subi	r24, 0x10	; 16
    1dac:	99 4f       	sbci	r25, 0xF9	; 249
    1dae:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
    1db2:	08 94       	sec
    1db4:	e1 1c       	adc	r14, r1
    1db6:	f1 1c       	adc	r15, r1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1db8:	f5 e0       	ldi	r31, 0x05	; 5
    1dba:	ef 16       	cp	r14, r31
    1dbc:	f1 04       	cpc	r15, r1
    1dbe:	61 f7       	brne	.-40     	; 0x1d98 <xTaskGenericCreate+0x11e>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1dc0:	0f 2e       	mov	r0, r31
    1dc2:	f9 e3       	ldi	r31, 0x39	; 57
    1dc4:	ef 2e       	mov	r14, r31
    1dc6:	f7 e0       	ldi	r31, 0x07	; 7
    1dc8:	ff 2e       	mov	r15, r31
    1dca:	f0 2d       	mov	r31, r0
    1dcc:	c7 01       	movw	r24, r14
    1dce:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1dd2:	0f 2e       	mov	r0, r31
    1dd4:	f2 e4       	ldi	r31, 0x42	; 66
    1dd6:	af 2e       	mov	r10, r31
    1dd8:	f7 e0       	ldi	r31, 0x07	; 7
    1dda:	bf 2e       	mov	r11, r31
    1ddc:	f0 2d       	mov	r31, r0
    1dde:	c5 01       	movw	r24, r10
    1de0:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1de4:	8d e1       	ldi	r24, 0x1D	; 29
    1de6:	97 e0       	ldi	r25, 0x07	; 7
    1de8:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1dec:	8e e2       	ldi	r24, 0x2E	; 46
    1dee:	97 e0       	ldi	r25, 0x07	; 7
    1df0:	0e 94 6a 05 	call	0xad4	; 0xad4 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1df4:	f0 92 29 07 	sts	0x0729, r15
    1df8:	e0 92 28 07 	sts	0x0728, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1dfc:	b0 92 27 07 	sts	0x0727, r11
    1e00:	a0 92 26 07 	sts	0x0726, r10
    1e04:	0f c0       	rjmp	.+30     	; 0x1e24 <xTaskGenericCreate+0x1aa>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1e06:	80 91 2c 07 	lds	r24, 0x072C
    1e0a:	88 23       	and	r24, r24
    1e0c:	59 f4       	brne	.+22     	; 0x1e24 <xTaskGenericCreate+0x1aa>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1e0e:	e0 91 e8 06 	lds	r30, 0x06E8
    1e12:	f0 91 e9 06 	lds	r31, 0x06E9
    1e16:	86 89       	ldd	r24, Z+22	; 0x16
    1e18:	08 17       	cp	r16, r24
    1e1a:	20 f0       	brcs	.+8      	; 0x1e24 <xTaskGenericCreate+0x1aa>
					{
						pxCurrentTCB = pxNewTCB;
    1e1c:	d0 93 e9 06 	sts	0x06E9, r29
    1e20:	c0 93 e8 06 	sts	0x06E8, r28
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1e24:	8e 89       	ldd	r24, Y+22	; 0x16
    1e26:	90 91 38 07 	lds	r25, 0x0738
    1e2a:	98 17       	cp	r25, r24
    1e2c:	10 f4       	brcc	.+4      	; 0x1e32 <xTaskGenericCreate+0x1b8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1e2e:	80 93 38 07 	sts	0x0738, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1e32:	90 91 37 07 	lds	r25, 0x0737
    1e36:	9f 5f       	subi	r25, 0xFF	; 255
    1e38:	90 93 37 07 	sts	0x0737, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    1e3c:	90 91 ef 06 	lds	r25, 0x06EF
    1e40:	98 17       	cp	r25, r24
    1e42:	10 f4       	brcc	.+4      	; 0x1e48 <xTaskGenericCreate+0x1ce>
    1e44:	80 93 ef 06 	sts	0x06EF, r24
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	9c 01       	movw	r18, r24
    1e4c:	22 0f       	add	r18, r18
    1e4e:	33 1f       	adc	r19, r19
    1e50:	22 0f       	add	r18, r18
    1e52:	33 1f       	adc	r19, r19
    1e54:	22 0f       	add	r18, r18
    1e56:	33 1f       	adc	r19, r19
    1e58:	82 0f       	add	r24, r18
    1e5a:	93 1f       	adc	r25, r19
    1e5c:	80 51       	subi	r24, 0x10	; 16
    1e5e:	99 4f       	sbci	r25, 0xF9	; 249
    1e60:	b6 01       	movw	r22, r12
    1e62:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>

			xReturn = pdPASS;
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1e66:	0f 90       	pop	r0
    1e68:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1e6a:	80 91 2c 07 	lds	r24, 0x072C
    1e6e:	88 23       	and	r24, r24
    1e70:	69 f0       	breq	.+26     	; 0x1e8c <xTaskGenericCreate+0x212>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1e72:	e0 91 e8 06 	lds	r30, 0x06E8
    1e76:	f0 91 e9 06 	lds	r31, 0x06E9
    1e7a:	86 89       	ldd	r24, Z+22	; 0x16
    1e7c:	80 17       	cp	r24, r16
    1e7e:	40 f4       	brcc	.+16     	; 0x1e90 <xTaskGenericCreate+0x216>
			{
				portYIELD_WITHIN_API();
    1e80:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1e84:	81 e0       	ldi	r24, 0x01	; 1
    1e86:	05 c0       	rjmp	.+10     	; 0x1e92 <xTaskGenericCreate+0x218>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e88:	8f ef       	ldi	r24, 0xFF	; 255
    1e8a:	03 c0       	rjmp	.+6      	; 0x1e92 <xTaskGenericCreate+0x218>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	01 c0       	rjmp	.+2      	; 0x1e92 <xTaskGenericCreate+0x218>
    1e90:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1e92:	df 91       	pop	r29
    1e94:	cf 91       	pop	r28
    1e96:	1f 91       	pop	r17
    1e98:	0f 91       	pop	r16
    1e9a:	ff 90       	pop	r15
    1e9c:	ef 90       	pop	r14
    1e9e:	df 90       	pop	r13
    1ea0:	cf 90       	pop	r12
    1ea2:	bf 90       	pop	r11
    1ea4:	af 90       	pop	r10
    1ea6:	9f 90       	pop	r9
    1ea8:	8f 90       	pop	r8
    1eaa:	7f 90       	pop	r7
    1eac:	6f 90       	pop	r6
    1eae:	5f 90       	pop	r5
    1eb0:	4f 90       	pop	r4
    1eb2:	3f 90       	pop	r3
    1eb4:	2f 90       	pop	r2
    1eb6:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1eb8:	d8 8e       	std	Y+24, r13	; 0x18
    1eba:	cf 8a       	std	Y+23, r12	; 0x17
    1ebc:	13 cf       	rjmp	.-474    	; 0x1ce4 <xTaskGenericCreate+0x6a>

00001ebe <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1ebe:	ef 92       	push	r14
    1ec0:	ff 92       	push	r15
    1ec2:	0f 93       	push	r16
    1ec4:	1f 93       	push	r17
    1ec6:	cf 93       	push	r28
    1ec8:	df 93       	push	r29
    1eca:	ec 01       	movw	r28, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1ed2:	80 91 e8 06 	lds	r24, 0x06E8
    1ed6:	90 91 e9 06 	lds	r25, 0x06E9
    1eda:	c8 17       	cp	r28, r24
    1edc:	d9 07       	cpc	r29, r25
    1ede:	19 f0       	breq	.+6      	; 0x1ee6 <vTaskDelete+0x28>
			{
				pxTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1ee0:	20 97       	sbiw	r28, 0x00	; 0
    1ee2:	41 f4       	brne	.+16     	; 0x1ef4 <vTaskDelete+0x36>
    1ee4:	02 c0       	rjmp	.+4      	; 0x1eea <vTaskDelete+0x2c>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
			{
				pxTaskToDelete = NULL;
    1ee6:	c0 e0       	ldi	r28, 0x00	; 0
    1ee8:	d0 e0       	ldi	r29, 0x00	; 0
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1eea:	00 91 e8 06 	lds	r16, 0x06E8
    1eee:	10 91 e9 06 	lds	r17, 0x06E9
    1ef2:	01 c0       	rjmp	.+2      	; 0x1ef6 <vTaskDelete+0x38>
    1ef4:	8e 01       	movw	r16, r28

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    1ef6:	ee 24       	eor	r14, r14
    1ef8:	ff 24       	eor	r15, r15
    1efa:	68 94       	set
    1efc:	e1 f8       	bld	r14, 1
    1efe:	e0 0e       	add	r14, r16
    1f00:	f1 1e       	adc	r15, r17
    1f02:	c7 01       	movw	r24, r14
    1f04:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1f08:	f8 01       	movw	r30, r16
    1f0a:	84 89       	ldd	r24, Z+20	; 0x14
    1f0c:	95 89       	ldd	r25, Z+21	; 0x15
    1f0e:	00 97       	sbiw	r24, 0x00	; 0
    1f10:	21 f0       	breq	.+8      	; 0x1f1a <vTaskDelete+0x5c>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    1f12:	c8 01       	movw	r24, r16
    1f14:	0c 96       	adiw	r24, 0x0c	; 12
    1f16:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1f1a:	8e e2       	ldi	r24, 0x2E	; 46
    1f1c:	97 e0       	ldi	r25, 0x07	; 7
    1f1e:	b7 01       	movw	r22, r14
    1f20:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1f24:	80 91 2d 07 	lds	r24, 0x072D
    1f28:	8f 5f       	subi	r24, 0xFF	; 255
    1f2a:	80 93 2d 07 	sts	0x072D, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1f2e:	80 91 37 07 	lds	r24, 0x0737
    1f32:	8f 5f       	subi	r24, 0xFF	; 255
    1f34:	80 93 37 07 	sts	0x0737, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1f38:	0f 90       	pop	r0
    1f3a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1f3c:	80 91 2c 07 	lds	r24, 0x072C
    1f40:	88 23       	and	r24, r24
    1f42:	21 f0       	breq	.+8      	; 0x1f4c <vTaskDelete+0x8e>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    1f44:	20 97       	sbiw	r28, 0x00	; 0
    1f46:	11 f4       	brne	.+4      	; 0x1f4c <vTaskDelete+0x8e>
			{
				portYIELD_WITHIN_API();
    1f48:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
			}
		}
	}
    1f4c:	df 91       	pop	r29
    1f4e:	cf 91       	pop	r28
    1f50:	1f 91       	pop	r17
    1f52:	0f 91       	pop	r16
    1f54:	ff 90       	pop	r15
    1f56:	ef 90       	pop	r14
    1f58:	08 95       	ret

00001f5a <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1f5a:	af 92       	push	r10
    1f5c:	bf 92       	push	r11
    1f5e:	cf 92       	push	r12
    1f60:	df 92       	push	r13
    1f62:	ef 92       	push	r14
    1f64:	ff 92       	push	r15
    1f66:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1f68:	80 e5       	ldi	r24, 0x50	; 80
    1f6a:	91 e1       	ldi	r25, 0x11	; 17
    1f6c:	60 ed       	ldi	r22, 0xD0	; 208
    1f6e:	70 e0       	ldi	r23, 0x00	; 0
    1f70:	45 e5       	ldi	r20, 0x55	; 85
    1f72:	50 e0       	ldi	r21, 0x00	; 0
    1f74:	20 e0       	ldi	r18, 0x00	; 0
    1f76:	30 e0       	ldi	r19, 0x00	; 0
    1f78:	00 e0       	ldi	r16, 0x00	; 0
    1f7a:	ee 24       	eor	r14, r14
    1f7c:	ff 24       	eor	r15, r15
    1f7e:	cc 24       	eor	r12, r12
    1f80:	dd 24       	eor	r13, r13
    1f82:	aa 24       	eor	r10, r10
    1f84:	bb 24       	eor	r11, r11
    1f86:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    1f8a:	81 30       	cpi	r24, 0x01	; 1
    1f8c:	49 f4       	brne	.+18     	; 0x1fa0 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1f8e:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1f90:	80 93 2c 07 	sts	0x072C, r24
		xTickCount = ( portTickType ) 0U;
    1f94:	10 92 ed 06 	sts	0x06ED, r1
    1f98:	10 92 ec 06 	sts	0x06EC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1f9c:	0e 94 53 06 	call	0xca6	; 0xca6 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    1fa0:	0f 91       	pop	r16
    1fa2:	ff 90       	pop	r15
    1fa4:	ef 90       	pop	r14
    1fa6:	df 90       	pop	r13
    1fa8:	cf 90       	pop	r12
    1faa:	bf 90       	pop	r11
    1fac:	af 90       	pop	r10
    1fae:	08 95       	ret

00001fb0 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1fb0:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1fb2:	10 92 2c 07 	sts	0x072C, r1
	vPortEndScheduler();
    1fb6:	0e 94 88 06 	call	0xd10	; 0xd10 <vPortEndScheduler>
}
    1fba:	08 95       	ret

00001fbc <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1fbc:	80 91 ee 06 	lds	r24, 0x06EE
    1fc0:	8f 5f       	subi	r24, 0xFF	; 255
    1fc2:	80 93 ee 06 	sts	0x06EE, r24
}
    1fc6:	08 95       	ret

00001fc8 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1fc8:	0f b6       	in	r0, 0x3f	; 63
    1fca:	f8 94       	cli
    1fcc:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1fce:	20 91 ec 06 	lds	r18, 0x06EC
    1fd2:	30 91 ed 06 	lds	r19, 0x06ED
	}
	taskEXIT_CRITICAL();
    1fd6:	0f 90       	pop	r0
    1fd8:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1fda:	82 2f       	mov	r24, r18
    1fdc:	93 2f       	mov	r25, r19
    1fde:	08 95       	ret

00001fe0 <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1fe0:	20 91 ec 06 	lds	r18, 0x06EC
    1fe4:	30 91 ed 06 	lds	r19, 0x06ED
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1fe8:	82 2f       	mov	r24, r18
    1fea:	93 2f       	mov	r25, r19
    1fec:	08 95       	ret

00001fee <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1fee:	80 91 2b 07 	lds	r24, 0x072B
}
    1ff2:	08 95       	ret

00001ff4 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1ff4:	0f 93       	push	r16
    1ff6:	1f 93       	push	r17
    1ff8:	cf 93       	push	r28
    1ffa:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1ffc:	80 91 ee 06 	lds	r24, 0x06EE
    2000:	88 23       	and	r24, r24
    2002:	09 f0       	breq	.+2      	; 0x2006 <vTaskIncrementTick+0x12>
    2004:	b3 c0       	rjmp	.+358    	; 0x216c <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    2006:	80 91 ec 06 	lds	r24, 0x06EC
    200a:	90 91 ed 06 	lds	r25, 0x06ED
    200e:	01 96       	adiw	r24, 0x01	; 1
    2010:	90 93 ed 06 	sts	0x06ED, r25
    2014:	80 93 ec 06 	sts	0x06EC, r24
		if( xTickCount == ( portTickType ) 0U )
    2018:	80 91 ec 06 	lds	r24, 0x06EC
    201c:	90 91 ed 06 	lds	r25, 0x06ED
    2020:	00 97       	sbiw	r24, 0x00	; 0
    2022:	99 f5       	brne	.+102    	; 0x208a <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2024:	80 91 28 07 	lds	r24, 0x0728
    2028:	90 91 29 07 	lds	r25, 0x0729
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    202c:	20 91 26 07 	lds	r18, 0x0726
    2030:	30 91 27 07 	lds	r19, 0x0727
    2034:	30 93 29 07 	sts	0x0729, r19
    2038:	20 93 28 07 	sts	0x0728, r18
			pxOverflowDelayedTaskList = pxTemp;
    203c:	90 93 27 07 	sts	0x0727, r25
    2040:	80 93 26 07 	sts	0x0726, r24
			xNumOfOverflows++;
    2044:	80 91 eb 06 	lds	r24, 0x06EB
    2048:	8f 5f       	subi	r24, 0xFF	; 255
    204a:	80 93 eb 06 	sts	0x06EB, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    204e:	e0 91 28 07 	lds	r30, 0x0728
    2052:	f0 91 29 07 	lds	r31, 0x0729
    2056:	80 81       	ld	r24, Z
    2058:	88 23       	and	r24, r24
    205a:	39 f4       	brne	.+14     	; 0x206a <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    205c:	8f ef       	ldi	r24, 0xFF	; 255
    205e:	9f ef       	ldi	r25, 0xFF	; 255
    2060:	90 93 d6 00 	sts	0x00D6, r25
    2064:	80 93 d5 00 	sts	0x00D5, r24
    2068:	10 c0       	rjmp	.+32     	; 0x208a <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    206a:	e0 91 28 07 	lds	r30, 0x0728
    206e:	f0 91 29 07 	lds	r31, 0x0729
    2072:	05 80       	ldd	r0, Z+5	; 0x05
    2074:	f6 81       	ldd	r31, Z+6	; 0x06
    2076:	e0 2d       	mov	r30, r0
    2078:	06 80       	ldd	r0, Z+6	; 0x06
    207a:	f7 81       	ldd	r31, Z+7	; 0x07
    207c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    207e:	82 81       	ldd	r24, Z+2	; 0x02
    2080:	93 81       	ldd	r25, Z+3	; 0x03
    2082:	90 93 d6 00 	sts	0x00D6, r25
    2086:	80 93 d5 00 	sts	0x00D5, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    208a:	20 91 ec 06 	lds	r18, 0x06EC
    208e:	30 91 ed 06 	lds	r19, 0x06ED
    2092:	80 91 d5 00 	lds	r24, 0x00D5
    2096:	90 91 d6 00 	lds	r25, 0x00D6
    209a:	28 17       	cp	r18, r24
    209c:	39 07       	cpc	r19, r25
    209e:	08 f4       	brcc	.+2      	; 0x20a2 <vTaskIncrementTick+0xae>
    20a0:	6a c0       	rjmp	.+212    	; 0x2176 <vTaskIncrementTick+0x182>
    20a2:	e0 91 28 07 	lds	r30, 0x0728
    20a6:	f0 91 29 07 	lds	r31, 0x0729
    20aa:	80 81       	ld	r24, Z
    20ac:	88 23       	and	r24, r24
    20ae:	99 f0       	breq	.+38     	; 0x20d6 <vTaskIncrementTick+0xe2>
    20b0:	e0 91 28 07 	lds	r30, 0x0728
    20b4:	f0 91 29 07 	lds	r31, 0x0729
    20b8:	05 80       	ldd	r0, Z+5	; 0x05
    20ba:	f6 81       	ldd	r31, Z+6	; 0x06
    20bc:	e0 2d       	mov	r30, r0
    20be:	c6 81       	ldd	r28, Z+6	; 0x06
    20c0:	d7 81       	ldd	r29, Z+7	; 0x07
    20c2:	8a 81       	ldd	r24, Y+2	; 0x02
    20c4:	9b 81       	ldd	r25, Y+3	; 0x03
    20c6:	20 91 ec 06 	lds	r18, 0x06EC
    20ca:	30 91 ed 06 	lds	r19, 0x06ED
    20ce:	28 17       	cp	r18, r24
    20d0:	39 07       	cpc	r19, r25
    20d2:	f8 f4       	brcc	.+62     	; 0x2112 <vTaskIncrementTick+0x11e>
    20d4:	19 c0       	rjmp	.+50     	; 0x2108 <vTaskIncrementTick+0x114>
    20d6:	8f ef       	ldi	r24, 0xFF	; 255
    20d8:	9f ef       	ldi	r25, 0xFF	; 255
    20da:	90 93 d6 00 	sts	0x00D6, r25
    20de:	80 93 d5 00 	sts	0x00D5, r24
    20e2:	49 c0       	rjmp	.+146    	; 0x2176 <vTaskIncrementTick+0x182>
    20e4:	e0 91 28 07 	lds	r30, 0x0728
    20e8:	f0 91 29 07 	lds	r31, 0x0729
    20ec:	05 80       	ldd	r0, Z+5	; 0x05
    20ee:	f6 81       	ldd	r31, Z+6	; 0x06
    20f0:	e0 2d       	mov	r30, r0
    20f2:	c6 81       	ldd	r28, Z+6	; 0x06
    20f4:	d7 81       	ldd	r29, Z+7	; 0x07
    20f6:	8a 81       	ldd	r24, Y+2	; 0x02
    20f8:	9b 81       	ldd	r25, Y+3	; 0x03
    20fa:	20 91 ec 06 	lds	r18, 0x06EC
    20fe:	30 91 ed 06 	lds	r19, 0x06ED
    2102:	28 17       	cp	r18, r24
    2104:	39 07       	cpc	r19, r25
    2106:	28 f4       	brcc	.+10     	; 0x2112 <vTaskIncrementTick+0x11e>
    2108:	90 93 d6 00 	sts	0x00D6, r25
    210c:	80 93 d5 00 	sts	0x00D5, r24
    2110:	32 c0       	rjmp	.+100    	; 0x2176 <vTaskIncrementTick+0x182>
    2112:	8e 01       	movw	r16, r28
    2114:	0e 5f       	subi	r16, 0xFE	; 254
    2116:	1f 4f       	sbci	r17, 0xFF	; 255
    2118:	c8 01       	movw	r24, r16
    211a:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
    211e:	8c 89       	ldd	r24, Y+20	; 0x14
    2120:	9d 89       	ldd	r25, Y+21	; 0x15
    2122:	00 97       	sbiw	r24, 0x00	; 0
    2124:	21 f0       	breq	.+8      	; 0x212e <vTaskIncrementTick+0x13a>
    2126:	ce 01       	movw	r24, r28
    2128:	0c 96       	adiw	r24, 0x0c	; 12
    212a:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
    212e:	8e 89       	ldd	r24, Y+22	; 0x16
    2130:	90 91 ef 06 	lds	r25, 0x06EF
    2134:	98 17       	cp	r25, r24
    2136:	10 f4       	brcc	.+4      	; 0x213c <vTaskIncrementTick+0x148>
    2138:	80 93 ef 06 	sts	0x06EF, r24
    213c:	90 e0       	ldi	r25, 0x00	; 0
    213e:	9c 01       	movw	r18, r24
    2140:	22 0f       	add	r18, r18
    2142:	33 1f       	adc	r19, r19
    2144:	22 0f       	add	r18, r18
    2146:	33 1f       	adc	r19, r19
    2148:	22 0f       	add	r18, r18
    214a:	33 1f       	adc	r19, r19
    214c:	82 0f       	add	r24, r18
    214e:	93 1f       	adc	r25, r19
    2150:	80 51       	subi	r24, 0x10	; 16
    2152:	99 4f       	sbci	r25, 0xF9	; 249
    2154:	b8 01       	movw	r22, r16
    2156:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>
    215a:	e0 91 28 07 	lds	r30, 0x0728
    215e:	f0 91 29 07 	lds	r31, 0x0729
    2162:	80 81       	ld	r24, Z
    2164:	88 23       	and	r24, r24
    2166:	09 f0       	breq	.+2      	; 0x216a <vTaskIncrementTick+0x176>
    2168:	bd cf       	rjmp	.-134    	; 0x20e4 <vTaskIncrementTick+0xf0>
    216a:	b5 cf       	rjmp	.-150    	; 0x20d6 <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    216c:	80 91 2a 07 	lds	r24, 0x072A
    2170:	8f 5f       	subi	r24, 0xFF	; 255
    2172:	80 93 2a 07 	sts	0x072A, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	1f 91       	pop	r17
    217c:	0f 91       	pop	r16
    217e:	08 95       	ret

00002180 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2180:	af 92       	push	r10
    2182:	bf 92       	push	r11
    2184:	cf 92       	push	r12
    2186:	df 92       	push	r13
    2188:	ef 92       	push	r14
    218a:	ff 92       	push	r15
    218c:	0f 93       	push	r16
    218e:	1f 93       	push	r17
    2190:	cf 93       	push	r28
    2192:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2194:	0f b6       	in	r0, 0x3f	; 63
    2196:	f8 94       	cli
    2198:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    219a:	80 91 ee 06 	lds	r24, 0x06EE
    219e:	81 50       	subi	r24, 0x01	; 1
    21a0:	80 93 ee 06 	sts	0x06EE, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    21a4:	80 91 ee 06 	lds	r24, 0x06EE
    21a8:	88 23       	and	r24, r24
    21aa:	09 f0       	breq	.+2      	; 0x21ae <xTaskResumeAll+0x2e>
    21ac:	69 c0       	rjmp	.+210    	; 0x2280 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    21ae:	80 91 2b 07 	lds	r24, 0x072B
    21b2:	88 23       	and	r24, r24
    21b4:	81 f5       	brne	.+96     	; 0x2216 <xTaskResumeAll+0x96>
    21b6:	67 c0       	rjmp	.+206    	; 0x2286 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    21b8:	d6 01       	movw	r26, r12
    21ba:	ed 91       	ld	r30, X+
    21bc:	fc 91       	ld	r31, X
    21be:	c6 81       	ldd	r28, Z+6	; 0x06
    21c0:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
    21c2:	ce 01       	movw	r24, r28
    21c4:	0c 96       	adiw	r24, 0x0c	; 12
    21c6:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    21ca:	8e 01       	movw	r16, r28
    21cc:	0e 5f       	subi	r16, 0xFE	; 254
    21ce:	1f 4f       	sbci	r17, 0xFF	; 255
    21d0:	c8 01       	movw	r24, r16
    21d2:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    21d6:	8e 89       	ldd	r24, Y+22	; 0x16
    21d8:	90 91 ef 06 	lds	r25, 0x06EF
    21dc:	98 17       	cp	r25, r24
    21de:	10 f4       	brcc	.+4      	; 0x21e4 <xTaskResumeAll+0x64>
    21e0:	80 93 ef 06 	sts	0x06EF, r24
    21e4:	90 e0       	ldi	r25, 0x00	; 0
    21e6:	9c 01       	movw	r18, r24
    21e8:	22 0f       	add	r18, r18
    21ea:	33 1f       	adc	r19, r19
    21ec:	22 0f       	add	r18, r18
    21ee:	33 1f       	adc	r19, r19
    21f0:	22 0f       	add	r18, r18
    21f2:	33 1f       	adc	r19, r19
    21f4:	82 0f       	add	r24, r18
    21f6:	93 1f       	adc	r25, r19
    21f8:	80 51       	subi	r24, 0x10	; 16
    21fa:	99 4f       	sbci	r25, 0xF9	; 249
    21fc:	b8 01       	movw	r22, r16
    21fe:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2202:	e0 91 e8 06 	lds	r30, 0x06E8
    2206:	f0 91 e9 06 	lds	r31, 0x06E9
    220a:	9e 89       	ldd	r25, Y+22	; 0x16
    220c:	86 89       	ldd	r24, Z+22	; 0x16
    220e:	98 17       	cp	r25, r24
    2210:	88 f0       	brcs	.+34     	; 0x2234 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    2212:	ba 2c       	mov	r11, r10
    2214:	0f c0       	rjmp	.+30     	; 0x2234 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2216:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2218:	0f 2e       	mov	r0, r31
    221a:	fd e1       	ldi	r31, 0x1D	; 29
    221c:	ef 2e       	mov	r14, r31
    221e:	f7 e0       	ldi	r31, 0x07	; 7
    2220:	ff 2e       	mov	r15, r31
    2222:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2224:	0f 2e       	mov	r0, r31
    2226:	f2 e2       	ldi	r31, 0x22	; 34
    2228:	cf 2e       	mov	r12, r31
    222a:	f7 e0       	ldi	r31, 0x07	; 7
    222c:	df 2e       	mov	r13, r31
    222e:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    2230:	aa 24       	eor	r10, r10
    2232:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2234:	f7 01       	movw	r30, r14
    2236:	80 81       	ld	r24, Z
    2238:	88 23       	and	r24, r24
    223a:	09 f0       	breq	.+2      	; 0x223e <xTaskResumeAll+0xbe>
    223c:	bd cf       	rjmp	.-134    	; 0x21b8 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    223e:	80 91 2a 07 	lds	r24, 0x072A
    2242:	88 23       	and	r24, r24
    2244:	81 f0       	breq	.+32     	; 0x2266 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2246:	80 91 2a 07 	lds	r24, 0x072A
    224a:	88 23       	and	r24, r24
    224c:	99 f0       	breq	.+38     	; 0x2274 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    224e:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vTaskIncrementTick>
						--uxMissedTicks;
    2252:	80 91 2a 07 	lds	r24, 0x072A
    2256:	81 50       	subi	r24, 0x01	; 1
    2258:	80 93 2a 07 	sts	0x072A, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    225c:	80 91 2a 07 	lds	r24, 0x072A
    2260:	88 23       	and	r24, r24
    2262:	a9 f7       	brne	.-22     	; 0x224e <xTaskResumeAll+0xce>
    2264:	07 c0       	rjmp	.+14     	; 0x2274 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2266:	fb 2d       	mov	r31, r11
    2268:	f1 30       	cpi	r31, 0x01	; 1
    226a:	21 f0       	breq	.+8      	; 0x2274 <xTaskResumeAll+0xf4>
    226c:	80 91 ea 06 	lds	r24, 0x06EA
    2270:	81 30       	cpi	r24, 0x01	; 1
    2272:	41 f4       	brne	.+16     	; 0x2284 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2274:	10 92 ea 06 	sts	0x06EA, r1
					portYIELD_WITHIN_API();
    2278:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    227c:	81 e0       	ldi	r24, 0x01	; 1
    227e:	03 c0       	rjmp	.+6      	; 0x2286 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2280:	80 e0       	ldi	r24, 0x00	; 0
    2282:	01 c0       	rjmp	.+2      	; 0x2286 <xTaskResumeAll+0x106>
    2284:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2286:	0f 90       	pop	r0
    2288:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    228a:	df 91       	pop	r29
    228c:	cf 91       	pop	r28
    228e:	1f 91       	pop	r17
    2290:	0f 91       	pop	r16
    2292:	ff 90       	pop	r15
    2294:	ef 90       	pop	r14
    2296:	df 90       	pop	r13
    2298:	cf 90       	pop	r12
    229a:	bf 90       	pop	r11
    229c:	af 90       	pop	r10
    229e:	08 95       	ret

000022a0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    22a0:	cf 92       	push	r12
    22a2:	df 92       	push	r13
    22a4:	ff 92       	push	r15
    22a6:	0f 93       	push	r16
    22a8:	1f 93       	push	r17
    22aa:	cf 93       	push	r28
    22ac:	df 93       	push	r29
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    22ae:	0e e2       	ldi	r16, 0x2E	; 46
    22b0:	17 e0       	ldi	r17, 0x07	; 7
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    22b2:	0f 2e       	mov	r0, r31
    22b4:	f3 e3       	ldi	r31, 0x33	; 51
    22b6:	cf 2e       	mov	r12, r31
    22b8:	f7 e0       	ldi	r31, 0x07	; 7
    22ba:	df 2e       	mov	r13, r31
    22bc:	f0 2d       	mov	r31, r0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    22be:	80 91 2d 07 	lds	r24, 0x072D
    22c2:	88 23       	and	r24, r24
    22c4:	39 f1       	breq	.+78     	; 0x2314 <prvIdleTask+0x74>
		{
			vTaskSuspendAll();
    22c6:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    22ca:	d8 01       	movw	r26, r16
    22cc:	fc 90       	ld	r15, X
			xTaskResumeAll();
    22ce:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    22d2:	ff 20       	and	r15, r15
    22d4:	f9 f0       	breq	.+62     	; 0x2314 <prvIdleTask+0x74>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    22d6:	0f b6       	in	r0, 0x3f	; 63
    22d8:	f8 94       	cli
    22da:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    22dc:	d6 01       	movw	r26, r12
    22de:	ed 91       	ld	r30, X+
    22e0:	fc 91       	ld	r31, X
    22e2:	c6 81       	ldd	r28, Z+6	; 0x06
    22e4:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    22e6:	ce 01       	movw	r24, r28
    22e8:	02 96       	adiw	r24, 0x02	; 2
    22ea:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
					--uxCurrentNumberOfTasks;
    22ee:	80 91 2b 07 	lds	r24, 0x072B
    22f2:	81 50       	subi	r24, 0x01	; 1
    22f4:	80 93 2b 07 	sts	0x072B, r24
					--uxTasksDeleted;
    22f8:	80 91 2d 07 	lds	r24, 0x072D
    22fc:	81 50       	subi	r24, 0x01	; 1
    22fe:	80 93 2d 07 	sts	0x072D, r24
				}
				taskEXIT_CRITICAL();
    2302:	0f 90       	pop	r0
    2304:	0f be       	out	0x3f, r0	; 63

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2306:	8f 89       	ldd	r24, Y+23	; 0x17
    2308:	98 8d       	ldd	r25, Y+24	; 0x18
    230a:	0e 94 03 04 	call	0x806	; 0x806 <vPortFree>
		vPortFree( pxTCB );
    230e:	ce 01       	movw	r24, r28
    2310:	0e 94 03 04 	call	0x806	; 0x806 <vPortFree>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    2314:	0e 94 10 0c 	call	0x1820	; 0x1820 <vApplicationIdleHook>
    2318:	d2 cf       	rjmp	.-92     	; 0x22be <prvIdleTask+0x1e>

0000231a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    231a:	0f 93       	push	r16
    231c:	1f 93       	push	r17
    231e:	cf 93       	push	r28
    2320:	df 93       	push	r29
    2322:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2324:	00 97       	sbiw	r24, 0x00	; 0
    2326:	b1 f0       	breq	.+44     	; 0x2354 <vTaskDelay+0x3a>
		{
			vTaskSuspendAll();
    2328:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    232c:	00 91 ec 06 	lds	r16, 0x06EC
    2330:	10 91 ed 06 	lds	r17, 0x06ED

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2334:	80 91 e8 06 	lds	r24, 0x06E8
    2338:	90 91 e9 06 	lds	r25, 0x06E9
    233c:	02 96       	adiw	r24, 0x02	; 2
    233e:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2342:	ce 01       	movw	r24, r28
    2344:	80 0f       	add	r24, r16
    2346:	91 1f       	adc	r25, r17
    2348:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    234c:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2350:	88 23       	and	r24, r24
    2352:	11 f4       	brne	.+4      	; 0x2358 <vTaskDelay+0x3e>
		{
			portYIELD_WITHIN_API();
    2354:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
		}
	}
    2358:	df 91       	pop	r29
    235a:	cf 91       	pop	r28
    235c:	1f 91       	pop	r17
    235e:	0f 91       	pop	r16
    2360:	08 95       	ret

00002362 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2362:	0f 93       	push	r16
    2364:	1f 93       	push	r17
    2366:	cf 93       	push	r28
    2368:	df 93       	push	r29
    236a:	8c 01       	movw	r16, r24
    236c:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    236e:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2372:	f8 01       	movw	r30, r16
    2374:	80 81       	ld	r24, Z
    2376:	91 81       	ldd	r25, Z+1	; 0x01
    2378:	c8 0f       	add	r28, r24
    237a:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    237c:	20 91 ec 06 	lds	r18, 0x06EC
    2380:	30 91 ed 06 	lds	r19, 0x06ED
    2384:	28 17       	cp	r18, r24
    2386:	39 07       	cpc	r19, r25
    2388:	68 f4       	brcc	.+26     	; 0x23a4 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    238a:	c8 17       	cp	r28, r24
    238c:	d9 07       	cpc	r29, r25
    238e:	50 f5       	brcc	.+84     	; 0x23e4 <vTaskDelayUntil+0x82>
    2390:	80 91 ec 06 	lds	r24, 0x06EC
    2394:	90 91 ed 06 	lds	r25, 0x06ED
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2398:	d1 83       	std	Z+1, r29	; 0x01
    239a:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    239c:	8c 17       	cp	r24, r28
    239e:	9d 07       	cpc	r25, r29
    23a0:	b0 f4       	brcc	.+44     	; 0x23ce <vTaskDelayUntil+0x6c>
    23a2:	0b c0       	rjmp	.+22     	; 0x23ba <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    23a4:	c8 17       	cp	r28, r24
    23a6:	d9 07       	cpc	r29, r25
    23a8:	c8 f0       	brcs	.+50     	; 0x23dc <vTaskDelayUntil+0x7a>
    23aa:	80 91 ec 06 	lds	r24, 0x06EC
    23ae:	90 91 ed 06 	lds	r25, 0x06ED
    23b2:	8c 17       	cp	r24, r28
    23b4:	9d 07       	cpc	r25, r29
    23b6:	90 f0       	brcs	.+36     	; 0x23dc <vTaskDelayUntil+0x7a>
    23b8:	15 c0       	rjmp	.+42     	; 0x23e4 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    23ba:	80 91 e8 06 	lds	r24, 0x06E8
    23be:	90 91 e9 06 	lds	r25, 0x06E9
    23c2:	02 96       	adiw	r24, 0x02	; 2
    23c4:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    23c8:	ce 01       	movw	r24, r28
    23ca:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    23ce:	0e 94 c0 10 	call	0x2180	; 0x2180 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    23d2:	88 23       	and	r24, r24
    23d4:	59 f4       	brne	.+22     	; 0x23ec <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    23d6:	0e 94 89 06 	call	0xd12	; 0xd12 <vPortYield>
    23da:	08 c0       	rjmp	.+16     	; 0x23ec <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    23dc:	f8 01       	movw	r30, r16
    23de:	d1 83       	std	Z+1, r29	; 0x01
    23e0:	c0 83       	st	Z, r28
    23e2:	eb cf       	rjmp	.-42     	; 0x23ba <vTaskDelayUntil+0x58>
    23e4:	f8 01       	movw	r30, r16
    23e6:	d1 83       	std	Z+1, r29	; 0x01
    23e8:	c0 83       	st	Z, r28
    23ea:	f1 cf       	rjmp	.-30     	; 0x23ce <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    23ec:	df 91       	pop	r29
    23ee:	cf 91       	pop	r28
    23f0:	1f 91       	pop	r17
    23f2:	0f 91       	pop	r16
    23f4:	08 95       	ret

000023f6 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    23f6:	80 91 ee 06 	lds	r24, 0x06EE
    23fa:	88 23       	and	r24, r24
    23fc:	99 f4       	brne	.+38     	; 0x2424 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    23fe:	80 91 ef 06 	lds	r24, 0x06EF
    2402:	90 e0       	ldi	r25, 0x00	; 0
    2404:	fc 01       	movw	r30, r24
    2406:	ee 0f       	add	r30, r30
    2408:	ff 1f       	adc	r31, r31
    240a:	ee 0f       	add	r30, r30
    240c:	ff 1f       	adc	r31, r31
    240e:	ee 0f       	add	r30, r30
    2410:	ff 1f       	adc	r31, r31
    2412:	8e 0f       	add	r24, r30
    2414:	9f 1f       	adc	r25, r31
    2416:	fc 01       	movw	r30, r24
    2418:	e0 51       	subi	r30, 0x10	; 16
    241a:	f9 4f       	sbci	r31, 0xF9	; 249
    241c:	80 81       	ld	r24, Z
    241e:	88 23       	and	r24, r24
    2420:	29 f0       	breq	.+10     	; 0x242c <vTaskSwitchContext+0x36>
    2422:	1d c0       	rjmp	.+58     	; 0x245e <vTaskSwitchContext+0x68>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	80 93 ea 06 	sts	0x06EA, r24
    242a:	08 95       	ret
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    242c:	20 ef       	ldi	r18, 0xF0	; 240
    242e:	36 e0       	ldi	r19, 0x06	; 6
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    2430:	80 91 ef 06 	lds	r24, 0x06EF
    2434:	81 50       	subi	r24, 0x01	; 1
    2436:	80 93 ef 06 	sts	0x06EF, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    243a:	80 91 ef 06 	lds	r24, 0x06EF
    243e:	90 e0       	ldi	r25, 0x00	; 0
    2440:	fc 01       	movw	r30, r24
    2442:	ee 0f       	add	r30, r30
    2444:	ff 1f       	adc	r31, r31
    2446:	ee 0f       	add	r30, r30
    2448:	ff 1f       	adc	r31, r31
    244a:	ee 0f       	add	r30, r30
    244c:	ff 1f       	adc	r31, r31
    244e:	8e 0f       	add	r24, r30
    2450:	9f 1f       	adc	r25, r31
    2452:	f9 01       	movw	r30, r18
    2454:	e8 0f       	add	r30, r24
    2456:	f9 1f       	adc	r31, r25
    2458:	80 81       	ld	r24, Z
    245a:	88 23       	and	r24, r24
    245c:	49 f3       	breq	.-46     	; 0x2430 <vTaskSwitchContext+0x3a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    245e:	80 91 ef 06 	lds	r24, 0x06EF
    2462:	90 e0       	ldi	r25, 0x00	; 0
    2464:	9c 01       	movw	r18, r24
    2466:	22 0f       	add	r18, r18
    2468:	33 1f       	adc	r19, r19
    246a:	22 0f       	add	r18, r18
    246c:	33 1f       	adc	r19, r19
    246e:	22 0f       	add	r18, r18
    2470:	33 1f       	adc	r19, r19
    2472:	28 0f       	add	r18, r24
    2474:	39 1f       	adc	r19, r25
    2476:	d9 01       	movw	r26, r18
    2478:	a0 51       	subi	r26, 0x10	; 16
    247a:	b9 4f       	sbci	r27, 0xF9	; 249
    247c:	11 96       	adiw	r26, 0x01	; 1
    247e:	ed 91       	ld	r30, X+
    2480:	fc 91       	ld	r31, X
    2482:	12 97       	sbiw	r26, 0x02	; 2
    2484:	02 80       	ldd	r0, Z+2	; 0x02
    2486:	f3 81       	ldd	r31, Z+3	; 0x03
    2488:	e0 2d       	mov	r30, r0
    248a:	12 96       	adiw	r26, 0x02	; 2
    248c:	fc 93       	st	X, r31
    248e:	ee 93       	st	-X, r30
    2490:	11 97       	sbiw	r26, 0x01	; 1
    2492:	2d 50       	subi	r18, 0x0D	; 13
    2494:	39 4f       	sbci	r19, 0xF9	; 249
    2496:	e2 17       	cp	r30, r18
    2498:	f3 07       	cpc	r31, r19
    249a:	29 f4       	brne	.+10     	; 0x24a6 <vTaskSwitchContext+0xb0>
    249c:	22 81       	ldd	r18, Z+2	; 0x02
    249e:	33 81       	ldd	r19, Z+3	; 0x03
    24a0:	fd 01       	movw	r30, r26
    24a2:	32 83       	std	Z+2, r19	; 0x02
    24a4:	21 83       	std	Z+1, r18	; 0x01
    24a6:	fc 01       	movw	r30, r24
    24a8:	ee 0f       	add	r30, r30
    24aa:	ff 1f       	adc	r31, r31
    24ac:	ee 0f       	add	r30, r30
    24ae:	ff 1f       	adc	r31, r31
    24b0:	ee 0f       	add	r30, r30
    24b2:	ff 1f       	adc	r31, r31
    24b4:	8e 0f       	add	r24, r30
    24b6:	9f 1f       	adc	r25, r31
    24b8:	fc 01       	movw	r30, r24
    24ba:	e0 51       	subi	r30, 0x10	; 16
    24bc:	f9 4f       	sbci	r31, 0xF9	; 249
    24be:	01 80       	ldd	r0, Z+1	; 0x01
    24c0:	f2 81       	ldd	r31, Z+2	; 0x02
    24c2:	e0 2d       	mov	r30, r0
    24c4:	86 81       	ldd	r24, Z+6	; 0x06
    24c6:	97 81       	ldd	r25, Z+7	; 0x07
    24c8:	90 93 e9 06 	sts	0x06E9, r25
    24cc:	80 93 e8 06 	sts	0x06E8, r24
    24d0:	08 95       	ret

000024d2 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    24d2:	cf 93       	push	r28
    24d4:	df 93       	push	r29
    24d6:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    24d8:	60 91 e8 06 	lds	r22, 0x06E8
    24dc:	70 91 e9 06 	lds	r23, 0x06E9
    24e0:	64 5f       	subi	r22, 0xF4	; 244
    24e2:	7f 4f       	sbci	r23, 0xFF	; 255
    24e4:	0e 94 a3 05 	call	0xb46	; 0xb46 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    24e8:	80 91 e8 06 	lds	r24, 0x06E8
    24ec:	90 91 e9 06 	lds	r25, 0x06E9
    24f0:	02 96       	adiw	r24, 0x02	; 2
    24f2:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    24f6:	80 91 ec 06 	lds	r24, 0x06EC
    24fa:	90 91 ed 06 	lds	r25, 0x06ED
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    24fe:	8c 0f       	add	r24, r28
    2500:	9d 1f       	adc	r25, r29
    2502:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    2506:	df 91       	pop	r29
    2508:	cf 91       	pop	r28
    250a:	08 95       	ret

0000250c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    250c:	0f 93       	push	r16
    250e:	1f 93       	push	r17
    2510:	cf 93       	push	r28
    2512:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2514:	dc 01       	movw	r26, r24
    2516:	15 96       	adiw	r26, 0x05	; 5
    2518:	ed 91       	ld	r30, X+
    251a:	fc 91       	ld	r31, X
    251c:	16 97       	sbiw	r26, 0x06	; 6
    251e:	c6 81       	ldd	r28, Z+6	; 0x06
    2520:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2522:	8e 01       	movw	r16, r28
    2524:	04 5f       	subi	r16, 0xF4	; 244
    2526:	1f 4f       	sbci	r17, 0xFF	; 255
    2528:	c8 01       	movw	r24, r16
    252a:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    252e:	80 91 ee 06 	lds	r24, 0x06EE
    2532:	88 23       	and	r24, r24
    2534:	e9 f4       	brne	.+58     	; 0x2570 <xTaskRemoveFromEventList+0x64>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2536:	8e 01       	movw	r16, r28
    2538:	0e 5f       	subi	r16, 0xFE	; 254
    253a:	1f 4f       	sbci	r17, 0xFF	; 255
    253c:	c8 01       	movw	r24, r16
    253e:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2542:	8e 89       	ldd	r24, Y+22	; 0x16
    2544:	90 91 ef 06 	lds	r25, 0x06EF
    2548:	98 17       	cp	r25, r24
    254a:	10 f4       	brcc	.+4      	; 0x2550 <xTaskRemoveFromEventList+0x44>
    254c:	80 93 ef 06 	sts	0x06EF, r24
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	9c 01       	movw	r18, r24
    2554:	22 0f       	add	r18, r18
    2556:	33 1f       	adc	r19, r19
    2558:	22 0f       	add	r18, r18
    255a:	33 1f       	adc	r19, r19
    255c:	22 0f       	add	r18, r18
    255e:	33 1f       	adc	r19, r19
    2560:	82 0f       	add	r24, r18
    2562:	93 1f       	adc	r25, r19
    2564:	80 51       	subi	r24, 0x10	; 16
    2566:	99 4f       	sbci	r25, 0xF9	; 249
    2568:	b8 01       	movw	r22, r16
    256a:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>
    256e:	05 c0       	rjmp	.+10     	; 0x257a <xTaskRemoveFromEventList+0x6e>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2570:	8d e1       	ldi	r24, 0x1D	; 29
    2572:	97 e0       	ldi	r25, 0x07	; 7
    2574:	b8 01       	movw	r22, r16
    2576:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    257a:	e0 91 e8 06 	lds	r30, 0x06E8
    257e:	f0 91 e9 06 	lds	r31, 0x06E9
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2582:	81 e0       	ldi	r24, 0x01	; 1
    2584:	2e 89       	ldd	r18, Y+22	; 0x16
    2586:	96 89       	ldd	r25, Z+22	; 0x16
    2588:	29 17       	cp	r18, r25
    258a:	08 f4       	brcc	.+2      	; 0x258e <xTaskRemoveFromEventList+0x82>
    258c:	80 e0       	ldi	r24, 0x00	; 0
}
    258e:	df 91       	pop	r29
    2590:	cf 91       	pop	r28
    2592:	1f 91       	pop	r17
    2594:	0f 91       	pop	r16
    2596:	08 95       	ret

00002598 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2598:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    259a:	80 91 eb 06 	lds	r24, 0x06EB
    259e:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    25a0:	80 91 ec 06 	lds	r24, 0x06EC
    25a4:	90 91 ed 06 	lds	r25, 0x06ED
    25a8:	92 83       	std	Z+2, r25	; 0x02
    25aa:	81 83       	std	Z+1, r24	; 0x01
}
    25ac:	08 95       	ret

000025ae <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    25ae:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    25b0:	0f b6       	in	r0, 0x3f	; 63
    25b2:	f8 94       	cli
    25b4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    25b6:	80 91 eb 06 	lds	r24, 0x06EB
    25ba:	90 81       	ld	r25, Z
    25bc:	98 17       	cp	r25, r24
    25be:	49 f0       	breq	.+18     	; 0x25d2 <xTaskCheckForTimeOut+0x24>
    25c0:	80 91 ec 06 	lds	r24, 0x06EC
    25c4:	90 91 ed 06 	lds	r25, 0x06ED
    25c8:	21 81       	ldd	r18, Z+1	; 0x01
    25ca:	32 81       	ldd	r19, Z+2	; 0x02
    25cc:	82 17       	cp	r24, r18
    25ce:	93 07       	cpc	r25, r19
    25d0:	f0 f4       	brcc	.+60     	; 0x260e <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    25d2:	40 91 ec 06 	lds	r20, 0x06EC
    25d6:	50 91 ed 06 	lds	r21, 0x06ED
    25da:	21 81       	ldd	r18, Z+1	; 0x01
    25dc:	32 81       	ldd	r19, Z+2	; 0x02
    25de:	db 01       	movw	r26, r22
    25e0:	8d 91       	ld	r24, X+
    25e2:	9c 91       	ld	r25, X
    25e4:	11 97       	sbiw	r26, 0x01	; 1
    25e6:	42 1b       	sub	r20, r18
    25e8:	53 0b       	sbc	r21, r19
    25ea:	48 17       	cp	r20, r24
    25ec:	59 07       	cpc	r21, r25
    25ee:	88 f4       	brcc	.+34     	; 0x2612 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    25f0:	40 91 ec 06 	lds	r20, 0x06EC
    25f4:	50 91 ed 06 	lds	r21, 0x06ED
    25f8:	24 1b       	sub	r18, r20
    25fa:	35 0b       	sbc	r19, r21
    25fc:	82 0f       	add	r24, r18
    25fe:	93 1f       	adc	r25, r19
    2600:	8d 93       	st	X+, r24
    2602:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    2604:	cf 01       	movw	r24, r30
    2606:	0e 94 cc 12 	call	0x2598	; 0x2598 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    260a:	80 e0       	ldi	r24, 0x00	; 0
    260c:	03 c0       	rjmp	.+6      	; 0x2614 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	01 c0       	rjmp	.+2      	; 0x2614 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2612:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2614:	0f 90       	pop	r0
    2616:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2618:	08 95       	ret

0000261a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    261a:	81 e0       	ldi	r24, 0x01	; 1
    261c:	80 93 ea 06 	sts	0x06EA, r24
}
    2620:	08 95       	ret

00002622 <__subsf3>:
    2622:	50 58       	subi	r21, 0x80	; 128

00002624 <__addsf3>:
    2624:	bb 27       	eor	r27, r27
    2626:	aa 27       	eor	r26, r26
    2628:	0e d0       	rcall	.+28     	; 0x2646 <__addsf3x>
    262a:	e5 c0       	rjmp	.+458    	; 0x27f6 <__fp_round>
    262c:	d6 d0       	rcall	.+428    	; 0x27da <__fp_pscA>
    262e:	30 f0       	brcs	.+12     	; 0x263c <__addsf3+0x18>
    2630:	db d0       	rcall	.+438    	; 0x27e8 <__fp_pscB>
    2632:	20 f0       	brcs	.+8      	; 0x263c <__addsf3+0x18>
    2634:	31 f4       	brne	.+12     	; 0x2642 <__addsf3+0x1e>
    2636:	9f 3f       	cpi	r25, 0xFF	; 255
    2638:	11 f4       	brne	.+4      	; 0x263e <__addsf3+0x1a>
    263a:	1e f4       	brtc	.+6      	; 0x2642 <__addsf3+0x1e>
    263c:	cb c0       	rjmp	.+406    	; 0x27d4 <__fp_nan>
    263e:	0e f4       	brtc	.+2      	; 0x2642 <__addsf3+0x1e>
    2640:	e0 95       	com	r30
    2642:	e7 fb       	bst	r30, 7
    2644:	c1 c0       	rjmp	.+386    	; 0x27c8 <__fp_inf>

00002646 <__addsf3x>:
    2646:	e9 2f       	mov	r30, r25
    2648:	e7 d0       	rcall	.+462    	; 0x2818 <__fp_split3>
    264a:	80 f3       	brcs	.-32     	; 0x262c <__addsf3+0x8>
    264c:	ba 17       	cp	r27, r26
    264e:	62 07       	cpc	r22, r18
    2650:	73 07       	cpc	r23, r19
    2652:	84 07       	cpc	r24, r20
    2654:	95 07       	cpc	r25, r21
    2656:	18 f0       	brcs	.+6      	; 0x265e <__addsf3x+0x18>
    2658:	71 f4       	brne	.+28     	; 0x2676 <__addsf3x+0x30>
    265a:	9e f5       	brtc	.+102    	; 0x26c2 <__addsf3x+0x7c>
    265c:	ff c0       	rjmp	.+510    	; 0x285c <__fp_zero>
    265e:	0e f4       	brtc	.+2      	; 0x2662 <__addsf3x+0x1c>
    2660:	e0 95       	com	r30
    2662:	0b 2e       	mov	r0, r27
    2664:	ba 2f       	mov	r27, r26
    2666:	a0 2d       	mov	r26, r0
    2668:	0b 01       	movw	r0, r22
    266a:	b9 01       	movw	r22, r18
    266c:	90 01       	movw	r18, r0
    266e:	0c 01       	movw	r0, r24
    2670:	ca 01       	movw	r24, r20
    2672:	a0 01       	movw	r20, r0
    2674:	11 24       	eor	r1, r1
    2676:	ff 27       	eor	r31, r31
    2678:	59 1b       	sub	r21, r25
    267a:	99 f0       	breq	.+38     	; 0x26a2 <__addsf3x+0x5c>
    267c:	59 3f       	cpi	r21, 0xF9	; 249
    267e:	50 f4       	brcc	.+20     	; 0x2694 <__addsf3x+0x4e>
    2680:	50 3e       	cpi	r21, 0xE0	; 224
    2682:	68 f1       	brcs	.+90     	; 0x26de <__addsf3x+0x98>
    2684:	1a 16       	cp	r1, r26
    2686:	f0 40       	sbci	r31, 0x00	; 0
    2688:	a2 2f       	mov	r26, r18
    268a:	23 2f       	mov	r18, r19
    268c:	34 2f       	mov	r19, r20
    268e:	44 27       	eor	r20, r20
    2690:	58 5f       	subi	r21, 0xF8	; 248
    2692:	f3 cf       	rjmp	.-26     	; 0x267a <__addsf3x+0x34>
    2694:	46 95       	lsr	r20
    2696:	37 95       	ror	r19
    2698:	27 95       	ror	r18
    269a:	a7 95       	ror	r26
    269c:	f0 40       	sbci	r31, 0x00	; 0
    269e:	53 95       	inc	r21
    26a0:	c9 f7       	brne	.-14     	; 0x2694 <__addsf3x+0x4e>
    26a2:	7e f4       	brtc	.+30     	; 0x26c2 <__addsf3x+0x7c>
    26a4:	1f 16       	cp	r1, r31
    26a6:	ba 0b       	sbc	r27, r26
    26a8:	62 0b       	sbc	r22, r18
    26aa:	73 0b       	sbc	r23, r19
    26ac:	84 0b       	sbc	r24, r20
    26ae:	ba f0       	brmi	.+46     	; 0x26de <__addsf3x+0x98>
    26b0:	91 50       	subi	r25, 0x01	; 1
    26b2:	a1 f0       	breq	.+40     	; 0x26dc <__addsf3x+0x96>
    26b4:	ff 0f       	add	r31, r31
    26b6:	bb 1f       	adc	r27, r27
    26b8:	66 1f       	adc	r22, r22
    26ba:	77 1f       	adc	r23, r23
    26bc:	88 1f       	adc	r24, r24
    26be:	c2 f7       	brpl	.-16     	; 0x26b0 <__addsf3x+0x6a>
    26c0:	0e c0       	rjmp	.+28     	; 0x26de <__addsf3x+0x98>
    26c2:	ba 0f       	add	r27, r26
    26c4:	62 1f       	adc	r22, r18
    26c6:	73 1f       	adc	r23, r19
    26c8:	84 1f       	adc	r24, r20
    26ca:	48 f4       	brcc	.+18     	; 0x26de <__addsf3x+0x98>
    26cc:	87 95       	ror	r24
    26ce:	77 95       	ror	r23
    26d0:	67 95       	ror	r22
    26d2:	b7 95       	ror	r27
    26d4:	f7 95       	ror	r31
    26d6:	9e 3f       	cpi	r25, 0xFE	; 254
    26d8:	08 f0       	brcs	.+2      	; 0x26dc <__addsf3x+0x96>
    26da:	b3 cf       	rjmp	.-154    	; 0x2642 <__addsf3+0x1e>
    26dc:	93 95       	inc	r25
    26de:	88 0f       	add	r24, r24
    26e0:	08 f0       	brcs	.+2      	; 0x26e4 <__addsf3x+0x9e>
    26e2:	99 27       	eor	r25, r25
    26e4:	ee 0f       	add	r30, r30
    26e6:	97 95       	ror	r25
    26e8:	87 95       	ror	r24
    26ea:	08 95       	ret

000026ec <__fixsfsi>:
    26ec:	04 d0       	rcall	.+8      	; 0x26f6 <__fixunssfsi>
    26ee:	68 94       	set
    26f0:	b1 11       	cpse	r27, r1
    26f2:	b5 c0       	rjmp	.+362    	; 0x285e <__fp_szero>
    26f4:	08 95       	ret

000026f6 <__fixunssfsi>:
    26f6:	98 d0       	rcall	.+304    	; 0x2828 <__fp_splitA>
    26f8:	88 f0       	brcs	.+34     	; 0x271c <__fixunssfsi+0x26>
    26fa:	9f 57       	subi	r25, 0x7F	; 127
    26fc:	90 f0       	brcs	.+36     	; 0x2722 <__fixunssfsi+0x2c>
    26fe:	b9 2f       	mov	r27, r25
    2700:	99 27       	eor	r25, r25
    2702:	b7 51       	subi	r27, 0x17	; 23
    2704:	a0 f0       	brcs	.+40     	; 0x272e <__fixunssfsi+0x38>
    2706:	d1 f0       	breq	.+52     	; 0x273c <__fixunssfsi+0x46>
    2708:	66 0f       	add	r22, r22
    270a:	77 1f       	adc	r23, r23
    270c:	88 1f       	adc	r24, r24
    270e:	99 1f       	adc	r25, r25
    2710:	1a f0       	brmi	.+6      	; 0x2718 <__fixunssfsi+0x22>
    2712:	ba 95       	dec	r27
    2714:	c9 f7       	brne	.-14     	; 0x2708 <__fixunssfsi+0x12>
    2716:	12 c0       	rjmp	.+36     	; 0x273c <__fixunssfsi+0x46>
    2718:	b1 30       	cpi	r27, 0x01	; 1
    271a:	81 f0       	breq	.+32     	; 0x273c <__fixunssfsi+0x46>
    271c:	9f d0       	rcall	.+318    	; 0x285c <__fp_zero>
    271e:	b1 e0       	ldi	r27, 0x01	; 1
    2720:	08 95       	ret
    2722:	9c c0       	rjmp	.+312    	; 0x285c <__fp_zero>
    2724:	67 2f       	mov	r22, r23
    2726:	78 2f       	mov	r23, r24
    2728:	88 27       	eor	r24, r24
    272a:	b8 5f       	subi	r27, 0xF8	; 248
    272c:	39 f0       	breq	.+14     	; 0x273c <__fixunssfsi+0x46>
    272e:	b9 3f       	cpi	r27, 0xF9	; 249
    2730:	cc f3       	brlt	.-14     	; 0x2724 <__fixunssfsi+0x2e>
    2732:	86 95       	lsr	r24
    2734:	77 95       	ror	r23
    2736:	67 95       	ror	r22
    2738:	b3 95       	inc	r27
    273a:	d9 f7       	brne	.-10     	; 0x2732 <__fixunssfsi+0x3c>
    273c:	3e f4       	brtc	.+14     	; 0x274c <__fixunssfsi+0x56>
    273e:	90 95       	com	r25
    2740:	80 95       	com	r24
    2742:	70 95       	com	r23
    2744:	61 95       	neg	r22
    2746:	7f 4f       	sbci	r23, 0xFF	; 255
    2748:	8f 4f       	sbci	r24, 0xFF	; 255
    274a:	9f 4f       	sbci	r25, 0xFF	; 255
    274c:	08 95       	ret

0000274e <__floatunsisf>:
    274e:	e8 94       	clt
    2750:	09 c0       	rjmp	.+18     	; 0x2764 <__floatsisf+0x12>

00002752 <__floatsisf>:
    2752:	97 fb       	bst	r25, 7
    2754:	3e f4       	brtc	.+14     	; 0x2764 <__floatsisf+0x12>
    2756:	90 95       	com	r25
    2758:	80 95       	com	r24
    275a:	70 95       	com	r23
    275c:	61 95       	neg	r22
    275e:	7f 4f       	sbci	r23, 0xFF	; 255
    2760:	8f 4f       	sbci	r24, 0xFF	; 255
    2762:	9f 4f       	sbci	r25, 0xFF	; 255
    2764:	99 23       	and	r25, r25
    2766:	a9 f0       	breq	.+42     	; 0x2792 <__floatsisf+0x40>
    2768:	f9 2f       	mov	r31, r25
    276a:	96 e9       	ldi	r25, 0x96	; 150
    276c:	bb 27       	eor	r27, r27
    276e:	93 95       	inc	r25
    2770:	f6 95       	lsr	r31
    2772:	87 95       	ror	r24
    2774:	77 95       	ror	r23
    2776:	67 95       	ror	r22
    2778:	b7 95       	ror	r27
    277a:	f1 11       	cpse	r31, r1
    277c:	f8 cf       	rjmp	.-16     	; 0x276e <__floatsisf+0x1c>
    277e:	fa f4       	brpl	.+62     	; 0x27be <__floatsisf+0x6c>
    2780:	bb 0f       	add	r27, r27
    2782:	11 f4       	brne	.+4      	; 0x2788 <__floatsisf+0x36>
    2784:	60 ff       	sbrs	r22, 0
    2786:	1b c0       	rjmp	.+54     	; 0x27be <__floatsisf+0x6c>
    2788:	6f 5f       	subi	r22, 0xFF	; 255
    278a:	7f 4f       	sbci	r23, 0xFF	; 255
    278c:	8f 4f       	sbci	r24, 0xFF	; 255
    278e:	9f 4f       	sbci	r25, 0xFF	; 255
    2790:	16 c0       	rjmp	.+44     	; 0x27be <__floatsisf+0x6c>
    2792:	88 23       	and	r24, r24
    2794:	11 f0       	breq	.+4      	; 0x279a <__floatsisf+0x48>
    2796:	96 e9       	ldi	r25, 0x96	; 150
    2798:	11 c0       	rjmp	.+34     	; 0x27bc <__floatsisf+0x6a>
    279a:	77 23       	and	r23, r23
    279c:	21 f0       	breq	.+8      	; 0x27a6 <__floatsisf+0x54>
    279e:	9e e8       	ldi	r25, 0x8E	; 142
    27a0:	87 2f       	mov	r24, r23
    27a2:	76 2f       	mov	r23, r22
    27a4:	05 c0       	rjmp	.+10     	; 0x27b0 <__floatsisf+0x5e>
    27a6:	66 23       	and	r22, r22
    27a8:	71 f0       	breq	.+28     	; 0x27c6 <__floatsisf+0x74>
    27aa:	96 e8       	ldi	r25, 0x86	; 134
    27ac:	86 2f       	mov	r24, r22
    27ae:	70 e0       	ldi	r23, 0x00	; 0
    27b0:	60 e0       	ldi	r22, 0x00	; 0
    27b2:	2a f0       	brmi	.+10     	; 0x27be <__floatsisf+0x6c>
    27b4:	9a 95       	dec	r25
    27b6:	66 0f       	add	r22, r22
    27b8:	77 1f       	adc	r23, r23
    27ba:	88 1f       	adc	r24, r24
    27bc:	da f7       	brpl	.-10     	; 0x27b4 <__floatsisf+0x62>
    27be:	88 0f       	add	r24, r24
    27c0:	96 95       	lsr	r25
    27c2:	87 95       	ror	r24
    27c4:	97 f9       	bld	r25, 7
    27c6:	08 95       	ret

000027c8 <__fp_inf>:
    27c8:	97 f9       	bld	r25, 7
    27ca:	9f 67       	ori	r25, 0x7F	; 127
    27cc:	80 e8       	ldi	r24, 0x80	; 128
    27ce:	70 e0       	ldi	r23, 0x00	; 0
    27d0:	60 e0       	ldi	r22, 0x00	; 0
    27d2:	08 95       	ret

000027d4 <__fp_nan>:
    27d4:	9f ef       	ldi	r25, 0xFF	; 255
    27d6:	80 ec       	ldi	r24, 0xC0	; 192
    27d8:	08 95       	ret

000027da <__fp_pscA>:
    27da:	00 24       	eor	r0, r0
    27dc:	0a 94       	dec	r0
    27de:	16 16       	cp	r1, r22
    27e0:	17 06       	cpc	r1, r23
    27e2:	18 06       	cpc	r1, r24
    27e4:	09 06       	cpc	r0, r25
    27e6:	08 95       	ret

000027e8 <__fp_pscB>:
    27e8:	00 24       	eor	r0, r0
    27ea:	0a 94       	dec	r0
    27ec:	12 16       	cp	r1, r18
    27ee:	13 06       	cpc	r1, r19
    27f0:	14 06       	cpc	r1, r20
    27f2:	05 06       	cpc	r0, r21
    27f4:	08 95       	ret

000027f6 <__fp_round>:
    27f6:	09 2e       	mov	r0, r25
    27f8:	03 94       	inc	r0
    27fa:	00 0c       	add	r0, r0
    27fc:	11 f4       	brne	.+4      	; 0x2802 <__fp_round+0xc>
    27fe:	88 23       	and	r24, r24
    2800:	52 f0       	brmi	.+20     	; 0x2816 <__fp_round+0x20>
    2802:	bb 0f       	add	r27, r27
    2804:	40 f4       	brcc	.+16     	; 0x2816 <__fp_round+0x20>
    2806:	bf 2b       	or	r27, r31
    2808:	11 f4       	brne	.+4      	; 0x280e <__fp_round+0x18>
    280a:	60 ff       	sbrs	r22, 0
    280c:	04 c0       	rjmp	.+8      	; 0x2816 <__fp_round+0x20>
    280e:	6f 5f       	subi	r22, 0xFF	; 255
    2810:	7f 4f       	sbci	r23, 0xFF	; 255
    2812:	8f 4f       	sbci	r24, 0xFF	; 255
    2814:	9f 4f       	sbci	r25, 0xFF	; 255
    2816:	08 95       	ret

00002818 <__fp_split3>:
    2818:	57 fd       	sbrc	r21, 7
    281a:	90 58       	subi	r25, 0x80	; 128
    281c:	44 0f       	add	r20, r20
    281e:	55 1f       	adc	r21, r21
    2820:	59 f0       	breq	.+22     	; 0x2838 <__fp_splitA+0x10>
    2822:	5f 3f       	cpi	r21, 0xFF	; 255
    2824:	71 f0       	breq	.+28     	; 0x2842 <__fp_splitA+0x1a>
    2826:	47 95       	ror	r20

00002828 <__fp_splitA>:
    2828:	88 0f       	add	r24, r24
    282a:	97 fb       	bst	r25, 7
    282c:	99 1f       	adc	r25, r25
    282e:	61 f0       	breq	.+24     	; 0x2848 <__fp_splitA+0x20>
    2830:	9f 3f       	cpi	r25, 0xFF	; 255
    2832:	79 f0       	breq	.+30     	; 0x2852 <__fp_splitA+0x2a>
    2834:	87 95       	ror	r24
    2836:	08 95       	ret
    2838:	12 16       	cp	r1, r18
    283a:	13 06       	cpc	r1, r19
    283c:	14 06       	cpc	r1, r20
    283e:	55 1f       	adc	r21, r21
    2840:	f2 cf       	rjmp	.-28     	; 0x2826 <__fp_split3+0xe>
    2842:	46 95       	lsr	r20
    2844:	f1 df       	rcall	.-30     	; 0x2828 <__fp_splitA>
    2846:	08 c0       	rjmp	.+16     	; 0x2858 <__fp_splitA+0x30>
    2848:	16 16       	cp	r1, r22
    284a:	17 06       	cpc	r1, r23
    284c:	18 06       	cpc	r1, r24
    284e:	99 1f       	adc	r25, r25
    2850:	f1 cf       	rjmp	.-30     	; 0x2834 <__fp_splitA+0xc>
    2852:	86 95       	lsr	r24
    2854:	71 05       	cpc	r23, r1
    2856:	61 05       	cpc	r22, r1
    2858:	08 94       	sec
    285a:	08 95       	ret

0000285c <__fp_zero>:
    285c:	e8 94       	clt

0000285e <__fp_szero>:
    285e:	bb 27       	eor	r27, r27
    2860:	66 27       	eor	r22, r22
    2862:	77 27       	eor	r23, r23
    2864:	cb 01       	movw	r24, r22
    2866:	97 f9       	bld	r25, 7
    2868:	08 95       	ret

0000286a <__mulsf3>:
    286a:	0b d0       	rcall	.+22     	; 0x2882 <__mulsf3x>
    286c:	c4 cf       	rjmp	.-120    	; 0x27f6 <__fp_round>
    286e:	b5 df       	rcall	.-150    	; 0x27da <__fp_pscA>
    2870:	28 f0       	brcs	.+10     	; 0x287c <__mulsf3+0x12>
    2872:	ba df       	rcall	.-140    	; 0x27e8 <__fp_pscB>
    2874:	18 f0       	brcs	.+6      	; 0x287c <__mulsf3+0x12>
    2876:	95 23       	and	r25, r21
    2878:	09 f0       	breq	.+2      	; 0x287c <__mulsf3+0x12>
    287a:	a6 cf       	rjmp	.-180    	; 0x27c8 <__fp_inf>
    287c:	ab cf       	rjmp	.-170    	; 0x27d4 <__fp_nan>
    287e:	11 24       	eor	r1, r1
    2880:	ee cf       	rjmp	.-36     	; 0x285e <__fp_szero>

00002882 <__mulsf3x>:
    2882:	ca df       	rcall	.-108    	; 0x2818 <__fp_split3>
    2884:	a0 f3       	brcs	.-24     	; 0x286e <__mulsf3+0x4>

00002886 <__mulsf3_pse>:
    2886:	95 9f       	mul	r25, r21
    2888:	d1 f3       	breq	.-12     	; 0x287e <__mulsf3+0x14>
    288a:	95 0f       	add	r25, r21
    288c:	50 e0       	ldi	r21, 0x00	; 0
    288e:	55 1f       	adc	r21, r21
    2890:	62 9f       	mul	r22, r18
    2892:	f0 01       	movw	r30, r0
    2894:	72 9f       	mul	r23, r18
    2896:	bb 27       	eor	r27, r27
    2898:	f0 0d       	add	r31, r0
    289a:	b1 1d       	adc	r27, r1
    289c:	63 9f       	mul	r22, r19
    289e:	aa 27       	eor	r26, r26
    28a0:	f0 0d       	add	r31, r0
    28a2:	b1 1d       	adc	r27, r1
    28a4:	aa 1f       	adc	r26, r26
    28a6:	64 9f       	mul	r22, r20
    28a8:	66 27       	eor	r22, r22
    28aa:	b0 0d       	add	r27, r0
    28ac:	a1 1d       	adc	r26, r1
    28ae:	66 1f       	adc	r22, r22
    28b0:	82 9f       	mul	r24, r18
    28b2:	22 27       	eor	r18, r18
    28b4:	b0 0d       	add	r27, r0
    28b6:	a1 1d       	adc	r26, r1
    28b8:	62 1f       	adc	r22, r18
    28ba:	73 9f       	mul	r23, r19
    28bc:	b0 0d       	add	r27, r0
    28be:	a1 1d       	adc	r26, r1
    28c0:	62 1f       	adc	r22, r18
    28c2:	83 9f       	mul	r24, r19
    28c4:	a0 0d       	add	r26, r0
    28c6:	61 1d       	adc	r22, r1
    28c8:	22 1f       	adc	r18, r18
    28ca:	74 9f       	mul	r23, r20
    28cc:	33 27       	eor	r19, r19
    28ce:	a0 0d       	add	r26, r0
    28d0:	61 1d       	adc	r22, r1
    28d2:	23 1f       	adc	r18, r19
    28d4:	84 9f       	mul	r24, r20
    28d6:	60 0d       	add	r22, r0
    28d8:	21 1d       	adc	r18, r1
    28da:	82 2f       	mov	r24, r18
    28dc:	76 2f       	mov	r23, r22
    28de:	6a 2f       	mov	r22, r26
    28e0:	11 24       	eor	r1, r1
    28e2:	9f 57       	subi	r25, 0x7F	; 127
    28e4:	50 40       	sbci	r21, 0x00	; 0
    28e6:	8a f0       	brmi	.+34     	; 0x290a <__mulsf3_pse+0x84>
    28e8:	e1 f0       	breq	.+56     	; 0x2922 <__mulsf3_pse+0x9c>
    28ea:	88 23       	and	r24, r24
    28ec:	4a f0       	brmi	.+18     	; 0x2900 <__mulsf3_pse+0x7a>
    28ee:	ee 0f       	add	r30, r30
    28f0:	ff 1f       	adc	r31, r31
    28f2:	bb 1f       	adc	r27, r27
    28f4:	66 1f       	adc	r22, r22
    28f6:	77 1f       	adc	r23, r23
    28f8:	88 1f       	adc	r24, r24
    28fa:	91 50       	subi	r25, 0x01	; 1
    28fc:	50 40       	sbci	r21, 0x00	; 0
    28fe:	a9 f7       	brne	.-22     	; 0x28ea <__mulsf3_pse+0x64>
    2900:	9e 3f       	cpi	r25, 0xFE	; 254
    2902:	51 05       	cpc	r21, r1
    2904:	70 f0       	brcs	.+28     	; 0x2922 <__mulsf3_pse+0x9c>
    2906:	60 cf       	rjmp	.-320    	; 0x27c8 <__fp_inf>
    2908:	aa cf       	rjmp	.-172    	; 0x285e <__fp_szero>
    290a:	5f 3f       	cpi	r21, 0xFF	; 255
    290c:	ec f3       	brlt	.-6      	; 0x2908 <__mulsf3_pse+0x82>
    290e:	98 3e       	cpi	r25, 0xE8	; 232
    2910:	dc f3       	brlt	.-10     	; 0x2908 <__mulsf3_pse+0x82>
    2912:	86 95       	lsr	r24
    2914:	77 95       	ror	r23
    2916:	67 95       	ror	r22
    2918:	b7 95       	ror	r27
    291a:	f7 95       	ror	r31
    291c:	e7 95       	ror	r30
    291e:	9f 5f       	subi	r25, 0xFF	; 255
    2920:	c1 f7       	brne	.-16     	; 0x2912 <__mulsf3_pse+0x8c>
    2922:	fe 2b       	or	r31, r30
    2924:	88 0f       	add	r24, r24
    2926:	91 1d       	adc	r25, r1
    2928:	96 95       	lsr	r25
    292a:	87 95       	ror	r24
    292c:	97 f9       	bld	r25, 7
    292e:	08 95       	ret

00002930 <pow>:
    2930:	fa 01       	movw	r30, r20
    2932:	ee 0f       	add	r30, r30
    2934:	ff 1f       	adc	r31, r31
    2936:	30 96       	adiw	r30, 0x00	; 0
    2938:	21 05       	cpc	r18, r1
    293a:	31 05       	cpc	r19, r1
    293c:	99 f1       	breq	.+102    	; 0x29a4 <pow+0x74>
    293e:	61 15       	cp	r22, r1
    2940:	71 05       	cpc	r23, r1
    2942:	61 f4       	brne	.+24     	; 0x295c <pow+0x2c>
    2944:	80 38       	cpi	r24, 0x80	; 128
    2946:	bf e3       	ldi	r27, 0x3F	; 63
    2948:	9b 07       	cpc	r25, r27
    294a:	49 f1       	breq	.+82     	; 0x299e <pow+0x6e>
    294c:	68 94       	set
    294e:	90 38       	cpi	r25, 0x80	; 128
    2950:	81 05       	cpc	r24, r1
    2952:	61 f0       	breq	.+24     	; 0x296c <pow+0x3c>
    2954:	80 38       	cpi	r24, 0x80	; 128
    2956:	bf ef       	ldi	r27, 0xFF	; 255
    2958:	9b 07       	cpc	r25, r27
    295a:	41 f0       	breq	.+16     	; 0x296c <pow+0x3c>
    295c:	99 23       	and	r25, r25
    295e:	42 f5       	brpl	.+80     	; 0x29b0 <pow+0x80>
    2960:	ff 3f       	cpi	r31, 0xFF	; 255
    2962:	e1 05       	cpc	r30, r1
    2964:	31 05       	cpc	r19, r1
    2966:	21 05       	cpc	r18, r1
    2968:	11 f1       	breq	.+68     	; 0x29ae <pow+0x7e>
    296a:	e8 94       	clt
    296c:	08 94       	sec
    296e:	e7 95       	ror	r30
    2970:	d9 01       	movw	r26, r18
    2972:	aa 23       	and	r26, r26
    2974:	29 f4       	brne	.+10     	; 0x2980 <pow+0x50>
    2976:	ab 2f       	mov	r26, r27
    2978:	be 2f       	mov	r27, r30
    297a:	f8 5f       	subi	r31, 0xF8	; 248
    297c:	d0 f3       	brcs	.-12     	; 0x2972 <pow+0x42>
    297e:	10 c0       	rjmp	.+32     	; 0x29a0 <pow+0x70>
    2980:	ff 5f       	subi	r31, 0xFF	; 255
    2982:	70 f4       	brcc	.+28     	; 0x29a0 <pow+0x70>
    2984:	a6 95       	lsr	r26
    2986:	e0 f7       	brcc	.-8      	; 0x2980 <pow+0x50>
    2988:	f7 39       	cpi	r31, 0x97	; 151
    298a:	50 f0       	brcs	.+20     	; 0x29a0 <pow+0x70>
    298c:	19 f0       	breq	.+6      	; 0x2994 <pow+0x64>
    298e:	ff 3a       	cpi	r31, 0xAF	; 175
    2990:	38 f4       	brcc	.+14     	; 0x29a0 <pow+0x70>
    2992:	9f 77       	andi	r25, 0x7F	; 127
    2994:	9f 93       	push	r25
    2996:	0c d0       	rcall	.+24     	; 0x29b0 <pow+0x80>
    2998:	0f 90       	pop	r0
    299a:	07 fc       	sbrc	r0, 7
    299c:	90 58       	subi	r25, 0x80	; 128
    299e:	08 95       	ret
    29a0:	3e f0       	brts	.+14     	; 0x29b0 <pow+0x80>
    29a2:	18 cf       	rjmp	.-464    	; 0x27d4 <__fp_nan>
    29a4:	60 e0       	ldi	r22, 0x00	; 0
    29a6:	70 e0       	ldi	r23, 0x00	; 0
    29a8:	80 e8       	ldi	r24, 0x80	; 128
    29aa:	9f e3       	ldi	r25, 0x3F	; 63
    29ac:	08 95       	ret
    29ae:	4f e7       	ldi	r20, 0x7F	; 127
    29b0:	9f 77       	andi	r25, 0x7F	; 127
    29b2:	5f 93       	push	r21
    29b4:	4f 93       	push	r20
    29b6:	3f 93       	push	r19
    29b8:	2f 93       	push	r18
    29ba:	9e d0       	rcall	.+316    	; 0x2af8 <log>
    29bc:	2f 91       	pop	r18
    29be:	3f 91       	pop	r19
    29c0:	4f 91       	pop	r20
    29c2:	5f 91       	pop	r21
    29c4:	52 df       	rcall	.-348    	; 0x286a <__mulsf3>
    29c6:	05 c0       	rjmp	.+10     	; 0x29d2 <exp>
    29c8:	19 f4       	brne	.+6      	; 0x29d0 <pow+0xa0>
    29ca:	0e f0       	brts	.+2      	; 0x29ce <pow+0x9e>
    29cc:	fd ce       	rjmp	.-518    	; 0x27c8 <__fp_inf>
    29ce:	46 cf       	rjmp	.-372    	; 0x285c <__fp_zero>
    29d0:	01 cf       	rjmp	.-510    	; 0x27d4 <__fp_nan>

000029d2 <exp>:
    29d2:	2a df       	rcall	.-428    	; 0x2828 <__fp_splitA>
    29d4:	c8 f3       	brcs	.-14     	; 0x29c8 <pow+0x98>
    29d6:	96 38       	cpi	r25, 0x86	; 134
    29d8:	c0 f7       	brcc	.-16     	; 0x29ca <pow+0x9a>
    29da:	07 f8       	bld	r0, 7
    29dc:	0f 92       	push	r0
    29de:	e8 94       	clt
    29e0:	2b e3       	ldi	r18, 0x3B	; 59
    29e2:	3a ea       	ldi	r19, 0xAA	; 170
    29e4:	48 eb       	ldi	r20, 0xB8	; 184
    29e6:	5f e7       	ldi	r21, 0x7F	; 127
    29e8:	4e df       	rcall	.-356    	; 0x2886 <__mulsf3_pse>
    29ea:	0f 92       	push	r0
    29ec:	0f 92       	push	r0
    29ee:	0f 92       	push	r0
    29f0:	4d b7       	in	r20, 0x3d	; 61
    29f2:	5e b7       	in	r21, 0x3e	; 62
    29f4:	0f 92       	push	r0
    29f6:	c0 d0       	rcall	.+384    	; 0x2b78 <modf>
    29f8:	e4 e5       	ldi	r30, 0x54	; 84
    29fa:	f0 e0       	ldi	r31, 0x00	; 0
    29fc:	16 d0       	rcall	.+44     	; 0x2a2a <__fp_powser>
    29fe:	4f 91       	pop	r20
    2a00:	5f 91       	pop	r21
    2a02:	ef 91       	pop	r30
    2a04:	ff 91       	pop	r31
    2a06:	e5 95       	asr	r30
    2a08:	ee 1f       	adc	r30, r30
    2a0a:	ff 1f       	adc	r31, r31
    2a0c:	49 f0       	breq	.+18     	; 0x2a20 <exp+0x4e>
    2a0e:	fe 57       	subi	r31, 0x7E	; 126
    2a10:	e0 68       	ori	r30, 0x80	; 128
    2a12:	44 27       	eor	r20, r20
    2a14:	ee 0f       	add	r30, r30
    2a16:	44 1f       	adc	r20, r20
    2a18:	fa 95       	dec	r31
    2a1a:	e1 f7       	brne	.-8      	; 0x2a14 <exp+0x42>
    2a1c:	41 95       	neg	r20
    2a1e:	55 0b       	sbc	r21, r21
    2a20:	32 d0       	rcall	.+100    	; 0x2a86 <ldexp>
    2a22:	0f 90       	pop	r0
    2a24:	07 fe       	sbrs	r0, 7
    2a26:	26 c0       	rjmp	.+76     	; 0x2a74 <inverse>
    2a28:	08 95       	ret

00002a2a <__fp_powser>:
    2a2a:	df 93       	push	r29
    2a2c:	cf 93       	push	r28
    2a2e:	1f 93       	push	r17
    2a30:	0f 93       	push	r16
    2a32:	ff 92       	push	r15
    2a34:	ef 92       	push	r14
    2a36:	df 92       	push	r13
    2a38:	7b 01       	movw	r14, r22
    2a3a:	8c 01       	movw	r16, r24
    2a3c:	68 94       	set
    2a3e:	05 c0       	rjmp	.+10     	; 0x2a4a <__fp_powser+0x20>
    2a40:	da 2e       	mov	r13, r26
    2a42:	ef 01       	movw	r28, r30
    2a44:	1e df       	rcall	.-452    	; 0x2882 <__mulsf3x>
    2a46:	fe 01       	movw	r30, r28
    2a48:	e8 94       	clt
    2a4a:	a5 91       	lpm	r26, Z+
    2a4c:	25 91       	lpm	r18, Z+
    2a4e:	35 91       	lpm	r19, Z+
    2a50:	45 91       	lpm	r20, Z+
    2a52:	55 91       	lpm	r21, Z+
    2a54:	ae f3       	brts	.-22     	; 0x2a40 <__fp_powser+0x16>
    2a56:	ef 01       	movw	r28, r30
    2a58:	f6 dd       	rcall	.-1044   	; 0x2646 <__addsf3x>
    2a5a:	fe 01       	movw	r30, r28
    2a5c:	97 01       	movw	r18, r14
    2a5e:	a8 01       	movw	r20, r16
    2a60:	da 94       	dec	r13
    2a62:	79 f7       	brne	.-34     	; 0x2a42 <__fp_powser+0x18>
    2a64:	df 90       	pop	r13
    2a66:	ef 90       	pop	r14
    2a68:	ff 90       	pop	r15
    2a6a:	0f 91       	pop	r16
    2a6c:	1f 91       	pop	r17
    2a6e:	cf 91       	pop	r28
    2a70:	df 91       	pop	r29
    2a72:	08 95       	ret

00002a74 <inverse>:
    2a74:	9b 01       	movw	r18, r22
    2a76:	ac 01       	movw	r20, r24
    2a78:	60 e0       	ldi	r22, 0x00	; 0
    2a7a:	70 e0       	ldi	r23, 0x00	; 0
    2a7c:	80 e8       	ldi	r24, 0x80	; 128
    2a7e:	9f e3       	ldi	r25, 0x3F	; 63
    2a80:	ae c0       	rjmp	.+348    	; 0x2bde <__divsf3>
    2a82:	a2 ce       	rjmp	.-700    	; 0x27c8 <__fp_inf>
    2a84:	14 c1       	rjmp	.+552    	; 0x2cae <__fp_mpack>

00002a86 <ldexp>:
    2a86:	d0 de       	rcall	.-608    	; 0x2828 <__fp_splitA>
    2a88:	e8 f3       	brcs	.-6      	; 0x2a84 <inverse+0x10>
    2a8a:	99 23       	and	r25, r25
    2a8c:	d9 f3       	breq	.-10     	; 0x2a84 <inverse+0x10>
    2a8e:	94 0f       	add	r25, r20
    2a90:	51 1d       	adc	r21, r1
    2a92:	bb f3       	brvs	.-18     	; 0x2a82 <inverse+0xe>
    2a94:	91 50       	subi	r25, 0x01	; 1
    2a96:	50 40       	sbci	r21, 0x00	; 0
    2a98:	94 f0       	brlt	.+36     	; 0x2abe <ldexp+0x38>
    2a9a:	59 f0       	breq	.+22     	; 0x2ab2 <ldexp+0x2c>
    2a9c:	88 23       	and	r24, r24
    2a9e:	32 f0       	brmi	.+12     	; 0x2aac <ldexp+0x26>
    2aa0:	66 0f       	add	r22, r22
    2aa2:	77 1f       	adc	r23, r23
    2aa4:	88 1f       	adc	r24, r24
    2aa6:	91 50       	subi	r25, 0x01	; 1
    2aa8:	50 40       	sbci	r21, 0x00	; 0
    2aaa:	c1 f7       	brne	.-16     	; 0x2a9c <ldexp+0x16>
    2aac:	9e 3f       	cpi	r25, 0xFE	; 254
    2aae:	51 05       	cpc	r21, r1
    2ab0:	44 f7       	brge	.-48     	; 0x2a82 <inverse+0xe>
    2ab2:	88 0f       	add	r24, r24
    2ab4:	91 1d       	adc	r25, r1
    2ab6:	96 95       	lsr	r25
    2ab8:	87 95       	ror	r24
    2aba:	97 f9       	bld	r25, 7
    2abc:	08 95       	ret
    2abe:	5f 3f       	cpi	r21, 0xFF	; 255
    2ac0:	ac f0       	brlt	.+42     	; 0x2aec <ldexp+0x66>
    2ac2:	98 3e       	cpi	r25, 0xE8	; 232
    2ac4:	9c f0       	brlt	.+38     	; 0x2aec <ldexp+0x66>
    2ac6:	bb 27       	eor	r27, r27
    2ac8:	86 95       	lsr	r24
    2aca:	77 95       	ror	r23
    2acc:	67 95       	ror	r22
    2ace:	b7 95       	ror	r27
    2ad0:	08 f4       	brcc	.+2      	; 0x2ad4 <ldexp+0x4e>
    2ad2:	b1 60       	ori	r27, 0x01	; 1
    2ad4:	93 95       	inc	r25
    2ad6:	c1 f7       	brne	.-16     	; 0x2ac8 <ldexp+0x42>
    2ad8:	bb 0f       	add	r27, r27
    2ada:	58 f7       	brcc	.-42     	; 0x2ab2 <ldexp+0x2c>
    2adc:	11 f4       	brne	.+4      	; 0x2ae2 <ldexp+0x5c>
    2ade:	60 ff       	sbrs	r22, 0
    2ae0:	e8 cf       	rjmp	.-48     	; 0x2ab2 <ldexp+0x2c>
    2ae2:	6f 5f       	subi	r22, 0xFF	; 255
    2ae4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae6:	8f 4f       	sbci	r24, 0xFF	; 255
    2ae8:	9f 4f       	sbci	r25, 0xFF	; 255
    2aea:	e3 cf       	rjmp	.-58     	; 0x2ab2 <ldexp+0x2c>
    2aec:	b8 ce       	rjmp	.-656    	; 0x285e <__fp_szero>
    2aee:	0e f0       	brts	.+2      	; 0x2af2 <ldexp+0x6c>
    2af0:	de c0       	rjmp	.+444    	; 0x2cae <__fp_mpack>
    2af2:	70 ce       	rjmp	.-800    	; 0x27d4 <__fp_nan>
    2af4:	68 94       	set
    2af6:	68 ce       	rjmp	.-816    	; 0x27c8 <__fp_inf>

00002af8 <log>:
    2af8:	97 de       	rcall	.-722    	; 0x2828 <__fp_splitA>
    2afa:	c8 f3       	brcs	.-14     	; 0x2aee <ldexp+0x68>
    2afc:	99 23       	and	r25, r25
    2afe:	d1 f3       	breq	.-12     	; 0x2af4 <ldexp+0x6e>
    2b00:	c6 f3       	brts	.-16     	; 0x2af2 <ldexp+0x6c>
    2b02:	df 93       	push	r29
    2b04:	cf 93       	push	r28
    2b06:	1f 93       	push	r17
    2b08:	0f 93       	push	r16
    2b0a:	ff 92       	push	r15
    2b0c:	c9 2f       	mov	r28, r25
    2b0e:	dd 27       	eor	r29, r29
    2b10:	88 23       	and	r24, r24
    2b12:	2a f0       	brmi	.+10     	; 0x2b1e <log+0x26>
    2b14:	21 97       	sbiw	r28, 0x01	; 1
    2b16:	66 0f       	add	r22, r22
    2b18:	77 1f       	adc	r23, r23
    2b1a:	88 1f       	adc	r24, r24
    2b1c:	da f7       	brpl	.-10     	; 0x2b14 <log+0x1c>
    2b1e:	20 e0       	ldi	r18, 0x00	; 0
    2b20:	30 e0       	ldi	r19, 0x00	; 0
    2b22:	40 e8       	ldi	r20, 0x80	; 128
    2b24:	5f eb       	ldi	r21, 0xBF	; 191
    2b26:	9f e3       	ldi	r25, 0x3F	; 63
    2b28:	88 39       	cpi	r24, 0x98	; 152
    2b2a:	20 f0       	brcs	.+8      	; 0x2b34 <log+0x3c>
    2b2c:	80 3e       	cpi	r24, 0xE0	; 224
    2b2e:	30 f0       	brcs	.+12     	; 0x2b3c <log+0x44>
    2b30:	21 96       	adiw	r28, 0x01	; 1
    2b32:	8f 77       	andi	r24, 0x7F	; 127
    2b34:	77 dd       	rcall	.-1298   	; 0x2624 <__addsf3>
    2b36:	ec e7       	ldi	r30, 0x7C	; 124
    2b38:	f0 e0       	ldi	r31, 0x00	; 0
    2b3a:	03 c0       	rjmp	.+6      	; 0x2b42 <log+0x4a>
    2b3c:	73 dd       	rcall	.-1306   	; 0x2624 <__addsf3>
    2b3e:	e9 ea       	ldi	r30, 0xA9	; 169
    2b40:	f0 e0       	ldi	r31, 0x00	; 0
    2b42:	73 df       	rcall	.-282    	; 0x2a2a <__fp_powser>
    2b44:	8b 01       	movw	r16, r22
    2b46:	be 01       	movw	r22, r28
    2b48:	ec 01       	movw	r28, r24
    2b4a:	fb 2e       	mov	r15, r27
    2b4c:	6f 57       	subi	r22, 0x7F	; 127
    2b4e:	71 09       	sbc	r23, r1
    2b50:	75 95       	asr	r23
    2b52:	77 1f       	adc	r23, r23
    2b54:	88 0b       	sbc	r24, r24
    2b56:	99 0b       	sbc	r25, r25
    2b58:	fc dd       	rcall	.-1032   	; 0x2752 <__floatsisf>
    2b5a:	28 e1       	ldi	r18, 0x18	; 24
    2b5c:	32 e7       	ldi	r19, 0x72	; 114
    2b5e:	41 e3       	ldi	r20, 0x31	; 49
    2b60:	5f e3       	ldi	r21, 0x3F	; 63
    2b62:	8f de       	rcall	.-738    	; 0x2882 <__mulsf3x>
    2b64:	af 2d       	mov	r26, r15
    2b66:	98 01       	movw	r18, r16
    2b68:	ae 01       	movw	r20, r28
    2b6a:	ff 90       	pop	r15
    2b6c:	0f 91       	pop	r16
    2b6e:	1f 91       	pop	r17
    2b70:	cf 91       	pop	r28
    2b72:	df 91       	pop	r29
    2b74:	68 dd       	rcall	.-1328   	; 0x2646 <__addsf3x>
    2b76:	3f ce       	rjmp	.-898    	; 0x27f6 <__fp_round>

00002b78 <modf>:
    2b78:	fa 01       	movw	r30, r20
    2b7a:	dc 01       	movw	r26, r24
    2b7c:	aa 0f       	add	r26, r26
    2b7e:	bb 1f       	adc	r27, r27
    2b80:	9b 01       	movw	r18, r22
    2b82:	ac 01       	movw	r20, r24
    2b84:	bf 57       	subi	r27, 0x7F	; 127
    2b86:	28 f4       	brcc	.+10     	; 0x2b92 <modf+0x1a>
    2b88:	22 27       	eor	r18, r18
    2b8a:	33 27       	eor	r19, r19
    2b8c:	44 27       	eor	r20, r20
    2b8e:	50 78       	andi	r21, 0x80	; 128
    2b90:	1f c0       	rjmp	.+62     	; 0x2bd0 <modf+0x58>
    2b92:	b7 51       	subi	r27, 0x17	; 23
    2b94:	88 f4       	brcc	.+34     	; 0x2bb8 <modf+0x40>
    2b96:	ab 2f       	mov	r26, r27
    2b98:	00 24       	eor	r0, r0
    2b9a:	46 95       	lsr	r20
    2b9c:	37 95       	ror	r19
    2b9e:	27 95       	ror	r18
    2ba0:	01 1c       	adc	r0, r1
    2ba2:	a3 95       	inc	r26
    2ba4:	d2 f3       	brmi	.-12     	; 0x2b9a <modf+0x22>
    2ba6:	00 20       	and	r0, r0
    2ba8:	69 f0       	breq	.+26     	; 0x2bc4 <modf+0x4c>
    2baa:	22 0f       	add	r18, r18
    2bac:	33 1f       	adc	r19, r19
    2bae:	44 1f       	adc	r20, r20
    2bb0:	b3 95       	inc	r27
    2bb2:	da f3       	brmi	.-10     	; 0x2baa <modf+0x32>
    2bb4:	0d d0       	rcall	.+26     	; 0x2bd0 <modf+0x58>
    2bb6:	35 cd       	rjmp	.-1430   	; 0x2622 <__subsf3>
    2bb8:	61 30       	cpi	r22, 0x01	; 1
    2bba:	71 05       	cpc	r23, r1
    2bbc:	a0 e8       	ldi	r26, 0x80	; 128
    2bbe:	8a 07       	cpc	r24, r26
    2bc0:	b9 46       	sbci	r27, 0x69	; 105
    2bc2:	30 f4       	brcc	.+12     	; 0x2bd0 <modf+0x58>
    2bc4:	9b 01       	movw	r18, r22
    2bc6:	ac 01       	movw	r20, r24
    2bc8:	66 27       	eor	r22, r22
    2bca:	77 27       	eor	r23, r23
    2bcc:	88 27       	eor	r24, r24
    2bce:	90 78       	andi	r25, 0x80	; 128
    2bd0:	30 96       	adiw	r30, 0x00	; 0
    2bd2:	21 f0       	breq	.+8      	; 0x2bdc <modf+0x64>
    2bd4:	20 83       	st	Z, r18
    2bd6:	31 83       	std	Z+1, r19	; 0x01
    2bd8:	42 83       	std	Z+2, r20	; 0x02
    2bda:	53 83       	std	Z+3, r21	; 0x03
    2bdc:	08 95       	ret

00002bde <__divsf3>:
    2bde:	0c d0       	rcall	.+24     	; 0x2bf8 <__divsf3x>
    2be0:	0a ce       	rjmp	.-1004   	; 0x27f6 <__fp_round>
    2be2:	02 de       	rcall	.-1020   	; 0x27e8 <__fp_pscB>
    2be4:	40 f0       	brcs	.+16     	; 0x2bf6 <__divsf3+0x18>
    2be6:	f9 dd       	rcall	.-1038   	; 0x27da <__fp_pscA>
    2be8:	30 f0       	brcs	.+12     	; 0x2bf6 <__divsf3+0x18>
    2bea:	21 f4       	brne	.+8      	; 0x2bf4 <__divsf3+0x16>
    2bec:	5f 3f       	cpi	r21, 0xFF	; 255
    2bee:	19 f0       	breq	.+6      	; 0x2bf6 <__divsf3+0x18>
    2bf0:	eb cd       	rjmp	.-1066   	; 0x27c8 <__fp_inf>
    2bf2:	51 11       	cpse	r21, r1
    2bf4:	34 ce       	rjmp	.-920    	; 0x285e <__fp_szero>
    2bf6:	ee cd       	rjmp	.-1060   	; 0x27d4 <__fp_nan>

00002bf8 <__divsf3x>:
    2bf8:	0f de       	rcall	.-994    	; 0x2818 <__fp_split3>
    2bfa:	98 f3       	brcs	.-26     	; 0x2be2 <__divsf3+0x4>

00002bfc <__divsf3_pse>:
    2bfc:	99 23       	and	r25, r25
    2bfe:	c9 f3       	breq	.-14     	; 0x2bf2 <__divsf3+0x14>
    2c00:	55 23       	and	r21, r21
    2c02:	b1 f3       	breq	.-20     	; 0x2bf0 <__divsf3+0x12>
    2c04:	95 1b       	sub	r25, r21
    2c06:	55 0b       	sbc	r21, r21
    2c08:	bb 27       	eor	r27, r27
    2c0a:	aa 27       	eor	r26, r26
    2c0c:	62 17       	cp	r22, r18
    2c0e:	73 07       	cpc	r23, r19
    2c10:	84 07       	cpc	r24, r20
    2c12:	38 f0       	brcs	.+14     	; 0x2c22 <__divsf3_pse+0x26>
    2c14:	9f 5f       	subi	r25, 0xFF	; 255
    2c16:	5f 4f       	sbci	r21, 0xFF	; 255
    2c18:	22 0f       	add	r18, r18
    2c1a:	33 1f       	adc	r19, r19
    2c1c:	44 1f       	adc	r20, r20
    2c1e:	aa 1f       	adc	r26, r26
    2c20:	a9 f3       	breq	.-22     	; 0x2c0c <__divsf3_pse+0x10>
    2c22:	33 d0       	rcall	.+102    	; 0x2c8a <__divsf3_pse+0x8e>
    2c24:	0e 2e       	mov	r0, r30
    2c26:	3a f0       	brmi	.+14     	; 0x2c36 <__divsf3_pse+0x3a>
    2c28:	e0 e8       	ldi	r30, 0x80	; 128
    2c2a:	30 d0       	rcall	.+96     	; 0x2c8c <__divsf3_pse+0x90>
    2c2c:	91 50       	subi	r25, 0x01	; 1
    2c2e:	50 40       	sbci	r21, 0x00	; 0
    2c30:	e6 95       	lsr	r30
    2c32:	00 1c       	adc	r0, r0
    2c34:	ca f7       	brpl	.-14     	; 0x2c28 <__divsf3_pse+0x2c>
    2c36:	29 d0       	rcall	.+82     	; 0x2c8a <__divsf3_pse+0x8e>
    2c38:	fe 2f       	mov	r31, r30
    2c3a:	27 d0       	rcall	.+78     	; 0x2c8a <__divsf3_pse+0x8e>
    2c3c:	66 0f       	add	r22, r22
    2c3e:	77 1f       	adc	r23, r23
    2c40:	88 1f       	adc	r24, r24
    2c42:	bb 1f       	adc	r27, r27
    2c44:	26 17       	cp	r18, r22
    2c46:	37 07       	cpc	r19, r23
    2c48:	48 07       	cpc	r20, r24
    2c4a:	ab 07       	cpc	r26, r27
    2c4c:	b0 e8       	ldi	r27, 0x80	; 128
    2c4e:	09 f0       	breq	.+2      	; 0x2c52 <__divsf3_pse+0x56>
    2c50:	bb 0b       	sbc	r27, r27
    2c52:	80 2d       	mov	r24, r0
    2c54:	bf 01       	movw	r22, r30
    2c56:	ff 27       	eor	r31, r31
    2c58:	93 58       	subi	r25, 0x83	; 131
    2c5a:	5f 4f       	sbci	r21, 0xFF	; 255
    2c5c:	2a f0       	brmi	.+10     	; 0x2c68 <__divsf3_pse+0x6c>
    2c5e:	9e 3f       	cpi	r25, 0xFE	; 254
    2c60:	51 05       	cpc	r21, r1
    2c62:	68 f0       	brcs	.+26     	; 0x2c7e <__divsf3_pse+0x82>
    2c64:	b1 cd       	rjmp	.-1182   	; 0x27c8 <__fp_inf>
    2c66:	fb cd       	rjmp	.-1034   	; 0x285e <__fp_szero>
    2c68:	5f 3f       	cpi	r21, 0xFF	; 255
    2c6a:	ec f3       	brlt	.-6      	; 0x2c66 <__divsf3_pse+0x6a>
    2c6c:	98 3e       	cpi	r25, 0xE8	; 232
    2c6e:	dc f3       	brlt	.-10     	; 0x2c66 <__divsf3_pse+0x6a>
    2c70:	86 95       	lsr	r24
    2c72:	77 95       	ror	r23
    2c74:	67 95       	ror	r22
    2c76:	b7 95       	ror	r27
    2c78:	f7 95       	ror	r31
    2c7a:	9f 5f       	subi	r25, 0xFF	; 255
    2c7c:	c9 f7       	brne	.-14     	; 0x2c70 <__divsf3_pse+0x74>
    2c7e:	88 0f       	add	r24, r24
    2c80:	91 1d       	adc	r25, r1
    2c82:	96 95       	lsr	r25
    2c84:	87 95       	ror	r24
    2c86:	97 f9       	bld	r25, 7
    2c88:	08 95       	ret
    2c8a:	e1 e0       	ldi	r30, 0x01	; 1
    2c8c:	66 0f       	add	r22, r22
    2c8e:	77 1f       	adc	r23, r23
    2c90:	88 1f       	adc	r24, r24
    2c92:	bb 1f       	adc	r27, r27
    2c94:	62 17       	cp	r22, r18
    2c96:	73 07       	cpc	r23, r19
    2c98:	84 07       	cpc	r24, r20
    2c9a:	ba 07       	cpc	r27, r26
    2c9c:	20 f0       	brcs	.+8      	; 0x2ca6 <__divsf3_pse+0xaa>
    2c9e:	62 1b       	sub	r22, r18
    2ca0:	73 0b       	sbc	r23, r19
    2ca2:	84 0b       	sbc	r24, r20
    2ca4:	ba 0b       	sbc	r27, r26
    2ca6:	ee 1f       	adc	r30, r30
    2ca8:	88 f7       	brcc	.-30     	; 0x2c8c <__divsf3_pse+0x90>
    2caa:	e0 95       	com	r30
    2cac:	08 95       	ret

00002cae <__fp_mpack>:
    2cae:	9f 3f       	cpi	r25, 0xFF	; 255
    2cb0:	31 f0       	breq	.+12     	; 0x2cbe <__fp_mpack_finite+0xc>

00002cb2 <__fp_mpack_finite>:
    2cb2:	91 50       	subi	r25, 0x01	; 1
    2cb4:	20 f4       	brcc	.+8      	; 0x2cbe <__fp_mpack_finite+0xc>
    2cb6:	87 95       	ror	r24
    2cb8:	77 95       	ror	r23
    2cba:	67 95       	ror	r22
    2cbc:	b7 95       	ror	r27
    2cbe:	88 0f       	add	r24, r24
    2cc0:	91 1d       	adc	r25, r1
    2cc2:	96 95       	lsr	r25
    2cc4:	87 95       	ror	r24
    2cc6:	97 f9       	bld	r25, 7
    2cc8:	08 95       	ret

00002cca <__divmodhi4>:
    2cca:	97 fb       	bst	r25, 7
    2ccc:	09 2e       	mov	r0, r25
    2cce:	07 26       	eor	r0, r23
    2cd0:	0a d0       	rcall	.+20     	; 0x2ce6 <__divmodhi4_neg1>
    2cd2:	77 fd       	sbrc	r23, 7
    2cd4:	04 d0       	rcall	.+8      	; 0x2cde <__divmodhi4_neg2>
    2cd6:	0c d0       	rcall	.+24     	; 0x2cf0 <__udivmodhi4>
    2cd8:	06 d0       	rcall	.+12     	; 0x2ce6 <__divmodhi4_neg1>
    2cda:	00 20       	and	r0, r0
    2cdc:	1a f4       	brpl	.+6      	; 0x2ce4 <__divmodhi4_exit>

00002cde <__divmodhi4_neg2>:
    2cde:	70 95       	com	r23
    2ce0:	61 95       	neg	r22
    2ce2:	7f 4f       	sbci	r23, 0xFF	; 255

00002ce4 <__divmodhi4_exit>:
    2ce4:	08 95       	ret

00002ce6 <__divmodhi4_neg1>:
    2ce6:	f6 f7       	brtc	.-4      	; 0x2ce4 <__divmodhi4_exit>
    2ce8:	90 95       	com	r25
    2cea:	81 95       	neg	r24
    2cec:	9f 4f       	sbci	r25, 0xFF	; 255
    2cee:	08 95       	ret

00002cf0 <__udivmodhi4>:
    2cf0:	aa 1b       	sub	r26, r26
    2cf2:	bb 1b       	sub	r27, r27
    2cf4:	51 e1       	ldi	r21, 0x11	; 17
    2cf6:	07 c0       	rjmp	.+14     	; 0x2d06 <__udivmodhi4_ep>

00002cf8 <__udivmodhi4_loop>:
    2cf8:	aa 1f       	adc	r26, r26
    2cfa:	bb 1f       	adc	r27, r27
    2cfc:	a6 17       	cp	r26, r22
    2cfe:	b7 07       	cpc	r27, r23
    2d00:	10 f0       	brcs	.+4      	; 0x2d06 <__udivmodhi4_ep>
    2d02:	a6 1b       	sub	r26, r22
    2d04:	b7 0b       	sbc	r27, r23

00002d06 <__udivmodhi4_ep>:
    2d06:	88 1f       	adc	r24, r24
    2d08:	99 1f       	adc	r25, r25
    2d0a:	5a 95       	dec	r21
    2d0c:	a9 f7       	brne	.-22     	; 0x2cf8 <__udivmodhi4_loop>
    2d0e:	80 95       	com	r24
    2d10:	90 95       	com	r25
    2d12:	bc 01       	movw	r22, r24
    2d14:	cd 01       	movw	r24, r26
    2d16:	08 95       	ret

00002d18 <memcpy>:
    2d18:	fb 01       	movw	r30, r22
    2d1a:	dc 01       	movw	r26, r24
    2d1c:	02 c0       	rjmp	.+4      	; 0x2d22 <memcpy+0xa>
    2d1e:	01 90       	ld	r0, Z+
    2d20:	0d 92       	st	X+, r0
    2d22:	41 50       	subi	r20, 0x01	; 1
    2d24:	50 40       	sbci	r21, 0x00	; 0
    2d26:	d8 f7       	brcc	.-10     	; 0x2d1e <memcpy+0x6>
    2d28:	08 95       	ret

00002d2a <memset>:
    2d2a:	dc 01       	movw	r26, r24
    2d2c:	01 c0       	rjmp	.+2      	; 0x2d30 <memset+0x6>
    2d2e:	6d 93       	st	X+, r22
    2d30:	41 50       	subi	r20, 0x01	; 1
    2d32:	50 40       	sbci	r21, 0x00	; 0
    2d34:	e0 f7       	brcc	.-8      	; 0x2d2e <memset+0x4>
    2d36:	08 95       	ret

00002d38 <strncpy>:
    2d38:	fb 01       	movw	r30, r22
    2d3a:	dc 01       	movw	r26, r24
    2d3c:	41 50       	subi	r20, 0x01	; 1
    2d3e:	50 40       	sbci	r21, 0x00	; 0
    2d40:	48 f0       	brcs	.+18     	; 0x2d54 <strncpy+0x1c>
    2d42:	01 90       	ld	r0, Z+
    2d44:	0d 92       	st	X+, r0
    2d46:	00 20       	and	r0, r0
    2d48:	c9 f7       	brne	.-14     	; 0x2d3c <strncpy+0x4>
    2d4a:	01 c0       	rjmp	.+2      	; 0x2d4e <strncpy+0x16>
    2d4c:	1d 92       	st	X+, r1
    2d4e:	41 50       	subi	r20, 0x01	; 1
    2d50:	50 40       	sbci	r21, 0x00	; 0
    2d52:	e0 f7       	brcc	.-8      	; 0x2d4c <strncpy+0x14>
    2d54:	08 95       	ret

00002d56 <_exit>:
    2d56:	f8 94       	cli

00002d58 <__stop_program>:
    2d58:	ff cf       	rjmp	.-2      	; 0x2d58 <__stop_program>
